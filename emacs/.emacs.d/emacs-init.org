#+TITLE: GNU Emacs Configuration
#+AUTHOR: Aaron Kuehler
#+EMAIL: aaron.kuehler@gmail.com
#+OPTIONS: toc:nil
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))

+ Created: 2020-11-26
+ Updated: *{{{export-date}}}*

#+TOC: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: h:feb4358b-68f8-40fd-88f0-142ef22d0c11
:END:

** Canonical links to this document
:PROPERTIES:
:CUSTOM_ID: h:134904bf-3f3a-43a9-8be0-17dab61b76d6
:END:

- Git Repo :: http://github.com/indiebrain/.emacs.d/

** What is this?
:PROPERTIES:
:CUSTOM_ID: h:330004be-9269-41e0-bd2a-2a897c0c1bd4
:END:


This document is the canonical source of configuration I use to
configure the Emacs editor to my liking.

It is designed using [[https://en.wikipedia.org/wiki/Literate_programming][Donald Knuth's concept of "Literate Programming"]];
a combination of prose intended to add context for human readers and
inline code blocks used for execution by a computer. Literate
programming allows us to take an expressive and deliberate approach to
generating code and documentation. Emacs' =org-babel= mode enables the
parsing of this document such that the =emacs-lisp= code blocks
contained herein constitute the majority of configuration used to
nudge a vanilla Emacs process into a shape I find useful. The rest of
the content is for humans - and any other machine capable of
extracting meaning from the natural language contextual clues - to
better understand the purpose and rationale behind including the
surrounding bits of configuration.

Each section contains a - hopefully - deeply contextual discussion of
the code contained therein. If something seems misrepresented,
incomplete, or unclear feedback is welcomed. Please submit a ticket on
the repository itself describing the section in question, a quotation
of the prose in question, and a suggestion of what you expected in its
stead.

This document draws from many sources. Some inspirations warrant
specific attention as their study would better inform the reader to
the mindset assumed by the author. The [[https://www.gnu.org/software/emacs/manual/][GNU Emacs Manuals]], Protesilaos
Stavrou's [[https://protesilaos.com/codelog/2019-12-20-vlog-switch-emacs/]["All about switching to Emacs"]], and [[https://www.masteringemacs.org/][Mickey Petersen's
"Mastering Emacs"]] serve as the foundation of technical foundation and
inspiration to use Emacs in the first place. The kernel of inspiration
belongs to the [[https://www.youtube.com/watch?v%3DSzA2YODtgK4][talk]] delivered by Harry R. Schwartz entitled "Getting
started with Org mode". The form of this document is heavily
influenced by the vast, and excellent work of [[https://protesilaos.com][Protesilaos Stavrou]]. My
gratitude to ALL of those whose work whence this derives is vast.

** Initialization
:PROPERTIES:
:CUSTOM_ID: h:4f872bdd-4cc9-41ef-b01d-57a9705ec6e5
:END:

*** =init.el= (for Emacs 27+)
:PROPERTIES:
:CUSTOM_ID: h:f919d17d-7326-4c43-8df2-4b5c3ea981a5
:END:

When an Emacs process starts, by convention, initialization logic is
executed from the =~/.emacs.d/init.el=. My =init.el= has very basic
responsibilities. First, it ensures that the package management and
configuration system is configured, then loads the configuration
provided by this document.

#+begin_example emacs-lisp
(require 'package)

;; In addition to the GNU repository look for external packages in
;; these repositories.
(add-to-list 'package-archives
             '("gnu" . "https://elpa.gnu.org/packages/"))
(add-to-list 'package-archives
             '("non-gnu" . "https://elpa.nongnu.org/nongnu/"))
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/"))

;; Make sure `use-package' is available.
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Configure `use-package' prior to loading it.
(eval-and-compile
  (setq use-package-always-ensure nil)
  (setq use-package-always-defer nil)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally nil)
  (setq use-package-enable-imenu-support t)
  (setq use-package-compute-statistics nil)
  ;; The following is VERY IMPORTANT. Write hooks using their real name
  ;; instead of a shorter version: after-init ==> `after-init-hook'.
  ;;
  ;; This is to empower help commands with their contextual awareness,
  ;; such as `describe-symbol'.
  (setq use-package-hook-name-suffix nil))

(eval-when-compile
  (require 'use-package))

;; Allow packages to declare dependencies on system programs.
(use-package use-package-ensure-system-package
  :ensure t
  :config
  (cond
   ((eq system-type 'darwin)
    (progn
    (setq system-packages-use-sudo nil)
    (setq system-packages-package-manager 'brew)))
   ((eq system-type 'gnu/linux)
    (progn
    (setq system-packages-use-sudo t)
    (setq system-packages-package-manager 'apt)))))

;; I create an "el" version of my Org configuration file as a final step
;; before closing down Emacs. This is done to load the latest version
;; of my code upon startup.
;;
;; Also helps with initialization times. Not that I care too much about
;; those… Hence why I no longer bother with deferring package loading
;; either by default or on a case-by-case basis.
(let* ((conf "~/.emacs.d/emacs-init")
       (el (concat conf ".el"))
       (org (concat conf ".org")))
  (if (file-exists-p el)
      (load-file el)
    (use-package org)
    (org-babel-load-file org)))
#+end_example

*** "Early Init" for Emacs 27+
:PROPERTIES:
:CUSTOM_ID: h:e131b8a0-4ef4-471b-aca5-47623e482802
:END:

Starting with Emacs 27.1, an =early-init.el= is now required to control
things with greater precision. Its code is as follows:

#+begin_example emacs-lisp
;; Initialise installed packages
(setq package-enable-at-startup t)

;; Allow loading from the package cache.
(setq package-quickstart t)

;; Do not resize the frame at this early stage.
(setq frame-inhibit-implied-resize t)
#+end_example

These adjustments are of paramount importance due to changes in the
way Emacs initializes the package manager. Prior to Emacs 27.1, the
=init.el= was supposed to handle that task by means of calling
=package-initialize=. Whereas for Emacs 27.1, the default behavior is
to start the package manager /before/ loading the user's init file.

** About =use-package=
:PROPERTIES:
:CUSTOM_ID: h:e7cceaf7-6d43-4fb7-b510-7e37480abebd
:END:

Emacs 24+ includes =package.el= as the default package management and
configuration system for Emacs. It provides mechanisms to declare
dependencies on and configure /packages/ - bundles of software which
alter the behavior of an Emacs process. A /package/ is just an
emacs-lisp file which is evaluated by Emacs. Some packages are
included with the upstream Emacs distribution, others may come from
external sources. Internally, =package.el= uses [[https://github.com/jwiegley/use-package][use-package]] to declare and configure
packages. Technically, =use-package= interfaces with the Package Manager
provided by =package.el= to provide Package Management capabilities. In
this sense =use-package= is NOT a package manager; it does much more
than installing and removing packages - typical of other Package
Managers with which the reader may be familiar, like Aptitude. Unlike other extensible programs, there are no material distinction
between code provided by the Emacs core and code that is provided from
other sources. External tools have access to the full set of features
provided by Emacs and emacs-lisp - there are no public/private API
distinctions. Emacs is a LISP interpreter - in interprets the
[[https://www.gnu.org/software/emacs/manual/elisp.html][emacs-lisp]] lisp dialect to be precise. The Emacs process evaluates
emacs-lisp and reacts according to the instructions immediately. The core ways in which =use-package= is utilized in this document are:

- To declare in inclusion of external packages. These are decorated
  with the =:ensure= keyword. This tells the Package Manager portion of
  =package.el= that these packages should be fetched and installed from
  external package repositories.
- To configure packages included in the Emacs core. Note that the
  =:ensure= keyword is not needed for these because their =.el= files are
  included in the core of Emacs already.

In several packages you will see the [[https://github.com/jwiegley/use-package#diminishing-and-delighting-minor-modes][:diminish keyword]]. This alters
the behavior of the package's "lighter". A lighter is the piece of
text that a package puts on the mode-line. For example the "Flyspell"
package's lighter is "Fly". With =:diminish= we demand that the lighter
be removed, but Flyspell's capabilities remain in the buffer, as
indicated by its presence in the mode-help-system - =C-h m=.

With =use-package= we can improve the startup performance of
Emacs. Whenever a command is bound to a key it is configured to be
loaded only once invoked. Otherwise we can specify which functions
should be autoloaded by specifying the =:commands= keyword.

I set the variable =use-package-hook-name-suffix= to nil in order to
always type in the proper name of a hook. The default behavior is to
omit the suffix for convenience. But that means that we can no longer
benefit from the contextual awareness of help/documentation commands
(e.g. =C-h o= over any of the symbols/functions/variables below will put
the thing at point as the first completion option).

You should be warned of a common error with handling package installs
(with or without =use-package=): if Emacs complains that the package you
want no longer exists, it means that *you must refresh your package
index* because there is a new version of that package, so the old one
that is still registered on your list has been removed from the
source. Do that with either =M-x package-refresh-contents= or the
package browser =M-x list-packages=.

The =system-packages= package allows us to declare dependencies on
external, system programs on which a particular package depends via the
=:ensure-system-package=. For example the =rg= package - an Emacs interface
to the ripgrep utility - pendents on the =rg= binary being present on the
host system. By specifying it as a dependency of the Emacs =rg= package,
=use-package= will ensure that either the =rg= binary is discover-able on
the user's =$PATH=, or attempt to install the binary if it is not present.

#+begin_example emacs-lisp
;; Make sure `use-package' is available.
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Configure `use-package' prior to loading it.
(eval-and-compile
  (setq use-package-always-ensure nil)
  (setq use-package-always-defer nil)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally nil)
  (setq use-package-enable-imenu-support t)
  ;; The following is VERY IMPORTANT. Write hooks using their real name
  ;; instead of a shorter version: after-init ==> `after-init-hook'.
  ;;
  ;; This is to empower help commands with their contextual awareness,
  ;; such as `describe-symbol'.
  (setq use-package-hook-name-suffix nil))

(eval-when-compile
  (require 'use-package))

;; Allow packages to declare dependencies on system programs.
(use-package use-package-ensure-system-package
  :ensure t)
#+end_example

** About the source code version of this document
:PROPERTIES:
:CUSTOM_ID: h:2172c967-89a4-474b-9435-98c3cd6b47ac
:END:

The above code blocks are NOT declared as =emacs-lisp= source blocks
because they are intended to be examples - they are not actually
included in the configuration provided by this document.

In this document, source code blocks which generate code are contained
between =#+begin_src= and =#end_src= tokens. Note, these tokens will NOT be
visible in some formats of this document - HTML, for example. For Emacs
26+ such code block tokens can be quickly inserted into an =org-mode=
document using the =C-c C-,= key chord. This can create empty blocks, or
blocks from active regions of text. For more information on =org-mode=
blocks, refer to the [[https://orgmode.org/manual/Blocks.html][org-mode documentation]].

Additionally, you will notice some metadata tags specific to =org-mode=
below each heading. These are generated by the functions that are
defined in the package declaration for =org-id=. The idea is to keep
anchor tags consistent when generating a new HTML version of this
document.

This metadata also makes it possible to create immutable internal
links, whenever a reference is needed. To create such links, you can
use =C-c l= to capture the unique ID of the current section and then =C-c
C-l= to create a link (the former is defined in the Org package
declaration — this is an internal link in action).

** COPYING
:PROPERTIES:
:CUSTOM_ID: h:1b9e6455-ba10-4683-88d4-738ecc41cdf6
:END:

Copyright (c) 2019-2020 Aaron Kuehler

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file. If not, see <http://www.gnu.org/licenses/>.

* Base settings
:PROPERTIES:
:CUSTOM_ID: h:cfc86036-2629-41df-868c-f3e4e105976c
:END:

This section contains the relatively few tweaks to default configuration required prior to the configuration of everything else.

** Default working directory
:PROPERTIES:
:CUSTOM_ID: h:83fb2ba5-d6c7-41ac-a9a5-5bccf3a41f69
:END:

Older version of Emacs used to make their default working directory
the current user's =$HOME= directory. I've become accustomed to this
over the years so in newer versions of Emacs I find it very
disorienting when things like =find-file= start in a location other than
=~/=.

#+begin_src emacs-lisp
(setq default-directory "~/")
#+end_src

** Exposing =$PATH= to Emacs on MacOS hosts
:PROPERTIES:
:CUSTOM_ID: h:9568f5a7-cb99-441c-b904-01f7a31a3464
:END:

When Emacs runs on a MacOS host, the user's =$PATH= is not accessible to
the Emacs process. This is problematic when Emacs attempts to use
external programs to support its functions - =ispell= as a back end for
Flyspell for example. =exec-path-from-shell= allows configuration of the
=$PATH= the Emacs process will use when attempting to lookup
programs. This is only executed if Emacs can detect that it is running
on a MacOS host.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns x))
  :ensure t
  :config
  (exec-path-from-shell-initialize)
  (setq exec-path (cons "/opt/local/bin" exec-path))
  (setenv "PATH" (concat "/opt/local/bin:" (getenv "PATH"))))
#+end_src

** Disable GUI components
:PROPERTIES:
:CUSTOM_ID: h:3ac77b45-6a42-42de-88b4-9599c88d0d18
:END:

The following configuration achieves these goals:

- Disable GUI accouterments. I normally use a Windowed variant of
  Emacs. I prefer to optimize space for buffers. As such this removes
  all of the additional GUI buttons, scroll bars, etc to reclaim
  precious viewable space.
- Disable the default "Welcome" buffer. By default, when Emacs is
  initialized, it will display a buffer with documentation and
  resources for new users. It contains lots of orientation
  information, but is not very useful once the basics of Emacs are
  well understood.
- Disable "Minimize" functions. The chords =C-z= and =C-x C-z= involve
  "minimizing" the Emacs frame. I find their accidental invocation
  quite disruptive - these are more normally expected to happen as GUI
  interactions rather than key chords.
- Disable the "Hello file" function. It's cute, but has no real function.

#+begin_src emacs-lisp
(use-package emacs
  :init
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
  :config
  (setq use-file-dialog nil)
  (setq use-dialog-box t)               ; only for mouse events
  (setq inhibit-splash-screen t)
  :bind (("C-z" . nil)
         ("C-x C-z" . nil)
         ("C-h h" . nil)))
#+end_src

** Always rebuild configuration and refresh package cache
:PROPERTIES:
:CUSTOM_ID: h:97d89ac2-45d7-4526-b2e5-c8d4b45ce609
:END:

When Emacs expands this =org-mode= file into the actual elisp code, it
creates a new document: =emacs-init.org= derives =emacs-init.el=. The
latter holds my customization's in the state they were in at the time the
document was created. Any updates require a rewrite.

To make sure that I do not load older settings after having made some
tweaks to my dotemacs, I want to delete that derived file when I
instruct Emacs to terminate its process. This ensures that edits I made
to =emacs-init.org= are parsed into a new =emacs-init.el= at the next
startup. Doing so at the =kill-emacs-hook= is a neat trick to roll over
the cost of building this massive document. We now pay the few second
penalty when terminating the Emacs session. Otherwise we would be
facing delays at the initialization stage.

Note that choosing to load the right file is the task of my =init.el=.
Browse the source code of my dotfiles, of which the present document is
a part of, or read the [[#h:f919d17d-7326-4c43-8df2-4b5c3ea981a5][init.el (for Emacs 27+)]] second of this document.

Similarly, I want to maintain an up-to-date cache with the installed
packages, which is used to speed up boot times, /ceteris paribus/. The
"quickstart" method is part of Emacs 27 or higher

#+begin_src emacs-lisp
(use-package emacs
  :config
  (defun indiebrain/rebuild-emacs-init ()
    "Produce Elisp init from my Org dotemacs.
  Add this to `kill-emacs-hook', to use the newest file in the next
  session. The idea is to reduce startup time, though just by
  rolling it over to the end of a session rather than the beginning
  of it."
    (let ((init-el "~/.emacs.d/emacs-init.el")
          (init-org "~/.emacs.d/emacs-init.org"))
      (when (file-exists-p init-el)
        (delete-file init-el))
      (org-babel-tangle-file init-org init-el)))
  :hook ((kill-emacs-hook . indiebrain/rebuild-emacs-init)
         (kill-emacs-hook . package-quickstart-refresh)))
#+end_src

** Remove mode-line "lighters"
:PROPERTIES:
:CUSTOM_ID: h:dfb6c891-ae43-4baa-a30c-bff1e247e7cd
:END:

Noted in the second [[#h:e7cceaf7-6d43-4fb7-b510-7e37480abebd][About use-package]], we can remove the "lighter" text from the mode-line via the =diminish= package.

#+begin_src emacs-lisp
(use-package diminish
  :ensure
  :after use-package)
#+end_src

** Put customization settings in a "custom.el"
:PROPERTIES:
:CUSTOM_ID: h:e8c1d68e-aebf-499c-b394-807fbd525624
:END:

The customization system for various packages will - by default -
store values in the user's =init.el=. This is a common headache when
syncing configuration across hosts. Instead, here the customization
system is configured to stored outside version control as to prevent
such collisions from happening. This file is intended to be
disposable.

#+begin_src emacs-lisp
(use-package cus-edit
  :config
  (defvar indiebrain/custom-file "~/.emacs.d/custom.el")

  (setq custom-file indiebrain/custom-file)

  (defun indiebrain/cus-edit ()
    (let ((file indiebrain/custom-file))
      (unless (file-exists-p file)
        (make-empty-file file))
      (load-file file)))
  :hook (after-init-hook . indiebrain/cus-edit))
#+end_src

** Fundamentals for Hydras
:PROPERTIES:
:CUSTOM_ID: h:8b9a5767-19a6-492b-80ab-845333fd39fa
:END:

A "hydra" is an ad-hoc mode for mapping commands to a group of more
convenient key bindings. In an active hydra, all of its keys---the
hydra's "heads"---can be typed in any order, keeping the mode active
in the process (if wanted), while at least one key performs the
function of exiting the hydra.

In practice, *I do not use hydras as substitutes for mode maps*.
Instead, I treat them as complementary to minor modes that offer
enhancements to a particular major mode but are otherwise not very
useful outside that niche. Think of cases such as a code linter (the
minor mode) as part of a programming session (major mode).

The reason I use hydras this way is due to the official key binding
conventions that I [generally] follow (as documented in the Emacs
manual). The idea of using =C-c [a-z]= for all these minor modes is
good only if you have a few of them and only if they are more useful
outside a particular task. In other words, it does not scale.

I thus employ =C-c h= as a common prefix for all my hydras (knowing that
it is meant for private use), binding each sequence to the relevant
minor mode's map. An extra key completes the chord following
mnemonics. For instance, a hydra about the linter when that is active
is =C-c h l=.

Look for the =defhydra= macro in the relevant package declarations
(these will evolve over time). Hydras are color-coded as a means of
denoting their behavior with regard to the use of non-defined keys
and the criteria for exiting.

| Color   | Hydra heads         | Other keys          |
|----------+---------------------+---------------------|
| red      | Accept and Continue | Accept and Exit     |
| pink     | Accept and Continue | Accept and Continue |
| amaranth | Accept and Continue | Reject and Continue |
| teal     | Exit                | Reject and Continue |
| blue     | Exit                | Accept and Exit     |

Also check [[https://github.com/abo-abo/hydra][the project's source]] for more information.

#+begin_src emacs-lisp
(use-package hydra
  :ensure)
#+end_src

** Load the color-theme
:PROPERTIES:
:CUSTOM_ID: h:d5fa30fc-3464-4dec-b4cb-bf8b2a78a888
:END:

Emacs 27.1 incorporated the wonderfully complete [[https://protesilaos.com/modus-themes/]["Modus" themes by
Protesilaos Stravrou]]. They're designed to be highly accessible and
meet WCAG AAA accessibility standards. There are two modus themes -
operandi, and vivendi. Operandi provides a light-background color
theme; while vivendi provides a dark-background color theme. Each
theme provides a considerable level of flexibility in its
configuration. The default background colors provide a bit too much
contrast for my eyes, so I provide overrides to the default background
colors. I provide a slightly darker background than the full-white for
the vivendi theme, and a slightly lighter than full-black background
for the operandi theme.

#+begin_src emacs-lisp
(use-package modus-themes
  :ensure
  :config
  (setq modus-themes-hl-line 'intense-background)

  (setq modus-themes-vivendi-color-overrides
        '((bg-main . "#272727")
          ("bg-alt"  . "#655b53")))

  (setq modus-themes-operandi-color-overrides
        '(("bg-main" . "#eee8d5")
          ("bg-alt"  . "#fdf6e3")))

  (defmacro modus-themes-format-sexp (sexp &rest objects)
    `(eval (read (format ,(format "%S" sexp) ,@objects))))

  (dolist (theme '("vivendi" "operandi"))
    (modus-themes-format-sexp
     (defun modus-%1$s-theme-load ()
       (setq modus-%1$s-theme-slanted-constructs t
             modus-%1$s-theme-bold-constructs t
             modus-%1$s-theme-fringes 'subtle ; {nil,'subtle,'intense}
             modus-%1$s-theme-mode-line 'moody ; {nil,'3d,'moody}
             modus-%1$s-theme-syntax 'alt-syntax ; {nil,faint,'yellow-comments,'green-strings,'yellow-comments-green-strings,'alt-syntax,'alt-syntax-yellow-comments}
             modus-%1$s-theme-intense-hl-line t
             modus-%1$s-theme-intense-paren-match t
             modus-%1$s-theme-links 'faint ; {nil,'faint,'neutral-underline,'faint-neutral-underline,'no-underline}
             modus-%1$s-theme-no-mixed-fonts nil
             modus-%1$s-theme-prompts nil ; {nil,'subtle,'intense}
             modus-%1$s-theme-completions 'moderate ; {nil,'moderate,'opinionated}
             modus-%1$s-theme-diffs nil ; {nil,'desaturated,'fg-only}
             modus-%1$s-theme-org-blocks 'grayscale ; {nil,'grayscale,'rainbow}
             modus-%1$s-theme-headings  ; Read further below in the manual for this one
             '((1 . section)
               (2 . line)
               (t . rainbow-line-no-bold))
             modus-%1$s-theme-variable-pitch-headings nil
             modus-%1$s-theme-scale-headings t
             modus-%1$s-theme-scale-1 1.1
             modus-%1$s-theme-scale-2 1.15
             modus-%1$s-theme-scale-3 1.21
             modus-%1$s-theme-scale-4 1.27
             modus-%1$s-theme-scale-5 1.33)
       (load-theme 'modus-%1$s t))
     theme))

  (defun modus-themes-toggle ()
    "Toggle between `modus-operandi' and `modus-vivendi' themes."
    (interactive)
    (if (eq (car custom-enabled-themes) 'modus-operandi)
        (progn
          (disable-theme 'modus-operandi)
          (modus-vivendi-theme-load))
      (disable-theme 'modus-vivendi)
      (modus-operandi-theme-load)))

  (modus-vivendi-theme-load))
#+end_src

** Typeface configurations
:PROPERTIES:
:CUSTOM_ID: h:92da7adc-eba1-4892-b74c-bd602861efea
:END:

*** Bidirectional writing and ~so-long.el~
:PROPERTIES:
:CUSTOM_ID: h:eb3413b9-d8bc-44a8-ae00-f4ce39831542
:END:

Emacs supports all kinds of languages. However, I only ever read/write
with the Latin alphabet. So, while I appreciate the fact that Emacs
can naively handle other scripts, I have no use for that particular
feature. Setting the default directional-ity  to what my languages use
can help improve the responsiveness of Emacs in some cases.

Consistent performance is the reason to also enable
=global-so-long-mode=, built into Emacs versions 27+, which allows the
active major mode to gracefully adapt to buffers with very long lines.
What "very long" means is, of course, configurable: =M-x find-library
so-long= covers several customization options, though I find that the
defaults require no further intervention from my part.

The code below is a minor adaptation of the insights of Alain M. Lafon
in the [[https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html][Comprehensive guide on handling long lines in Emacs]]
(2020-09-29).

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t))

(use-package so-long
  :config
  (global-so-long-mode 1))
#+end_src

* Selection candidates and search methods
:PROPERTIES:
:CUSTOM_ID: h:3672aa42-5caa-4fb1-a1ed-0f92a2705692
:END:

** In-buffer completions
:PROPERTIES:
:CUSTOM_ID: h:86E59081-F057-4B7C-969E-012487A87EDC
:END:

The "[[https://company-mode.github.io/][Complete Anything]]" (=company=) package is an extensible text
completion framework which comes with several backends. =company-mode= is
disabled by default. This configuration only enables =company-mode= in
buffers dealing with programming languages. More details on this are
available in the [[#h:8A4237AB-61F5-498A-8E32-390EB783DA37][Programming Language specific support]] section of this
document.

This configures the behavior of =company-mode= itself, such that:

- The completion pop-over will display completion candidates after the point
  has been idle in front of a token after 300ms.
- When the completion pop-over is present, the selection may be changed
  by pressing =C-n= to move the selection to next candidate, or
  =C-p= to move to the previous candidate, in the completion list.
- To choose a completion candidate use =RET= or =C-:=.

#+begin_src emacs-lisp
(use-package company
  :ensure
  :diminish
  :bind (:map company-active-map
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous)
              ("C-:" . company-complete))
  :config
  (setq company-idle-delay 0.3))
#+end_src

** Completion framework and extras
:PROPERTIES:
:CUSTOM_ID: h:efcb1075-f3de-4a66-b7fd-6f3db1813d64
:END:

The optimal way of using Emacs is through searching and narrowing
selection candidates. Spend less time worrying about where things are
on the screen a more on how fast you can bring them into focus. This
is, of course, a matter of realigning priorities, as we still wish to
control every aspect of the interface.

*** Helm
:PROPERTIES:
:CUSTOM_ID: h:BFBB5BF3-80BA-429B-AA9B-61D56819EF2B
:END:

Helm is an Emacs framework for incremental completions and narrowing
selections. It provides an easy-to-use API for developers wishing to
build their own Helm applications in Emacs, powerful search tools and
dozens of already built-in commands providing completion to almost
everything.

**** Basic configuration
:PROPERTIES:
:CUSTOM_ID: h:FFD4DE6E-5113-4DDF-AE07-EB466AEAC8A9
:END:

This configuration deeply - perhaps too much so - integrates Helm
into the Emacs interface. It alters the behavior of standard key
chords to "enhance" their function with Helm's completion and
selection capabilities. Of note, the behavior of
=execute-extended-command=, (=M-x=) is altered such that the user is
presented with a filterable list of candidates for execution, rather
than an empty prompt. Additionally, any key chord bound to the
candidate will be displayed as part of its list entry.

Some additional configuration to the =helm= system itself warrant
description here:

- =helm-M-x-fuzzy-match= allows fuzzy filtering of command candidates
  via =helm-M-x= (=M-x)= interface.
- =helm-candidate-number-limit= limits the number of candidates when no
  filter is provided. This helps keep the interface responsive.
- =helm-ff-skip-boring-files= prevents files matching the regular
  expressions in =helm-boring-file-regexp-list= from appearing in the
  results of =helm-find-files=. The defaults include many common
  compiled and temporary file extensions and can be altered to taste.


#+begin_src emacs-lisp
(use-package helm
  :ensure
  :bind (("C-x f" . helm-for-files)
         ("M-x" . helm-M-x))
  :config
  (use-package helm-config)
  (setq helm-candidate-number-limit 100
        helm-ff-skip-boring-files t
        helm-M-x-fuzzy-match t))
#+end_src

** Search configuration and extensions
:PROPERTIES:
:CUSTOM_ID: h:F8450875-4A6A-4820-A1F8-EAD091C13AB8
:END:

This section enhances Emacs' ability to filter and locate items.

*** isearch
:PROPERTIES:
:CUSTOM_ID: h:CFC9CEB2-1368-4AEC-8993-BE69D840939C
:END:

The built-in Emacs search capabilities - =isearch= - are powerful and
ergonomic. It doubles as a navigation mechanism when the structure or
content of a document is well known.

For more documentation on =isearch= see the help menu =C-h k C-s=. The
following is a sample of the most used key chords:

| Key chord | Description                  |
|-----------+------------------------------|
| C-s C-w   | Search char or word at point |
| M-s .    | Similar, but broader match   |
| M-s o     | Run `occur' on regexp        |
| M-s h r   | Highlight regexp             |
| M-s h u   | Undo the highlight           |
| C-s M-r   | Toggle regexp search         |
| M-%       | Run `query-replace'          |
| C-M-%     | `query-replace-regexp'       |

Many commands can be invoked while running =isearch= to operate on the
current match. For example, =C-s SEARCH M-s o= will produce an "Occur"
buffer with the contents of the search terms.

Replace commands can be invoked on an active region. Furthermore, you
do no need to confirm each instance of an action. Responding with =!= to
an action confirmation prompt will apply the action to the remaining
matches of a search.

The combined effect of the variables for whitespace is a valuable
hack: typing a space is the same as inserting a wildcard, which is
much more useful as far as I am concerned. A single space represents
a wildcard that matches items in a non-greedy fashion. *This affects
regular searches* (the standard =C-s= and =C-r=). The regexp-sensitive
functions =C-M-s= and =C-M-r= remain in tact. You can always toggle
whitespace matching behavior while performing a search, with =M-s SPC=
(revert back to just literal spaces).

#+begin_src emacs-lisp
(use-package isearch
  :diminish
  :config
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited))
#+end_src

*** Occur (replace.el)
:PROPERTIES:
:CUSTOM_ID: h:15A7CCE8-1D37-431E-8811-4B73E853DA71
:END:

The =setq= forms are mere stylistic tweaks for the buffer that =M-x occur=
produces. The faces come from the Modus themes.

The functions are simple tools to either produce a list with all URLs
present in the buffer (=indiebrain/occur-url=), or prompt you for visiting a
URL from those available using completion methods.

#+begin_src emacs-lisp
(use-package replace
  :config
  (setq list-matching-lines-jump-to-current-line t)
  ;; See my "Modus themes" for these inherited faces
  (setq list-matching-lines-buffer-name-face
        '(:inherit modus-theme-intense-neutral :weight bold))
  (setq list-matching-lines-current-line-face
        '(:inherit modus-theme-special-mild))

  (defun indiebrain/occur-url ()
    "Produce list with all URLs in the current buffer."
    (interactive)
    (let ((urls browse-url-button-regexp))
      (occur urls "\\&")))

  (defun indiebrain/occur-browse-url-in-buffer ()
    "Run `eww' on a URL from the buffer using completion.
Also see `indiebrain/occur-url'."
    (interactive)
    (let ((matches nil))
      (save-excursion
        (goto-char (point-min))
        (while (search-forward-regexp browse-url-button-regexp nil t)
          (push (match-string-no-properties 0) matches)))
      (eww
       (completing-read "Browse URL: " matches nil t))))

  (defun indiebrain/occur-visit-or-list-urls (&optional arg)
    "Wrap `indiebrain/occur-visit-or-list-urls' and `indiebrain/occur-url'.
Meant to economise on key bindings."
    (interactive "P")
    (if arg
        (indiebrain/occur-url)
      (indiebrain/occur-browse-url-in-buffer)))

  :hook ((occur-mode-hook . hl-line-mode)
         (occur-mode-hook . (lambda ()
                              (toggle-truncate-lines t))))
  :bind (("M-s u" . indiebrain/occur-visit-or-list-urls)
         ("M-s M-o" . multi-occur)
         :map occur-mode-map
         ("t" . toggle-truncate-lines)))
#+end_src

*** wgrep (writable grep)
:PROPERTIES:
:CUSTOM_ID: h:8B7E1B4C-D129-4F7E-A4AB-DEF5531C9F9C
:END:

With =wgrep= we can directly edit the results of a =grep= and save the
changes to all affected buffers. In principle, this is the same as
what the built-in =occur= offers. We can use it to operate on a list of
matches by leveraging the full power of Emacs' editing capabilities
(e.g. keyboard macros, multiple cursors…).

#+begin_src emacs-lisp
(use-package wgrep
  :ensure
  :commands wgrep
  :config
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  :bind (:map grep-mode-map
              ("e" . wgrep-change-to-wgrep-mode)
              ("C-x C-q" . wgrep-change-to-wgrep-mode)))
#+end_src

*** ripgrep (rg.el)
:PROPERTIES:
:CUSTOM_ID: h:53A85DAA-88A4-4FA5-A6D3-681CBB041108
:END:

This is a package that allows us to interface with the external
command line program called "ripgrep".

What is particularly appealing about =rg.el= is that it follows the
interface paradigms of built-in Emacs functions, such as =grep= or
=occur=. With regard to the latter, it even uses the same key to
convert the results' buffer into an editable one: =e= (the ability to
write changes is provided by the =wgrep= package [[*wgrep (writable grep)][defined above]].

Furthermore, =rg.el= interfaces with =ibuffer=, another built-in package, to
list saved searches (see my =indiebrain/rg-save-search-as-name= in the package
declaration below). Saved searches are regular buffers. You can switch
to any of them the normal way.

While inside of an =rg.el= buffer, hit =m= to produce a transient menu from
where you can refine your search. This works just like =magit=. In
addition, you can consult the universal =C-h m= for documentation
concerning the major mode you are in.

Concerning the key bindings for navigating the results buffer, I find
that the standard motions should retain their general function, while
moving between file headings can be done with =M-{n,p}=.

#+begin_src emacs-lisp
(use-package rg
  :ensure-system-package rg
  :config
  (setq rg-group-result t)
  (setq rg-hide-command t)
  (setq rg-show-columns nil)
  (setq rg-show-header t)
  (setq rg-custom-type-aliases nil)
  (setq rg-default-alias-fallback "all")

  (rg-define-search indiebrain/rg-vc-or-dir
                    "RipGrep in project root or present directory."
                    :query ask
                    :format regexp
                    :files "everything"
                    :dir (or (vc-root-dir)              ; search root project dir
                             default-directory)         ; or from the current dir
                    :confirm prefix
                    :flags ("--hidden -g !.git"))

  (rg-define-search indiebrain/rg-ref-in-dir
                    "RipGrep for thing at point in present directory."
                    :query point
                    :format regexp
                    :files "everything"
                    :dir default-directory
                    :confirm prefix
                    :flags ("--hidden -g !.git"))

  (defun indiebrain/rg-save-search-as-name ()
    "Save `rg' buffer, naming it after the current search query.

This function is meant to be mapped to a key in `rg-mode-map'."
    (interactive)
    (let ((pattern (car rg-pattern-history)))
      (rg-save-search-as-name (concat "«" pattern "»"))))

  :bind (("M-s g" . indiebrain/rg-vc-or-dir)
         ("M-s r" . indiebrain/rg-ref-in-dir)
         :map rg-mode-map
         ("s" . indiebrain/rg-save-search-as-name)
         ("C-n" . next-line)
         ("C-p" . previous-line)
         ("M-n" . rg-next-file)
         ("M-p" . rg-prev-file)))
#+end_src

*** =helm-swoop= - interactive text selection
:PROPERTIES:
:CUSTOM_ID: h:43DC0E11-7819-4D99-A85C-524B5F28902C
:END:

While the standard search and replace functionality of Emacs works
exceptionally well, it is sometimes nice to perform actions over a
collection of selection matches. This is the role of
=helm-swoop=. Using the =helm= interface, textual selections gain the
benefit of helm's group actions, such as edit all matches in palace at
the same time. This seems to be analogous to the role typically
fulfilled by =occur=, but integrated into the =helm= system itself.

- Start a =helm-swoop= buffer with =M-i=. This starts an interactive menu
  in which matches to the typed candidate will appear. Matches If the
  point happens to be over a term, this term is selected as the match
  candidate for the =helm-swoop= buffer. Initially, =helm-swoop= will
  match candidates in the current buffer.
- An =isearch= can be turned into a =helm-swoop= buffer. When conducting
  an interactive search, =M-i= with send the isearch term to a new
  =helm-swoop= buffer.
- While in a =helm-swoop= buffer, the search may be expanded to all
  open buffers - a =helm-swoop-all= buffer - by pressing =M-i= again.
- If instead it is desired to search across a subset of open buffers,
  consider the =heml-swoop-multi= buffer. This can be started by either
  =C-x M-i=, or from a =heml-swoop= buffer by pressing =M-m=.

#+begin_src emacs-lisp
(use-package helm-swoop
  :ensure
  :config
  ;; Save buffer when helm-multi-swoop-edit complete
  (setq helm-multi-swoop-edit-save t)
  ;; If this value is t, split window inside the current window
  (setq helm-swoop-split-with-multiple-windows nil)
  ;; If this value is t, split window inside the current window
  (setq helm-swoop-split-with-multiple-windows nil)
  ;; If you prefer fuzzy matching
  (setq helm-swoop-use-fuzzy-match t)
  :bind (("M-i" . 'helm-swoop)
         ("M-I" . 'helm-swoop-back-to-last-point)
         ("C-c M-i" . 'helm-multi-swoop)
         ("C-x M-i" . 'helm-multi-swoop-all)
         ;; When doing isearch, hand the word over to helm-swoop
         :map isearch-mode-map
         ("M-i" . helm-swoop-from-isearch)
         ;; From helm-swoop to helm-multi-swoop-all
         :map helm-swoop-map
         ("M-i" . 'helm-multi-swoop-all-from-helm-swoop)
         ;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
         ("M-m" . 'helm-multi-swoop-current-mode-from-helm-swoop)))
#+end_src
*** The silver searcher
:PROPERTIES:
:CUSTOM_ID: h:E11FA0C4-B256-469A-922B-9F334EE52A3D
:END:

=ag= is an external search tool which describes itself as:

#+begin_example
Like ack, but faster.
#+end_example

Functionally, it searches the contents of files for a given pattern
and returns contextual information about matches. The =ag= package is a
Emacs interface around this external tool.

#+begin_src emacs-lisp
(use-package ag
  :ensure
  :ensure-system-package ag)
#+end_src

** Project navigation
:PROPERTIES:
:CUSTOM_ID: h:45BB62A4-8381-499F-9404-D613FF217434
:END:

A "project" is a context which relates file system objects - trees,
files, symlinks, etc. Emacs has no sophisticated sense of "Projects",
per-se. However, it is sometimes beneficial to be able to relate to
objects on the file system as if they were contextually related in
this way. This configuration makes use of the =projectile= "Project
Interaction Library".

- =projectile-enable-caching= creates an index of the content of a
  project; keeping the interface snappy in large projects. This comes
  with the downside that if a project's content are modified via
  a-tool-external-to-Emacs the cache may be out of sync with the
  actual on-disk representation of the project. In this case the
  project cache may be invalidated and rebuilt via =C-c p i=.
- =projectile-indexing-method= defines the method =projectile= will use to
  perform indexing. The alien indexing method optimizes to the limit
  the speed of the hybrid indexing method. This means that Projectile
  will not do any processing of the files returned by the external
  commands and you’re going to get the maximum performance possible.
  This behavior makes a lot of sense for most people, as they’d
  typically be putting ignores in their VCS config and won’t care
  about any additional ignores/unignores/sorting that Projectile might
  also provide.
- =projectile-completion-system= and =projectile-switch-project-action=
  integrates =helm= into projectile. Helm provides interactive
  searching, narrowing, etc in the context of projects.
- In order to keep a consistent experience when performing narrowing
  and selections within projects, we make =projectile= aware that it
  should present such buffers with =helm=.

#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :after helm
  :bind
  (("C-c p" . projectile-command-map))
  :config
  (setq projectile-enable-caching t)
  (setq projectile-indexing-method 'alien)

  ;; Use helm as the completion framwork for projectiles built in
  ;; narrowing functions.
  (use-package helm-projectile
    :ensure
    :after (helm projectile)
    :config
    (helm-projectile-on))
  (setq projectile-completion-system 'helm)
  (setq projectile-switch-project-action 'helm-projectile)
  (projectile-mode))
#+end_src

*** Narrowing and selections within projects
:PROPERTIES:
:CUSTOM_ID: h:4F4F1FE2-4FE8-4F26-9BAB-54D332AAD132
:END:

Projectile adds the ability to perform searches scoped to the context
of a project. This section configures various mechanisms for searching
through piles of related file system objects.

**** The silver searcher (helm-ag)
:PROPERTIES:
:CUSTOM_ID: h:2C4D9DD2-7103-4B64-88C3-B6CEDA5044E0
:END:

=ag= is described in detail in the [[#h:E11FA0C4-B256-469A-922B-9F334EE52A3D][The silver searcher]] section of this
document. This bit presents matches from an =ag= search to the user
inside of the =helm= completion framework. This allows for more
consistent narrowing, and selection based on the rest of this
document.

To initiate an =ag= search in a project, use the =C-p s s= key chord.

#+begin_src emacs-lisp
(use-package helm-ag
  :ensure
  :after (helm ag))
#+end_src

**** ripgrep
:PROPERTIES:
:CUSTOM_ID: h:92CB5D6C-F99E-410D-9536-B03DCF998649
:END:

=ripgrep= is described in detail in the [[#h:047BEA3D-BBB2-4B63-A029-1C3710F70763][ripgrep]] section of this
document. This bit presents matches from a =ripgrep= search to the user
inside of the =helm= completion framework. This allows for more
consistent narrowing, and selection based on the rest of this
document.

To initiate an =ripgrep= search in a project, use the =C-p s r= key chord.

#+begin_src emacs-lisp
(use-package helm-rg
  :ensure
  :after (helm rg))
#+end_src

* Motion
:PROPERTIES:
:CUSTOM_ID: h:23D3BDB3-364E-4829-A1AD-A83A704B2ED7
:END:

** Expanding / contracting regions
:PROPERTIES:
:CUSTOM_ID: h:41A87044-ED1A-4290-9838-987AF803F361
:END:

When selecting regions, it is sometimes quicker or more cognitively
convenient, to expand or contract a region based on contextual
units. For example, expanding from a character, to a word, to a
sentence, to a paragraph, and so on.

This is the role of the =expand-region= package. Additionally,
=expand-region= is syntactically aware and smart enough to work within
most of the programming major modes - allowing for simple selection of
atoms and constructs within the syntax of a program.

#+begin_src emacs-lisp
(use-package expand-region
  :ensure
  :bind (("C-=" . 'er/expand-region)
         ("C--" . 'er/contract-region)))
#+end_src

* Directory, buffer, window management
:PROPERTIES:
:CUSTOM_ID: h:3b94740d-e1ce-4016-991c-4fa35b76a719
:END:

** Dired (directory editor, file manager)
:PROPERTIES:
:CUSTOM_ID: h:2591A95A-FC9F-40DA-9E24-A327A453606D
:END:

The directory editor - =dired= - is a built-in tool which acts performs
file management operations inside an Emacs buffer. One can
interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run
shell commands, and more.

*** Base configuration
:PROPERTIES:
:CUSTOM_ID: h:F34BE6DD-495C-49A2-80D8-6B735B2C39F1
:END:

This section configures =dired= such that:

- recursive copy and delete are performed without prompting for confirmation
- deleted items are move to the trash, rather than immediately freed with =rm=
- when viewing a tree (directory)
  - the implicit directories (=./=, and =../=) are omitted
  - hidden (dotfiles) files are included and sorted first
- when two =dired= buffers are side-by-side, rename and copy operations
  will assume that you intend the directory of the other dired buffer
  as the target of such actions.
- For Emacs 27.1, =dired= can automatically create destination
  directories for its copy and remove operations. So you can, for
  example, rename file to =/non-existent-path/file= and dired will make
  the =/noexistent-path= directory before moving the =file= there.

The commands with the =contrib/= prefix in =dired-aux= are copied from the
[[https://github.com/oantolin/emacs-config][Emacs configurations of Omar Antolín Camarena]]. They let you insert the
path of a bookmarked directory while performing an action such as
copying and renaming/moving a file.

#+begin_src emacs-lisp
(use-package dired
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv")
  (setq dired-dwim-target t)
  ;; Note that the the syntax for `use-package' hooks is controlled by
  ;; the `use-package-hook-name-suffix' variable. The "-hook" suffix is
  ;; not an error of mine.
  :hook ((dired-mode-hook . hl-line-mode)))

(use-package dired-aux
  :config
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)

  (defmacro indiebrain/dired-fd (name doc prompt &rest flags)
    "Make commands for selecting 'fd' results with completion.
NAME is how the function should be named. DOC is the function's
documentation string. PROMPT describes the scope of the query.
FLAGS are the command-line arguments passed to the 'fd'
executable, each of which is a string."
    `(defun ,name (&optional arg)
       ,doc
       (interactive "P")
       (let* ((vc (vc-root-dir))
              (dir (expand-file-name (or vc default-directory)))
              (regexp (read-regexp
                       (format "%s matching REGEXP in %s: " ,prompt
                               (propertize dir 'face 'bold))))
              (names (process-lines "fd" ,@flags regexp dir))
              (buf "*FD Dired*"))
         (if names
             (if arg
                 (dired (cons (generate-new-buffer-name buf) names))
               (find-file
                (completing-read (format "Items matching %s (%s): "
                                         (propertize regexp 'face 'success)
                                         (length names))
                                 names nil t))))
         (user-error (format "No matches for « %s » in %s" regexp dir)))))

  (indiebrain/dired-fd
   indiebrain/dired-fd-dirs
   "Search for directories in VC root or PWD.
With \\[universal-argument] put the results in a `dired' buffer.
This relies on the external 'fd' executable."
   "Subdirectories"
   "-i" "-H" "-a" "-t" "d" "-c" "never")

  (indiebrain/dired-fd
   indiebrain/dired-fd-files-and-dirs
   "Search for files and directories in VC root or PWD.
With \\[universal-argument] put the results in a `dired' buffer.
This relies on the external 'fd' executable."
   "Files and dirs"
   "-i" "-H" "-a" "-t" "d" "-t" "f" "-c" "never")

  (defun contrib/cdb--bookmarked-directories ()
    (bookmark-maybe-load-default-file)
    (cl-loop for (name . props) in bookmark-alist
             for fn = (cdr (assq 'filename props))
             when (and fn (string-suffix-p "/" fn))
             collect (cons name fn)))

  (defun contrib/cd-bookmark (bm)
    "Insert the path of a bookmarked directory."
    (interactive
     (list (let ((enable-recursive-minibuffers t))
             (completing-read
              "Directory: " (contrib/cdb--bookmarked-directories) nil t))))
    (when (minibufferp)
      (delete-region (minibuffer-prompt-end) (point-max)))
    (insert (cdr (assoc bm (contrib/cdb--bookmarked-directories)))))

  :bind (("M-s d" . indiebrain/dired-fd-dirs)
         ("M-s z" . indiebrain/dired-fd-files-and-dirs)
         :map dired-mode-map
         ("C-+" . dired-create-empty-file)
         ("M-s f" . nil)
         :map minibuffer-local-filename-completion-map
         ("C-c d" . contrib/cd-bookmark)))

;; NOTE de facto deprecated because of my `indiebrain/dired-fd' functions
(use-package find-dired
  :disabled
  :after dired
  :config
  (setq find-ls-option
        '("-ls" . "-AGFhlv"))
  (setq find-name-arg "-iname"))

(use-package async :ensure)

(use-package dired-async
  :after (dired async)
  :hook (dired-mode-hook . dired-async-mode))
#+end_src

*Pro tip* while renaming or copying a file, =M-n= will return its original
name, thus allowing you to easily {pre,ap}pend to it. This leverages
an intriguing concept of Emacs' design called "future history"
(because =M-p= goes back to your previous entries). The notion of the
future history, when applied, is basically an educated guess of what
the user would want to do in the current context, given that they are
not searching through their previous actions.

*** =dired=-like view of the "trash"
:PROPERTIES:
:CUSTOM_ID: h:C29470C3-ED95-4178-A429-4E06E551F912
:END:

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash. Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked. Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(use-package trashed
  :ensure
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

*** Dired disk usage (du)
:PROPERTIES:
:CUSTOM_ID: h:CB66AEC3-CDE7-4A31-BB1D-876F5F5A61DA
:END:

The POSIX =du= command estimates file space usage. =dired-du-mode= adds
the ability to check file space usage of a tree (directory).

#+begin_src emacs-lisp
(use-package dired-du
  :ensure
  :commands dired-du-mode)
#+end_src

** Working with buffers
:PROPERTIES:
:CUSTOM_ID: h:3911977F-D9EC-4282-A904-EE88545395A4
:END:

*** Buffer lists
:PROPERTIES:
:CUSTOM_ID: h:505CADEB-B1E3-4E9A-9E73-A446FB7A4F5F
:END:

=ibuffer= is a built-in replacement for =list-buffers= that allows for
fine-grained control over the buffer list. For this reason I bind it to
=C-x C-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[*Dired (directory editor, file manager)][Dired (directory editor, file manager)]])
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= on marked buffers or its regular-expression-aware
  equivalent.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

The following configuration deviates from the default behavior in the
following ways:

- Prompt for confirmation only when deleting a modified buffer.
- Hide the summary.
- Do not open on the other window (not focused window).
- Do not show empty filter groups.
- Do not cycle movements. So do not go to the top when moving downward
  at the last item on the list.

#+begin_src emacs-lisp
(use-package ibuffer
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)

  (defun indiebrain/buffers-major-mode (&optional arg)
    "Select buffers that match the current buffer's major mode.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly. Else use standard completion."
    (interactive "P")
    (let* ((major major-mode)
           (prompt "Buffers for ")
           (mode-string (format "%s" major))
           (mode-string-pretty (propertize mode-string 'face 'success)))
      (if arg
          (ibuffer t (concat "*" prompt mode-string "*")
                   (list (cons 'used-mode major)))
        (switch-to-buffer
         (read-buffer
          (concat prompt mode-string-pretty ": ") nil t
          (lambda (pair) ; pair is (name-string . buffer-object)
            (with-current-buffer (cdr pair) (derived-mode-p major))))))))

  (defun indiebrain/buffers-vc-root (&optional arg)
    "Select buffers that match the present `vc-root-dir'.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly. Else use standard completion.

When no VC root is available, use standard `switch-to-buffer'."
    (interactive "P")
    (let* ((root (vc-root-dir))
           (prompt "Buffers for VC ")
           (vc-string (format "%s" root))
           (vc-string-pretty (propertize vc-string 'face 'success)))
      (if root
          (if arg
              (ibuffer t (concat "*" prompt vc-string "*")
                       (list (cons 'filename (expand-file-name root))))
            (switch-to-buffer
             (read-buffer
              (concat prompt vc-string-pretty ": ") nil t
              (lambda (pair) ; pair is (name-string . buffer-object)
                (with-current-buffer (cdr pair) (string= (vc-root-dir) root))))))
        (call-interactively 'switch-to-buffer))))

  :hook (ibuffer-mode-hook . hl-line-mode)
  :bind (("M-s b" . indiebrain/buffers-major-mode)
         ("M-s v" . indiebrain/buffers-vc-root)
         ("C-x C-b" . ibuffer)
         :map ibuffer-mode-map
         ("* f" . ibuffer-mark-by-file-name-regexp)
         ("* g" . ibuffer-mark-by-content-regexp) ; "g" is for "grep"
         ("* n" . ibuffer-mark-by-name-regexp)
         ("s n" . ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
         ("/ g" . ibuffer-filter-by-content)))
#+end_src

*** Scratch buffers per-major-mode
:PROPERTIES:
:CUSTOM_ID: h:5F13EFA3-5714-4E20-91ED-1945E6F8B8CF
:END:

This package will produce a buffer that matches the major mode of the
one you are currently in. Use it with =M-x scratch=. Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead. Simple yet
super effective!

The =indiebrain/scratch-buffer-setup= simply adds some text in the buffer
and renames it appropriately for the sake of easier discovery. I got the
idea of copying the region from [[https://gist.github.com/eev2/52edbfdb645e26aefec19226c0ca7ad0][a snippet shared by eev2 on GitHub]].

#+begin_src emacs-lisp
(use-package scratch
  :ensure
  :config
  (defun indiebrain/scratch-buffer-setup ()
    "Add contents to `scratch' buffer and name it accordingly.
If region is active, add its contents to the new buffer."
    (let* ((mode major-mode)
           (string (format "Scratch buffer for: %s\n\n" mode))
           (region (with-current-buffer (current-buffer)
                     (if (region-active-p)
                         (buffer-substring-no-properties
                          (region-beginning)
                          (region-end)))
                     ""))
           (text (concat string region)))
      (when scratch-buffer
        (save-excursion
          (insert text)
          (goto-char (point-min))
          (comment-region (point-at-bol) (point-at-eol)))
        (forward-line 2))
      (rename-buffer (format "*Scratch for %s*" mode) t)))
  :hook (scratch-create-buffer-hook . indiebrain/scratch-buffer-setup)
  :bind ("C-c s" . scratch))
#+end_src

*** Unique names for buffers
:PROPERTIES:
:CUSTOM_ID: h:B2CBC8D4-21C4-4086-93F1-047E3C35A94A
:END:

:PROPERTIES:
:CUSTOM_ID: h:D43E2FC3-C9A0-40E7-9550-DF82663A00B9
:END:

These settings make it easier to work with multiple buffers. When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the
style of =uniquify-buffer-name-style=. While
=uniquify-strip-common-suffix= will remove the part of the file system
path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

** Window configuration
:PROPERTIES:
:CUSTOM_ID: h:D03674C2-AA9C-4B01-85A1-FE179C594224
:END:

Emacs' power lies in its buffer management rather than its
multiplexing. Since they require some division of the pane, windows
don't scale well. Instead we tend to leverage "search" to find a
specific item in the virtual pile of digital artifacts we keep in
storage. Screen real estate is a limited resource which must be
managed carefully.

That being said, like most everything else about Emacs, multiplexing
is highly configurable. One can define window placement rules, record
history of layouts, as well as navigation rules.

*** "Monocle" mode (single window toggle)
:PROPERTIES:
:CUSTOM_ID: h:CD0F9D27-3B68-4D91-8EC6-073FD6622756
:END:

The =indiebrain/window-single-toggle= is based on [[https://gitlab.com/ambrevar/emacs-windower/-/blob/master/windower.el][Pierre Neidhardt's
windower]].

#+begin_src emacs-lisp
(use-package emacs
  :config
  (defvar indiebrain/window-configuration nil
    "Current window configuration.")

  (define-minor-mode indiebrain/window-single-toggle
    "Toggle between multiple windows and single window.
This is the equivalent of maximising a window. Tiling window
managers such as DWM, BSPWM refer to this state as 'monocle'."
    :lighter " [M]"
    :global nil
    (if (one-window-p)
        (when indiebrain/window-configuration
          (set-window-configuration indiebrain/window-configuration))
      (setq indiebrain/window-configuration (current-window-configuration))
      (delete-other-windows)))
  :bind ("s-m" . indiebrain/window-single-toggle))
#+end_src

*** Directional window motions (windmove)
:PROPERTIES:
:CUSTOM_ID: h:16C42FC0-5A1E-4E76-B84F-E5314E54CD0E
:END:

While =C-x o= (=other-window=) is very useful when working with two or
three windows, it can become tiresome. Thankfully, Emacs comes with a
built-in package to move to a window in the given direction. I bind
the cardinal directions to Super plus an arrow key, with aliases for
the arrows you find on a standard keyboard's number pad.

The =windmove-create-window= specifies what should happen when trying to
move past the edge of the frame. The idea with this is to allow it to
create a new window with the contents of the current buffer. I tried it
for a while but felt that the times it would interfere with my layout
where more than those it would actually speed up my workflow.

#+begin_src emacs-lisp
(use-package windmove
  :config
  (setq windmove-create-window nil)     ; Emacs 27.1
  :bind (("<s-up>" . windmove-up)
         ("<s-right>" . windmove-right)
         ("<s-down>" . windmove-down)
         ("<s-left>" . windmove-left)
         ;; numpad keys clockwise: 8 6 2 4
         ("<kp-up>" . windmove-up)
         ("<kp-right>" . windmove-right)
         ("<kp-down>" . windmove-down)
         ("<kp-left>" . windmove-left)))
#+end_src

* Applications and utilities
:PROPERTIES:
:CUSTOM_ID: h:a927f3be-91fb-4ad7-a45e-48980a3b7941
:END:

Here we find configuration which extends Emacs to perform the role of
what would normally be considered the realm of a standalone
application - Calendars, TODO management, etc. This section is
expected to grow as I move more of my computing and workflow into the
care of Emacs.

** Calendar
:PROPERTIES:
:CUSTOM_ID: h:64eba618-ca5a-4ff0-bff1-c499e76563ab
:END:

This configures the function of date-time behavior.

- Calendars should start their weeks on Monday
- Represent date-time according to the [[https://www.iso.org/iso-8601-date-and-time-format.html][ISO 8601]] standards
- Time is represented in by a 24 hour clock (sometimes called Military
  time in the US). I dislike ambiguity, so even though I live in the
  states, I communicate time in this manner.

#+begin_src emacs-lisp
(use-package calendar
  :config
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-time-display-form
        '(24-hours ":" minutes
                   (when time-zone
                     (concat " (" time-zone ")"))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-christian-all-holidays-flag nil)
  (setq calendar-holidays
        (append holiday-local-holidays  ; TODO set local holidays
                holiday-solar-holidays))

  (use-package solar
    :config
    (setq calendar-latitude 39.952583
          calendar-longitude -75.165222))

  (use-package lunar
    :config
    (setq lunar-phase-names
          '("New Moon"
            "First Quarter Moon"
            "Full Moon"
            "Last Quarter Moon")))

  :hook (calendar-today-visible-hook . calendar-mark-today))
#+end_src

** Diary
:PROPERTIES:
:CUSTOM_ID: h:f35c829b-6b8b-41f9-8b27-e7841c6ce150
:END:

Emacs core contains a package used to capture tasks and generate
notifications for them.

#+begin_src emacs-lisp
(use-package diary-lib
  :config
  (setq diary-file "~/.emacs.d/diary")
  (setq diary-entry-marker "diary")
  (setq diary-show-holidays-flag t)
  (setq diary-header-line-flag nil)
  (setq diary-mail-addr "aaron.kuehler@gmail.com")
  (setq diary-mail-days 3)
  (setq diary-number-of-entries 3)
  (setq diary-comment-start ";")
  (setq diary-comment-end "")
  (setq diary-date-forms
        '((day "/" month "[^/0-9]")
          (day "/" month "/" year "[^0-9]")
          (day " *" monthname " *" year "[^0-9]")
          (monthname " *" day "[^,0-9]")
          (monthname " *" day ", *" year "[^0-9]")
          (year "[-/]" month "[-/]" day "[^0-9]")
          (dayname "\\W"))))
#+end_src

** Manual pages (manpages) reader
:PROPERTIES:
:CUSTOM_ID: h:DE9E1716-5638-4737-91EE-3E0B90C66CCD
:END:

Typically Unix-like operating systems provide facilities for reading
the documentation of libraries, system calls, etc. One such program is
=man= - short for Manual; the documentation of a particular item is
referred to as its Manual Page, or manpage. =man= is sometimes referred
to as an on-line" documentation system. Like many terms from the
earlier days of computing, do not be confused by the, now, overloaded
meaning of the term "on-line". The term "on-line" in this sense refers
back to a time when documentation for libraries and systems typically
came in volumes of printed materials; Manual Pages are stored on the
host file system and do NOT require a network connection. They serve
as at-the-ready tool for discovering, and recalling the manner in
which a program are meant to be used.

Manuals are typical organized into "sections" - represented by a
number - which indicate the role of the software being documented. For
Research Unix, BSD, MacOS, and Linux the sections are organized as
follows:

| Section | Description                                                        |
|---------+-------------------------------------------------------------------|
|       1 | General commands                                                  |
|       2 | System calls                                                      |
|       3 | Library functions, convering in particular the C standard library |
|       4 | Special files (usually devices, those found in /dev) and drivers  |
|       5 | File formats and conventions                                      |
|       6 | Games and screensavers                                            |
|       7 | Miscellanea                                                       |
|       8 | System administration commands and daemons                        |

A manpage's "section" is usually shown after its name in
parentheses. For example, the manpage for the =ls= utility is listed in
section 1 - General commands - and is titled =LS(1)=

All manpages follow a common layout which is optimized for simple ASCII text display. Sections present may include:

- NAME :: The name of the command or function, followed by a one-line description of what it does.
- SYNOPSIS :: In the case of a command, a formal description of how to run it and what command line options it takes. For program functions, a list of the parameters the function takes and which header file contains its declaration.
- DESCRIPTION :: A textual description of the functioning of the command or function.
- EXAMPLES :: Some examples of common usage.
- SEE ALSO :: A list of related commands or functions.

Some items may be present in multiple sections of the manpages. For example on MacOS:

#+begin_example
$ man uname
UNAME(1)                         User Commands                        UNAME(1)

NAME
       uname - print system information
...
SEE ALSO
       arch(1), uname(2)
#+end_example

In this case, the manpage from section 1 - general commands was
displayed, but notice that an entry also exists in another section and
is referenced in the =SEE ALSO= section. Typically one could request
documentation for specific sections by passing the section to the =man= command:

#+begin_example
man 2 uname

# or

man uname.2
#+end_example

However, Emacs also has a built in mode for quickly navigating
manpages. This has the added benefit of enhanced typography,
navigation, etc provided by Emacs.

What you can do inside such a buffer (with minor tweaks by me):

- =i= will go to the information node you want using completion (same
  principle as with the Info pages of C-h i and the like)
- =g= will generate the buffer anew. Do it to reformat the text
  manually, though this should also happen automatically when
  adjusting a window's size
- =n= and =p= move between section headings
- =RET=,while over a referenced manpage, will produce a new buffer with
  its contents
- =s= navigates directly to the =SEE ALSO= section
- =m= will search for a manpage using the configured completion system

#+begin_src emacs-lisp
(use-package man
  :bind (:map Man-mode-map
              ("i" . Man-goto-section)
              ("g" . Man-update-manpage)))
#+end_src

** Org
:PROPERTIES:
:CUSTOM_ID: h:b6f6ef85-9265-461b-a04c-c634a819117a
:END:

While Org is often described as a markup language for organizing
information by the uninitiated it is so much more. The universe of
tools and extensions which can interact with and manipulate the Org
format is rich, and vast. This section intends to isolate aspects of
how Org is used into smaller, more digestible chunks in the following
subsections.

*** Basic configuration
:PROPERTIES:
:CUSTOM_ID: h:8063ec43-4780-4a7e-a48a-4564c5c8785d
:END:

This section contains configuration which span the more specialized
functions of Org - for consistency's sake. Some notes on specific
configurations:

- Defaults :: =org-directory= and =org-default-notes-file= are provided as
  a "fallback" location for capture templates which do not specify a
  target file.
- Agenda :: The bulk of the org-agenda configurations is defined in
  elsewhere, but this sets up the default directories in which
  =org-agenda= will file and search for items.
- Re-filing items :: Items can be organized under headings of a
  document using the =C-c C-w= key chord. This prompts the user to
  choose a heading under which an item should be organized. =org-agenda=
  files are a natural choice of possible targets into which items
  should be filed. When items are entered via an =org-capture= template,
  they may be re-filed according to the rules of the capture
  template. Entries are re-filed as the last item under their target
  heading.
- Metadata :: Complex TODO systems demand more time and though cycles
  of their users to maintain them - and in my experience have a
  rapidly diminishing return on investment. Keep TODO tracking
  simple. There's little value in capturing too much metadata as items
  are worked and completed. The more advanced metadata tracking is
  disabled.
- TODOs :: TODO keywords supply a shortcut to quickly mark an Org
  heading. The letter in the parentheses after the keyword makes for
  faster labeling of Org headings as particular types of TODOs via the
  =org-todo= (=C-c C-t=) menu. The various categories of TODO keywords is
  intended to make filtering tasks easier in the agenda views.

Additional notes on less obvious settings:

- Setting =org-special-ctrl-a/e=, and ==org-special-ctrl-k== to =nil= makes
  the =C-a=, =C-e=, and =C-k= key chord1, when used on an =org-mode= headline,
  obey the same semantics as everywhere else. When set to non-nil
  values, these key chords behave differently for headlines - which is
  terribly confusing and unpredictable. - All the markup characters should be hidden from view, in the same
  way links are. This generally reduces the distractions in the
  document.
  -
- The return key should never follow a link because it is more likely
  to be invoked by accident. Use =C-c C-o= instead.
- Setting =org-loop-over-headlines-in-active-region= ensures that
  actions over a region of headers - such as tagging and scheduling -
  only apply to headers of at the same level as the first header - IE
  don't touch the sub-tree headers.

#+begin_src emacs-lisp
(use-package org
  :config
  ;; agenda and basic directory structure
  (setq org-directory "~/.org")
  (setq org-default-notes-file "~/.org/notes.org")
  (setq org-agenda-files
        '("~/.org"
          "~/.emacs.d"
          "~/Documents"))
  ;; refile, todo
  (setq org-refile-targets
        '((org-agenda-files . (:maxlevel . 2))
          (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "|" "DONE(D)" "CANCEL(C)")
          (sequence "MEET(m)" "|" "MET(M)")
          (sequence "STUDY(s)" "|" "STUDIED(S)")
          (sequence "WRITE(w)" "|" "WROTE(W)")))
  (setq org-todo-keyword-faces
        '(("MEET" . '(font-lock-preprocessor-face org-todo))
          ("STUDY" . '(font-lock-variable-name-face org-todo))
          ("WRITE" . '(font-lock-type-face org-todo))))
  (setq org-priority-faces
        '((?A . '(org-scheduled-today org-priority))
          (?B . org-priority)
          (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line t)
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)
  ;; tags
  (setq org-tag-alist                   ; TODO review org tag list
        '((:startgroup)
          ("@work")
          ("@priv")
          (:endgroup)
          ("emacs")
          ("modus")
          ("politics")
          ("economics")
          ("philosophy")
          ("paper")
          ("book")
          ("essay")
          ("article")
          ("mail")
          ("website")))
  ;; code blocks
  (setq org-confirm-babel-evaluate nil)
  ;; log
  (setq org-log-done 'time)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline nil)
  (setq org-log-reschedule nil)
  (setq org-read-date-prefer-future 'time)
  ;; general
  (setq org-adapt-indentation nil)      ; No, thanks!
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
  (setq org-hide-leading-stars nil)
  (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
        '(("s" . "src")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-imenu-depth 7)
  (setq org-modules '(ol-gnus ol-info ol-eww))
  :bind (:map org-mode-map
              ("<C-return>" . nil)
              ("<C-S-return>" . nil)))
#+end_src

*** Links
:PROPERTIES:
:CUSTOM_ID: h:23f033ae-395e-4f02-b6c2-f03f59f7e787
:END:

The =org-store-link= function can be used via the =C-c l= key chord to
store a references to the heading under the point.

There are several ways to insert such links. With =C-c C-l= (which calls
=org-insert-link=) you will be prompted to select a stored link from the
link. It will be inserted at point, using the right markup, but will
first ask you for a description text. Otherwise you can invoke =C-c C-l=
with an active region, to create a link to that location with the
selected text becoming the description. Otherwise you can just call
=org-insert-last-stored-link= (=C-c M-l=) to skip the interactive process
and just insert the last link.

#+begin_src emacs-lisp
(use-package ol
  :config
  (setq org-link-keep-stored-after-insertion t)
  :bind (("C-c l" . org-store-link)))
#+end_src

*** Capture templates
:PROPERTIES:
:CUSTOM_ID: h:c7017667-edd3-49b8-8cd7-ef16386148f9
:END:

The =org-capture= tool is a powerful way to quickly produce some kind
of structured information. The type of data and the way to store is
determined by a system of templates which accepts a series of
possible specifiers as well as the evaluated part of arbitrary elisp
code.

Each template is accessed via a key. These are listed in a temporary
buffer when you call =org-capture=. Unique keys give direct access to
their template, whereas templates that share a common initial key will
produce a second selection list with the remaining options. In the
latter case, the initial key entry has no call to an actual function,
but is just written as a heading. For an example, look how I do the
"Work" section: all templates whose keys follow the pattern =wX= are
only visible after hitting =w= and are then accessed via =X=.

The visibility of a template is further controlled by another
variable: =org-capture-templates-contexts=. This allows us to tell Org
the context in which we want certain options to appear in. Otherwise
they remain concealed from our view. Equipped with this piece of
functionality, we can freely write highly specialized templates that
capture structured text when viewing some particular item, but are not
needed for more general purposes.

Specifiers that start with the caret sign (=^=) represent prompts for
further user input. The pattern =^{TEXT}= is a prompt whose name is =TEXT=.
To offer possible options, use =^{Initial|ONE|TWO|THREE}=, where the first
entry is the text of the prompt and all the rest are the available
choices (depending on your completion framework, you may need to add an
empty option as well, with =||=, should you ever want to insert nothing).
In some templates I use the =^t= specifier, which is a built-in method to
ask for a specific date.

The text that goes into a template can be written as part of a string or
inside a function that is then evaluated.

The =%?= determines where the point should be once the template is filled
in. While =%i= will insert the contents of the active region.

A file can be specified by its absolute path or just a name. In the
latter case, its location is understood relative to =org-directory=. When
using the =file+headline= pattern, non-existing files are created
automatically once you call the relevant template. Same for their
respective headings.

#+begin_src emacs-lisp
(use-package org-capture
  :after org
  :config
  (setq org-capture-templates
        `(("a" "Article to write" entry
           (file+headline "tasks.org" "Writing list")
           ,(concat "* WRITE %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n:END:\n\n"
                    "%i%?"))
          ("b" "Basic task for future review" entry
           (file+headline "tasks.org" "Basic tasks that need to be reviewed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%l"))
          ("w" "Work")
          ("wt" "Task or assignment" entry
           (file+headline "work.org" "Tasks and assignments")
           ,(concat "* TODO %^{Title} :@work:\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n:CAPTURED: %U\n:END:\n\n"
                    "%i%?"))
          ("wm" "Meeting, event, appointment" entry
           (file+headline "work.org" "Meetings, events, and appointments")
           ,(concat "* MEET %^{Title} :@work:\n"
                    "SCHEDULED: %^T\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n:END:\n\n"
                    "%i%?"))
          ("t" "Task with a due date" entry
           (file+headline "tasks.org" "Task list with a date")
           ,(concat "* %^{Scope of task||TODO|STUDY|MEET} %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n:CAPTURED: %U\n:END:\n\n"
                    "%i%?"))))

  (defun contrib/org-capture-no-delete-windows (oldfun args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))

  (advice-add 'org-capture-place-template
              :around 'contrib/org-capture-no-delete-windows)

  :bind ("C-c c" . org-capture))
#+end_src

*** Agenda
:PROPERTIES:
:CUSTOM_ID: h:207cdd77-5fa8-4e3e-8718-345be08a0e8a
:END:

The =org-agenda= is not just a single interface. It rather is your
conduit to a set of utilities from where you can keep track of all the
tasks you have written in the files declared as part of =org-agenda-files=
(see its value in the [[#h:8063ec43-4780-4a7e-a48a-4564c5c8785d][section which covers the Basic Org configuration]]).
Calling =org-agenda= will present you with a list of possible options: the
"dispatcher" as it called.

Here is a primer (there are many more functions documented in the
manual):

- From the dispatcher, the =a= is where you keep track of all the items
  that have a date assigned to them, be it =SCHEDULED= or =DEADLINE=. To
  assign such a value to a heading use =C-c C-s= or =C-c C-d= respectively.
  Run those commands with a universal prefix (=C-u=) to remove the
  timestamp. Hit =/= to filter this view to match particular tags.
- In the dispatcher's menu, the =t= will list all your tasks, regardless
  of whether they have a date assigned to them. You can then filter by
  keyword, regular expression, etc. Check the top of the buffer for
  information on how to do that.
- And the =n= in the dispatcher will offer you a combined view of the
  above.

Now a few words about some of my customizations (remember to use Emacs'
documentation facilities over each item, such as =C-h v=):

- Always ask for confirmation when hitting =C-k= from the agenda views.
  That command removes the entry in the original file.
- Show all dates in the current view, including those that have no
  entries. I find it easier that way to assess how far apart the tasks
  are.
- Do not produce a message in the echo area showing the outline path.
  It is too distracting.
- Any valid time expressions in headlines should be ignored. Otherwise
  they are used as part of the relevant sorting methods.
- The default view should just show me a three day span. All the
  commands for changing views still work as expected (e.g. hit =w= to show
  the current week).
- Disable follow mode by default. This produces a view of the current
  item's original context in the other window. It can be toggled on by
  hitting =F=.
- Time stamps should always be expressed in 24h format.
- Stylistic tweaks to the time grid view format.
- Disable the key bindings that cycle through the agenda files: too easy
  to hit while trying to perform some other action. Besides, I do not
  need that kind of functionality.

#+begin_src emacs-lisp
(use-package org-agenda
  :after org
  :config
  ;; Basic setup
  (setq org-agenda-span 14)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

  ;; General view options
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "->")
  (setq org-agenda-todo-keyword-format "%-1s")
  (setq org-agenda-diary-sexp-prefix nil)
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?—)

  (defun indiebrain/org-agenda-format-date-aligned (date)
    "Format a DATE string for display in the daily/weekly agenda.
  This function makes sure that dates are aligned for easy reading.

  Slightly tweaked version of `org-agenda-format-date-aligned' that
  produces dates with a fixed length."
    (require 'cal-iso)
    (let* ((dayname (calendar-day-name date t))
           (day (cadr date))
           (day-of-week (calendar-day-of-week date))
           (month (car date))
           (monthname (calendar-month-name month t))
           (year (nth 2 date))
           (iso-week (org-days-to-iso-week
                      (calendar-absolute-from-gregorian date)))
           (weekyear (cond ((and (= month 1) (>= iso-week 52))
                            (1- year))
                           ((and (= month 12) (<= iso-week 1))
                            (1+ year))
                           (t year)))
           (weekstring (if (= day-of-week 1)
                           (format " (W%02d)" iso-week)
                         "")))
      (format "%s %2d %s %4d%s"
              dayname day monthname year weekstring)))

  (setq org-agenda-format-date #'indiebrain/org-agenda-format-date-aligned)

  ;; Marks
  (setq org-agenda-bulk-mark-char "#")
  (setq org-agenda-persistent-marks nil)

  ;; Diary entries
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary t)

  ;; Follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

  ;; Multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

  ;; Filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

  ;; Items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 5)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time t)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string
        "Now -·-·-·-·-·-·-")
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (0600 0700 0800 0900 1000 1100
                1200 1300 1400 1500 1600
                1700 1800 1900 2000 2100)
          " ....." "-----------------"))
  (setq org-agenda-default-appointment-duration nil)

  ;; Global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

  ;; Tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -120)

  ;; Agenda entry
  ;;
  ;; NOTE I do not use this right now. Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    > ")

  ;; Logging, clocking
  ;;
  ;; NOTE I do not use these yet, though I plan to. Leaving everything to
  ;; its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-sort-agenda-notime-is-late t)
  (setq org-sort-agenda-noeffort-is-high t)

  ;; Agenda column view
  ;;
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

  :bind (("C-c a" . org-agenda)
         :map org-mode-map
         ("C-'" . nil)
         ("C-," . nil)))
#+end_src

*** Code Blocks
:PROPERTIES:
:CUSTOM_ID: h:274afc34-3b84-48a2-8c5a-e0be9a191f06
:END:

When working with code blocks, delimited by =#+begin_src= and =#+end_src=
tokens, Emacs can use the mode declaration of the block to perform
syntax highlighting of the block. Additionally, when the
=org-edit-special= function (=C-c '=) is invoked in a code block, Emacs
will open the a buffer with the block's contents and activate the
major mode as described by the =#+begin_src= block. For example a code
block of =emacs-lisp= might looks like this:

#+begin_example
  ,#+begin_src emacs-lisp
  (message "Hello!")
  ,#+end_src
#+end_example

When the point is in the block, and the key chord =C-c '= is invoked,
the contents of the block will open in a buffer whose major mode is
=emacs-lisp=. When editing a code block, make the new buffer occupy the
current window rather than causing a split.

#+begin_src emacs-lisp
(use-package org-src
  :after org
  :config
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0))
#+end_src

*** Export
:PROPERTIES:
:CUSTOM_ID: h:ec591767-5dc9-4277-8fae-a6a9da4f79b9
:END:

Org's "export" facility can produce a limitless set of file formats
from an =.org= document - HTML, PDFs, Markdown, JIRA Markup, etc. the
list is endless. This configuration sets some globally applicable
behavior when exporting org documents to various formats.

#+begin_src emacs-lisp
(use-package ox
  :after org
  :commands (indiebrain/ox-html indiebrain/ox-texinfo)
  :config
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
  (use-package ox-texinfo)
  ;; FIXME: how to remove everything else?
  (setq org-export-backends '(html texinfo))

  (defun indiebrain/ox-html ()
    (interactive)
    (org-html-export-as-html nil nil nil t nil))

  (defun indiebrain/ox-texinfo ()
    (interactive)
    (org-texinfo-export-to-info)))
#+end_src

*** Consistent Org headline IDs (and anchor tags)
:PROPERTIES:
:CUSTOM_ID: h:84F903C7-26FC-408D-900D-EBDF724FE554
:END:

Ensure that references to sections of =org-mode= documents remain
consistent across exports. See this detailed tutorial on [[https://writequit.org/articles/emacs-org-mode-generate-ids.html][Org header
IDs]] for more details.

#+begin_src emacs-lisp
(use-package org-id
  :after org
  :commands contrib/org-id-headlines
  :config
  (setq org-id-link-to-org-use-id
        'create-if-interactive-and-no-custom-id)

  (defun contrib/org-id-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker
  POM. If POM is nil, refer to the entry at point. If the entry
  does not have an CUSTOM_ID, the function returns nil. However,
  when CREATE is non nil, create a CUSTOM_ID if none is present
  already. PREFIX will be passed through to `org-id-new'. In any
  case, the CUSTOM_ID of the entry is returned."
    (org-with-point-at pom
      (let ((id (org-entry-get nil "CUSTOM_ID")))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (org-id-new (concat prefix "h")))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (format "%s" (buffer-file-name (buffer-base-buffer))))
          id)))))

  (defun contrib/org-id-headlines ()
    "Add CUSTOM_ID properties to all headlines in the current
  file which do not already have one."
    (interactive)
    (org-map-entries
     (lambda () (contrib/org-id-get (point) t)))))
#+end_src

*** Presentations
:PROPERTIES:
:CUSTOM_ID: h:9E77EBD9-7961-48D8-A68F-79AEE868AA46
:END:

An Org document can represent a simple set of slides for
presentations. Paired with =org-export= this makes for a powerful system
of defining and sharing ideas. To begin a presentation one needs only
to =M-x org-present=; to stop a presentation =C-c C-q=.

#+begin_src emacs-lisp
(use-package org-present
  :ensure t
  :config
  (add-hook 'org-present-mode-hook
            (lambda ()
              (org-present-big)
              (org-display-inline-images)
              (org-present-read-only)))
  (add-hook 'org-present-mode-quit-hook
            (lambda ()
              (org-present-small)
              (org-remove-inline-images)
              (org-present-read-write))))
#+end_src

*** Static site generator

My personal website and blog are generated from a collection of Org
documents via the =org-page= package. The following configuration is very
specific to generating the content found at [[https://aaronkuehler.com][https://aaronkuehler.com]].

To generate and preview the site locally, I run
=op/do-publication-and-preview-site=. This exports the Org documents as
HTML, then serves them on the local host using =simple-httpd=.

Once the content is ready to be published to the web, I do so via
=op/do-publication=. The configuration in this section takes care of
wiring the local repository to the hosted site.

#+begin_src emacs-lisp
(use-package org-page
  :ensure
  :config
  (setq op/repository-directory "~/Developer/indiebrain.github.io")
  (setq op/site-domain "https://aaronkuehler.com")
  (setq op/personal-github-link "https://github.com/indiebrain")
  (setq op/site-main-title "Aaron Kuehler")
  (setq op/site-sub-title "80% Scientist, 20% Artist. Theorist and Practitioner.")
  (setq op/theme-root-directory "~/Developer/indiebrain.github.io/themes")
  (setq op/theme 'indiebrain)
  (setq op/category-config-alist
        (cons '("resume"
                :show-meta nil
                :show-comment nil
                :uri-generator op/generate-uri
                :uri-template "/resume/"
                :sort-by :date
                :category-index nil)
              op/category-config-alist))
  (setq op/category-ignore-list
        (cons "resume" op/category-ignore-list))
  (setq op/category-ignore-list
        (cons "drafts" op/category-ignore-list)))
#+end_src

** Process monitor
:PROPERTIES:
:CUSTOM_ID: h:329207F4-0EE8-456E-8564-C895160FFB0D
:END:

Emacs has a built in process monitor, similar to =top=, called
=proced=. This section configured =proced= to display only processes from
the current user, and auto-update the process list. Additionally, the
live list of processes can be filtered by a narrowing-search -
initiated by the =/= key.

#+begin_src emacs-lisp
(use-package proced
  :commands proced
  :config
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 1)
  (setq proced-descend t)
  (setq proced-filter 'user))

(use-package proced-narrow
  :ensure
  :after proced
  :diminish
  :bind (:map proced-mode-map
              ("/" . proced-narrow)))
#+end_src

** Representational State Transfer Client (REST API Client)
:PROPERTIES:
:CUSTOM_ID: h:A0F56FF1-0AA1-4201-BD62-00FD4D98C9BE
:END:

The =restclient= package turns Emacs into a fully featured development
tool for interacting with RESTful APIs. Buffers become areas for
defining web requests - resoruce paths, query parameters, request bodies,
etc. Additionally, =resclient= buffers can take advantage of Emacs, and
=emacs-lisp= to pragmatically define requests. The table blow is but a
sample of the most frequent interactions with this mode:


| Key chord | Description                                                                           |
|-----------+---------------------------------------------------------------------------------------|
| =C-c C-c=   | Run the query at the point                                                            |
| =C-c C-p=   | Jump to the previous query                                                            |
| =C-c C-n=   | Jump to the next query                                                                |
| =C-c C-u=   | Yank the query at the point to the kill ring (and system clipboard) as a cURL command |

#+begin_src emacs-lisp
(use-package restclient
  :ensure
  :mode
  ("\\.rest$" . restclient-mode)
  ("\\.restclient$" . restclient-mode))
#+end_src

** Version control
:PROPERTIES:
:CUSTOM_ID: h:E99B08EA-E4D5-40F8-87FE-1EB99E4AEC11
:END:

*** Magit
:PROPERTIES:
:CUSTOM_ID: h:07AFEBDB-975C-489E-A7D1-2DC8BF1E3639
:END:


#+begin_quote
Magit is a complete text-based user interface to Git. It fills the
glaring gap between the Git command-line interface and various GUIs,
letting you perform trivial as well as elaborate version control tasks
with just a couple of mnemonic key presses.
#+end_quote

Magit presents an interactive interface to the full power of the =git=
version control system. The easiest way to start interacting with
Magit is to bring up the =magit-status= buffer via the =C-c g= key
chord. From there, the =?= key will produce a menu describing how
further interaction with a repository can be taken. The =?= key will
produce a similar "help" menu for most, if not all, magit buffers -
when one is lost, =?= to find the path.

**** Base settings
:PROPERTIES:
:CUSTOM_ID: h:C3BAEC4A-0CC5-4E36-86FD-1C4CFFC2BBD3
:END:

Magit has great defaults. I only found a few things that I would like
to customize, which I do in the following package declarations.

Some points of interest.

- To get the current status of the repository's working tree, use the
  =C-x g= key chord. This used to be the default, but the default
  binding was removed from the package some time ago.
- The =defadvice= bits configure magit to take up the entire window when
  activated. This is useful when inspecting diffs in the =magit-status=
  buffer. It also serves as a cognitive break from interacting with
  the content of things under a =git= repository's control, to
  interacting with the repository itself.

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :commands magit-status magit-blame
  :bind ("C-x g" . magit-status)
  :config
  (setq ad-redefinition-action 'accept)
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  (defadvice magit-quit-window (after magit-restore-screen activate)
    (jump-to-register :magit-fullscreen))
  (remove-hook 'magit-refs-sections-hook 'magit-insert-remote-branches)
  (remove-hook 'magit-refs-sections-hook 'magit-insert-tags))
#+end_src

**** Write good commit messages
:PROPERTIES:
:CUSTOM_ID: h:f851e0cc-099c-4309-8517-b2f20ab18ab4
:END:

The following package is configured in accordance with the guidelines
provided by this article on [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]]. The gist is
to write commits that are clean and easy to read. The =fill-column= is
set elsewhere in this document to 72 characters long.

#+begin_src emacs-lisp
(use-package git-commit
  :after magit
  :config
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line)))
#+end_src

**** Magit diffs
:PROPERTIES:
:CUSTOM_ID: h:7FE3C18A-AD03-4167-95BD-1837FB263BDC
:END:

When Magit produces a "diff" view, highlight the actual changes, not
just the lines on which changes occur. This is enabled for the focused
hunk, but /may/ also be configured for the entire diff by setting
=magit-diff-refine-hunk= to ='all=.

#+begin_src emacs-lisp
(use-package magit-diff
  :after magit
  :config
  (setq magit-diff-refine-hunk t))
#+end_src

**** Magit repository list
:PROPERTIES:
:CUSTOM_ID: h:35972439-0b28-4d33-8091-c6b5f1f02579
:END:

Rare is the git user who works within one and only one repository. The
following produces a overview list of repositories and their status
contained within paths contained in the =magit-repository-directories=
variable.

#+begin_src emacs-lisp
(use-package magit-repos
  :after magit
  :commands magit-list-repositories
  :config
  (setq magit-repository-directories
        '(("~/Developer" . 1))))
#+end_src

*** Resolving conflicts
:PROPERTIES:
:CUSTOM_ID: h:AEC20F4E-904A-4CAC-8D9E-01B0B8756D1A
:END:

When working on concurrent timelines of a project, it's only a matter
of time before we attempt to integrate changes are made in two
separate timelines which the version control system cannot resolve on
its own. Whenever conflicts arise, Emacs will annotate the conflicting
difference. When visiting a file with such conflicts, Emacs will
activate =smerge-mode= and allow us to resolve the conflicts manually.

Smerge represents the conflict of a merge as two distinct parts; the
"upper" (red) and "lower" (green), and possibly annotating the common
ancestor of each in the middle (yellow). As such, smerge provides
functions which allow us to navigate these conflicts and resolve
them - typically with the common key chord prefix of =C-c ^=. For
example, here are some common commands one might use when resolving
merge conflicts:

- =C-c ^ u= (=smerge-keep-upper=)
- =C-c ^ l= (=smerge-keep-lower=)
- =C-c ^ b= (=smerge-keep-base=)
- =C-c ^ a= (=smerge-keep-all=)
- =C-c ^ n= (=smerge-next=)
- =C-c ^ p= (=smerge-prev=)

Note: A hydra (=defhydra)= is provided by this configuration to simplify
the resolution process.

It is the role of the human to decide what the end-state of the
conflicts should be - be it through smerge, or manually correcting the
conflicts. It is entirely possible to utilize standard commands and
motions when resolving conflicts; however, this /can/ be prone to human
errors which will lead to more work in resolving future conflicts, or
even defects. Manual editions should be made when high levels of
confidence can be made about the resulting product. When working in an
smerge buffer, one can switch to =ediff= which offers even more powerful
tools for working with differences with the =C-c ^ E= key chord
(=smerge-ediff=).

Ediff starts by producing a layout of the two conflicting versions and
a "control panel" for operating on them. By default the panel is
positioned in a new frame, but this configuration places the frame
inside places the panel inside an Emacs window instead. While focusing
on the control panel, one can move between each diff range with =n= and
=p=. The focused conflict will be colored using red, green, and yellow
while other conflicts will be presented in gray.

For each conflict you can choose to keep buffer A's (red) version,
buffer B's (green) version, or a combination of the two. The key
chords for each of these scenarios are =a=, =b=, or =+= respectively. The
choice will be reflected in buffer C (yellow). When all conflicts have
been resolved, the user can quit the session with =q=. For more
information about =ediff= use =?= inside the control panel.

This section configures =smerge= and =ediff= such that when performing merge surgery:

- merge related buffers are dismissed after exiting an =ediff= session
- when a merge buffer is created, it should be editable
- the common ancestor is shown in a separate buffer - for context
- only the conflict is show, rather than a whole diff
- merge buffers are placed side-by-side
- =ediff= sessions are started in the current frame

Additionally, the above mentioned =smerge= hydra is activated when
visiting a file with merge conflicts.

#+begin_src emacs-lisp
(use-package smerge-mode
  :config
  (defhydra indiebrain/hydra-smerge-mode
    (:color pink :hint nil :post (smerge-auto-leave))
    "
     ^Motions^      ^Actions^
  ---^^-------------^^-------
  _n_: Next      _b_: Base
  _p_: Prev      _u_: Upper
  ^^             _l_: Lower
  ^^             _a_: All
  "
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("q" nil "cancel" :color blue))

  (defun indiebrain/smerge-mode-hydra ()
    "Load `indiebrain/hydra-smerge-mode' in `smerge-mode'."
    (when smerge-mode
      (indiebrain/hydra-smerge-mode/body)))
  :hook ((vc-find-file-hook . indiebrain/smerge-mode-hydra)
         (magit-diff-visit-file-hook . indiebrain/smerge-mode-hydra)))

(use-package ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< indiebrain-ediff-combine Variant A" A
          ">>>>>>> indiebrain-ediff-combine Variant B" B
          "####### indiebrain-ediff-combine Ancestor" Ancestor
          "======= indiebrain-ediff-combine End"))

  ;; TODO automate process in a robust way, or at least offer a good key
  ;; binding.
  (defun indiebrain/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

  This is a quick-and-dirty way to get rid of the markers that are
  left behind by `smerge-ediff' when combining the output of two
  diffs. While this could be automated via a hook, I am not yet
  sure this is a good approach."
    (interactive)
    (flush-lines ".*indiebrain-ediff.*" (point-min) (point-max) nil)))
#+end_src

*** Interacting with forges
:PROPERTIES:
:CUSTOM_ID: h:FF554E23-42D6-4A8E-BE4B-2A8CBCB5698C
:END:

The term "forge", informally, refers to a system which facilitates
collaboration on source code repositories - Github, and Gitlab for
example.

The =forge= provides a consistent interface for interacting with Git
forges from the comfort of Magit and the rest of Emacs.

Forge fetches issues, pull/merge-requests and other data using the
forge’s API and stores that in a local database. Additionally it
fetches the pull-request references using Git. Forge implements
various features that use this data but the database and pull-request
refs can also be used by third-party packages.

=forge= uses token-based authentication to communicate to the Git
forge's API. Typically I store these in an file encrypted with my GPG
keys - =.authinfo.gpg= - which Emacs can use transparently to supply
authentication credentials to the =forge= package. Then =.authinfo.gpg= entry for Github
might look like:

#+begin_example
machine api.github.com login <github-user-name>^forge password <api-authentication-token>
#+end_example

#+begin_src emacs-lisp
(use-package forge
  :ensure t
  :after magit)
#+end_src
* Interface and interactions
:PROPERTIES:
:CUSTOM_ID: h:2fe25adb-7f53-4c86-9e6c-4a9a96781dac
:END:

This section contains configuration of the Emacs user interface. There
are many 3rd party packages that change the fundamental shape of the
Emacs interface, but this attempts to keep the interface fairly close
to the vanilla experience.

** Automatically save buffers
:PROPERTIES:
:CUSTOM_ID: h:0B6C84D3-9A82-42BA-8AD0-2A1134BA1533
:END:

This configuration makes Emacs automatically save buffers when:

- The buffer loses focus
- Emacs has been idle for 5 or more seconds

#+begin_src emacs-lisp
(use-package super-save
  :ensure
  :config
  (setq super-save-auto-save-when-idle t)
  (setq super-save-idle-duration 5)
  (super-save-mode t))
#+end_src

** Modeline
:PROPERTIES:
:CUSTOM_ID: h:38419AC4-6729-484C-821B-1EC1FB734369
:END:

This configuration reorganizes some of the mode line indicators. The
=mode-line-defining-kbd-macro= is tweaked to use a more appropriate
string for its indicator and to apply colors that are designed
specifically for the mode line (the default uses the generic font-lock
warning face).

#+begin_src emacs-lisp
(use-package emacs
  :commands indiebrain/mode-line-hidden-mode
  :config
  (setq mode-line-percent-position '(-3 "%p"))
  (setq mode-line-defining-kbd-macro
        (propertize " Macro" 'face 'mode-line-emphasis))
  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "  "
                  mode-line-position
                  (vc-mode vc-mode)
                  " "
                  mode-line-modes
                  " "
                  mode-line-misc-info
                  mode-line-end-spaces))

  (define-minor-mode indiebrain/mode-line-hidden-mode
    "Toggle modeline visibility in the current buffer."
    :init-value nil
    :global nil
    (if indibrain/mode-line-hidden-mode
        (setq-local mode-line-format nil)
      (kill-local-variable 'mode-line-format)
      (force-mode-line-update))))
#+end_src

*** Moody (simple modeline configuration utility
:PROPERTIES:
:CUSTOM_ID: h:0A4B927D-FF9D-4516-9C3D-CA3BC0D03222
:END:

There is no easy, convenient way to tweak individual components of the
modeline. In order to make the very minor changes to the modeline
contained in this configuration, the =moody.el= package is incorporated.

#+begin_src emacs-lisp
(use-package moody
  :ensure
  :after indiebrain-fonts                     ; we need its hook
  :config
  (moody-replace-mode-line-buffer-identification)

  ;; TODO: this should be part of a future `indiebrain-simple.el' or something
  (defun indiebrain/moody--even-p (n)
    (if (numberp n)
        (= (% n 2) 0)
      (user-error "%s is not a number" n)))

  (defun indiebrain/moody--height ()
    "Set Moody height to an even number.
Bind this to a hook that gets called after loading/changing the
mode line's typeface (or the default one if they are the same)."
    (let* ((font (face-font 'mode-line))
           (height (truncate (* 1.35 (aref (font-info font) 2))))
           (height-even (if (indiebrain/moody--even-p height) height (+ height 1))))
      (if font
          height-even
        20)))

  (defun indiebrain/moody--mode-line-height ()
    "Set Moody height to the value of `indiebrain/moody--height'."
    (setq moody-mode-line-height (funcall 'indiebrain/moody--height)))
  :hook (indiebrain-fonts-set-typeface-hook . indiebrain/moody--mode-line-height))
#+end_src

** Fringes
:PROPERTIES:
:CUSTOM_ID: h:AB5800D6-3263-4651-AECE-CCC462D0B1A8
:END:

The fringes are areas to the right and left side of an Emacs frame.
They can be used to show status-related or contextual feedback such as
line truncation indicators, continuation lines, code linting markers,
etc.

The default fringe width (=nil=) is 8 pixels on either side, which I
approve of. It is possible to set the value of the =fringe-mode= to
something like ='(10 . 5)= which applies the varied width to the left and
right side respectively. Otherwise, we can use a single integer that
controls both sides.

The use of =setq-default= is necessary, otherwise these values become
buffer-local.

#+begin_src emacs-lisp
(use-package fringe
  :config
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t))
#+end_src

*** Diff highlights in the fringe (diff-hl)
:PROPERTIES:
:CUSTOM_ID: h:88694E5B-FF19-4029-B42E-602FDF2CD512
:END:

The =diff-hl= package uses the left or right fringe to highlight changes
in the current buffer. The indicators are color-coded to denote
whether a change is an addition, removal, or change that includes a bit
of both.

The package offers some more features, such as the ability to move
between diff hunks while editing the buffer.

#+begin_src emacs-lisp
(use-package diff-hl
  :ensure
  :after vc
  :config
  (setq diff-hl-draw-borders nil)
  (setq diff-hl-side 'left)
  :hook (after-init-hook . global-diff-hl-mode))
#+end_src
** Highlight the current line
:PROPERTIES:
:CUSTOM_ID: h:1CFAAF45-8EDE-436E-B33A-61EAF1C60D2D
:END:

To quickly orient oneself in a buffer, it is often helpful to have the
current-line of the point visually differentiated. This is the purpose
of the =hl-line= package.

#+begin_src emacs-lisp
(use-package hl-line
  :config
  (global-hl-line-mode))
#+end_src

** Highlight comment keywords (hl-todo)
:PROPERTIES:
:CUSTOM_ID: h:AA13D85A-3F06-40B8-9E56-88151E4EC652
:END:

This tool by Jonas Bernoulli will apply highlighting to keywords that
are normally used in code comments. Simple and effective!

#+begin_src emacs-lisp
(use-package hl-todo
  :ensure
  :hook (prog-mode-hook . hl-todo-mode))
#+end_src
** Tone down parentheses and autoload cookies in Elisp
:PROPERTIES:
:CUSTOM_ID: h:A5500696-4CD5-44DB-8381-7FB1C76A2A22
:END:

Both of these packages are developed by Jonas Bernoulli (aka tarsius).

- paren-face :: Apply a dedicated face to parentheses in Elisp modes. A
  more subtle gray than the default foreground text is used.
- dim-autoload :: De-emphasize the special =###autoload= cookie that Emacs
  uses to load things where they are needed. This package also offers
  the possibility to completely hide those cookies, though I have no use
  for that.

#+begin_src emacs-lisp
(use-package paren-face
  :ensure
  :hook (emacs-lisp-mode-hook . paren-face-mode))

(use-package dim-autoload
  :ensure
  :hook (emacs-lisp-mode-hook . dim-autoload-cookies-mode))
#+end_src

** Optional visual indicators or layout elements
:PROPERTIES:
:CUSTOM_ID: h:26A48E80-33BC-49A5-B4B5-682E66DF5697
:END:

*** Toggles for line numbers and whitespace indicators
:PROPERTIES:
:CUSTOM_ID: h:1D231A4F-DE10-4966-9E83-E904B3831756
:END:


- Display line numbers (buffer-local) :: I seldom use line numbers,
  but here it is. This toggles the setting for the local buffer and
  also activates hl-line-mode.
- Display invisible characters (whitespace) :: Viewing invisible
  characters (whitespace) can be very helpful under certain
  circumstances. Generally though, I do not keep it active.
- Automatic whitespace cleanup :: When emacs is asked to save a
  buffer, it first makes a pass on the buffer to cleanup any extra
  whitespace. The meaning of "extra whitespace" is defined by the
  =whitespace-cleanup= function. More information is available via its
  documentation (=C=h f RET whitespace-cleanup)=.

#+begin_src emacs-lisp
(use-package display-line-numbers
  :config
  ;; Set absolute line numbers. A value of "relative" is also useful.
  (setq display-line-numbers-type t)
  ;; Those two variables were introduced in Emacs 27.1
  (setq display-line-numbers-major-tick 20)
  (setq display-line-numbers-minor-tick 5)
  ;; Use absolute numbers in narrowed buffers
  (setq display-line-numbers-widen t)

  (define-minor-mode indiebrain/display-line-numbers-mode
    "Toggle `display-line-numbers-mode' and `hl-line-mode'."
    :init-value nil
    :global nil
    (if indiebrain/display-line-numbers-mode
        (progn
          (display-line-numbers-mode 1)
          (hl-line-mode 1)
          (setq-local truncate-lines t))
      (display-line-numbers-mode -1)
      (hl-line-mode -1)
      (setq-local truncate-lines nil)))
  :bind ("<f7>" . indiebrain/display-line-numbers-mode))

(use-package whitespace
  :config
  (defun indiebrain/toggle-invisibles ()
    "Toggles the display of indentation and space characters."
    (interactive)
    (if (bound-and-true-p whitespace-mode)
        (whitespace-mode -1)
      (whitespace-mode)))
  :bind (("<f6>" . indiebrain/toggle-invisibles)
         ("C-c z" . delete-trailing-whitespace))
  :hook (before-save-hook . whitespace-cleanup))
#+end_src

*** Undo history
:PROPERTIES:
:CUSTOM_ID: h:7FF3524B-F128-459C-ABD0-19EE38679C37
:END:

The default undo function of Emacs can sometimes get itself in a twist
when multiple undo/redo operations are performed on a buffer. Undo
tree provides a visual mode for traversing the many branches and
timelines of editions made to a buffer. It's often helpful for getting
out of these types of scenarios. The =C-x u= key chord will show the
tree of changes.

#+begin_src emacs-lisp
(use-package undo-tree
  :ensure
  :diminish
  :init
  (global-undo-tree-mode))
#+end_src

** Visual bookmarks (bm.el)
:PROPERTIES:
:CUSTOM_ID: h:f20b0d69-6fac-49d5-847f-362aea9f1bef
:END:

This is a deceptively simple-yet-effective package for marking a point
in a buffer for future review. More information in Manuel Uberti's
[[https://www.manueluberti.eu/emacs/2020/03/19/lockdown-beam-bm/][blog entry on the matter]] (2020-03-19). As Manuel puts it:

#+begin_quote
I find bm.el really useful when studying source code from others, or
when I want to quickly set jumping points in a log file cluttered with
stacktraces. It’s quicker then moving around with Isearch or helm-occur,
and unlike avy it’s not limited to what is currently visible on the
screen.
#+end_quote

I use visual bookmarks in much the same way.

#+begin_src emacs-lisp
(use-package bm
  :ensure
  :init
  (setq bm-restore-repository-on-load t)
  :config
  (setq bm-annotate-on-create nil)
  (setq bm-buffer-persistence t)
  (setq bm-cycle-all-buffers t)
  (setq bm-goto-position nil)
  (setq bm-highlight-style 'bm-highlight-only-fringe)
  (setq bm-marker 'bm-marker-left)
  (setq bm-in-lifo-order nil)
  (setq bm-recenter t)
  (setq bm-repository-file "~/.emacs.d/bm-bookmarks")
  (setq bm-repository-size 100)
  (setq bm-show-annotations t)
  (setq bm-wrap-immediately t)
  (setq bm-wrap-search t)
  :bind (("<C-f8>" . bm-next)
         ("<C-S-f8>" . bm-previous)
         ("<s-f8>" . bm-toggle-buffer-persistence)
         ("<f8>" . bm-toggle)))
#+end_src

** Cursor and mouse settings
:PROPERTIES:
:CUSTOM_ID: h:8C9F968E-4897-4FDC-901D-6B2DC2E1EAE6
:END:

*** Multiple cursors (edit in several parts at once)
:PROPERTIES:
:CUSTOM_ID: h:C5D3B4FE-E066-4C21-A8BF-3D7329DEED4C
:END:


The =multiple-cursors= package offers a comprehensive list of commands to
edit text in several points of the screen at once. Though I normally
rely on keyboard macros and =query-replace= to perform complex edits in
numerous parts of a buffer or set thereof, it sometimes is easier to
just pop a few extra cursors and type directly, especially for quick,
one-time operations.

For the technically minded, make sure to read Christopher Wellons'
article on [[https://nullprogram.com/blog/2017/09/07/][Gap Buffers Are Not Optimized for Multiple Cursors]]. Also
quoting from the source code (=M-x find-library multiple-cursors=):

#+begin_quote
Known limitations

- isearch-forward and isearch-backward aren't supported with multiple cursors.
  You should feel free to add a simplified version that can work with it.
- Commands run with `M-x` won't be repeated for all cursors.
- All key bindings that refer to lambdas are always run for all cursors. If you
  need to limit it, you will have to give it a name.
- Redo might screw with your cursors. Undo works very well.
#+end_quote

So learn keyboard macros and =query-replace= and let this package handle
more straightforward workflows.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure
  :bind (("C-<" . mc/mark-previous-like-this)
         ("C->" . mc/mark-next-like-this)
         ("s->" . mc/mark-all-like-this)))
#+end_src

*** Mouse wheel behavior
:PROPERTIES:
:CUSTOM_ID: h:02572210-eb26-4941-8f7c-666a0314877b
:END:

The value of =mouse-wheel-scroll-amount= means the following:

- By default scroll by one line.
- Hold down Shift to do so by five lines.
- Hold down Meta to scroll half a screen.
- Hold down Control to adjust the size of the text. This was added in
  Emacs 27.

The other options in short:

- Hide mouse pointer while typing.
- Enable mouse scroll.
- Scroll window under mouse pointer regardless of whether it is the
  current one or not.

Note that if we enable =mouse-drag-copy-region= we automatically place the
mouse selection to the kill ring. This is the same behavior as
terminal emulators that place the selection to the clipboard (or the
primary selection). I choose not to use this here.

#+begin_src emacs-lisp
(use-package mouse
  :config
  ;; In Emacs 27+, use Control + mouse wheel to scale text.
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 5)
          ((meta) . 0.5)
          ((control) . text-scale)))
  (setq mouse-drag-copy-region nil)
  (setq make-pointer-invisible t)
  (setq mouse-wheel-progressive-speed nil)
  (setq mouse-wheel-follow-mouse t)
  :hook (after-init-hook . mouse-wheel-mode))
#+end_src

*** Scrolling behavior
:PROPERTIES:
:CUSTOM_ID: h:9D1CD37D-A12F-4328-B556-358D2AE73E43
:END:

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behavior of visually
re-centering the point: it is too aggressive as a standard mode of
interaction. With the following =setq-default=, the point will stay at
the top/bottom of the screen while moving in that direction (use =C-l= to
reposition it).

While =indiebrain/scroll-center-cursor-mode= is a simple and super
effective way to get the always-centered behavior on demand. I use it
when I am reading prose or reviewing code and expect to perform few or
no edits.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default scroll-preserve-screen-position t)
  (setq-default scroll-conservatively 1) ; affects `scroll-step'
  (setq-default scroll-margin 0)

  (define-minor-mode indiebrain/scroll-center-cursor-mode
    "Toggle centered cursor scrolling behaviour."
    :init-value nil
    :lighter " S="
    :global nil
    (if indiebrain/scroll-center-cursor-mode
        (setq-local scroll-margin (* (frame-height) 2)
                    scroll-conservatively 0
                    maximum-scroll-margin 0.5)
      (dolist (local '(scroll-preserve-screen-position
                       scroll-conservatively
                       maximum-scroll-margin
                       scroll-margin))
        (kill-local-variable `,local))))

  ;; C-c l is used for `org-store-link'. The mnemonic for this is to
  ;; focus the Line and also works as a variant of C-l.
  :bind ("s-l" . indiebrain/scroll-center-cursor-mode))
#+end_src

*** Delete selection
:PROPERTIES:
:CUSTOM_ID: h:8AA4FEA0-E7C6-43D9-A4F1-D646D88E28BE
:END:

This is a very helpful mode. It kills the marked region when inserting
directly to it. It also has checks to ensure that yanking over a
selected region will not insert itself when =mouse-drag-copy-region= is in
effect (see the section on the [[#h:02572210-eb26-4941-8f7c-666a0314877b][mouse wheel behaviour]]).

#+begin_src emacs-lisp
(use-package delsel
  :hook (after-init-hook . delete-selection-mode))
#+end_src

*Pro tip*: On Emacs 27.1 or higher you can create a rectangular region by
holding down Ctrl and Meta while dragging the mouse with the left click
pressed.

*** Tooltips (tooltip-mode)
:PROPERTIES:
:CUSTOM_ID: h:9503461E-DDC7-438F-AA0E-6ADDA91BE6AF
:END:
These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:

+ I just want to make sure that the GTK theme is /not used/ for those: I
  prefer the generic display which follows my current theme's styles.
+ The delay is slightly reduced for the initial pop-up, while it has
  been increased for immediate pop-ups thereafter.

#+begin_src emacs-lisp
(use-package tooltip
  :config
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq tooltip-frame-parameters
        '((name . "tooltip")
          (internal-border-width . 6)
          (border-width . 0)
          (no-special-glyphs . t)))
  :hook (after-init-hook . tooltip-mode))
#+end_src


These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:

- I just want to make sure that the Window manager theme is /not used/
  for those: I prefer the generic display which follows my current
  theme's styles.
- The delay is slightly reduced for the initial pop-up, while it has
  been increased for immediate pop-ups thereafter.

#+begin_src emacs-lisp
(use-package tooltip
  :config
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq tooltip-frame-parameters
        '((name . "tooltip")
          (internal-border-width . 6)
          (border-width . 0)
          (no-special-glyphs . t)))
  :hook (after-init-hook . tooltip-mode))
#+end_src

** Conveniences and minor extras
:PROPERTIES:
:CUSTOM_ID: h:09FFAD23-391E-4244-A12D-A587958275AD
:END:

*** Auto revert mode
:PROPERTIES:
:CUSTOM_ID: h:3F2E4069-981D-446B-845F-93A061022354
:END:

This mode ensures that the buffer is updated whenever the file changes.
A change can happen externally or by some other tool inside of Emacs
(e.g. kill a Magit diff).

#+begin_src emacs-lisp
(use-package autorevert
  :diminish
  :config
  (setq auto-revert-verbose t)
  :hook (after-init-hook . global-auto-revert-mode))
#+end_src

*** Preserve contents of system clipboard
:PROPERTIES:
:CUSTOM_ID: h:0150994C-6A0F-4A7A-AC53-9FDBFD991C34
:END:

Say you copied a link from your web browser, then switched to Emacs to
paste it somewhere. Before you do that, you notice something you want
to kill. Doing that will place the last kill to the clipboard, thus
overriding the thing you copied earlier. We can have a kill ring
solution to this with the following:

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq save-interprogram-paste-before-kill t))
#+end_src

Now the contents of the clipboard are stored in the kill ring and can
be retrieved from there (e.g. with =M-y=).

*** Generic feedback
:PROPERTIES:
:CUSTOM_ID: h:4BB4F52D-B058-4C18-BDCD-87AB1DFDB86F
:END:

The common thread of these options is the feedback they provide us
with or simplify common tasks so that /their/ feedback does not cause
friction:

- Show the current buffer's name as the frame's title. This only
  affects window managers that have window decorations. If you do not
  know what that means, then you are most likely using an environment
  where frame titles are already visible.
- Faster feedback for key chords (keys appear in the echo area).
- Allow inputting Greek while preserving Emacs keys. Toggle with =C-\=.
- Ignore visual or audible bells. Emacs has more appropriate ways of
  providing error/warning messages or hints that something is not
  producing the desired results (e.g. a failed =isearch= will return no
  results, while the failed match will be styled accordingly in the echo
  area). By the way, use =C-h e= to bring up the log with the echo area's
  messages.
- Answer with just the initials when dealing with "yes/no" questions.
- Enable actions for narrowing the buffer, region {up,down}casing (all
  caps or no caps), =dired= single-buffer navigation (bound to =a=).
  Disable overwrite-mode.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq frame-title-format '("%b"))
  (setq echo-keystrokes 0.25)
  (setq default-input-method "greek")
  (setq ring-bell-function 'ignore)

  (defalias 'yes-or-no-p 'y-or-n-p)
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'overwrite-mode 'disabled t))
#+end_src

*** Newline characters for file ending
:PROPERTIES:
:CUSTOM_ID: h:9AAEC463-DC39-4600-B78D-FB1CA3EAB4B2
:END:

For some major modes, such as =diff-mode=, a final newline is of
paramount importance. Without it you cannot, for instance, apply a
patch cleanly. As such, the =mode-require-final-newline= will add a
newline character when visiting or saving a buffer of relevance.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq mode-require-final-newline 'visit-save))
#+end_src

*** Package lists
:PROPERTIES:
:CUSTOM_ID: h:532CC737-13EF-430B-86F3-6BEA2876E5C3
:END:

With this I just want to enable line highlighting when browsing the
list of packages. I generally use =hl-line-mode= on all interfaces
where the current line is more important than the exact column of the
point.

#+begin_src emacs-lisp
(use-package package
  :commands (list-packages
             package-refresh-contents
             package-list-packages)
  :config
  ;; All variables are for Emacs 28+
  (setq package-name-column-width 40)
  (setq package-version-column-width 14)
  (setq package-status-column-width 12)
  (setq package-archive-column-width 8)
  :hook (package-menu-mode-hook . hl-line-mode))
#+end_src

* Language settings for prose and code
:PROPERTIES:
:CUSTOM_ID: h:478C4948-62A1-4F4D-899D-28FB1121455C
:END:

** Programming Language specific support
:PROPERTIES:
:CUSTOM_ID: h:8A4237AB-61F5-498A-8E32-390EB783DA37
:END:

I develop software in a large number of languages and platforms. Emacs
is my staple tool for working in this manner. As such this section
contains quite a long list of language-specific sections which support
my day-to-day operations.
*** Common configuration
:PROPERTIES:
:CUSTOM_ID: h:424B937D-C734-41D3-8A71-2D2D8EF882A4
:END:

This section contains configuration common across all programming
language specific modes for consistency's sake. Some notable
behaviors include:

- Enable the auto insertion of closing delimiters (=electric-pair-mode=).
  See: [[*Configure 'electric' behavior][Configure 'electric' behavior]].
- Enable auto-completion of terms. See: [[#h:86E59081-F057-4B7C-969E-012487A87EDC][In-buffer completions]].
- Enables spell checking of code comments. See [[#h:DB14B9F0-C8CA-4841-A295-62C7A673620D][Spell checking (flyspell)]]
- Enables in-buffer linter feedback. See: [[#h:42BE413C-9A59-4ED2-A614-D3F3E500CF05][Linters]]
- Enables project navigation. See: [[#h:45BB62A4-8381-499F-9404-D613FF217434][Project navigation]]

#+begin_src emacs-lisp
(use-package prog-mode
  :hook (prog-mode-hook . (lambda ()
                            (electric-pair-mode t)
                            (company-mode t)
                            (flyspell-prog-mode)
                            (flymake-mode)
                            (flycheck-mode)
                            (projectile-mode))))
#+end_src

*** Bash script - The Bourne Again Shell
:PROPERTIES:
:CUSTOM_ID: h:1773F494-796A-4CC4-84F6-BDBF6088D1E6
:END:

There are many shells; some considered more fashionable. However, the
=bash= shell is ubiquitous, mature, and simple enough to be productive in
most contexts.

A [[https://devhints.io/bash][quick reference]] should be enough for most to get started with Bash
scripting, but for a more in depth look at Bash see the [[https://www.gnu.org/software/bash/manual/][GNU reference
manuals]]. This section enhances Emacs to be able to effectively
develop, test, and maintain =bash= scripts.

**** BATS (=bash= Automated Testing System)
:PROPERTIES:
:CUSTOM_ID: h:C0CF8151-5BC0-44B0-9F10-3E5750A2A5AF
:END:

[[https://github.com/sstephenson/bats][BATS]] is a [[http://testanything.org/][TAP]]-compliant testing framework for Bourne Again Shell
scripts. It provides a simple way to verify that the UNIX programs you
write behave as expected. BATS is most useful when testing software
written in Bash, but you can use it to test any UNIX
program. [[https://github.com/dougm/bats-mode][bats-mode]] provides editing support and functions for running
BATS tests within Emacs.

Common key chords for running BATS tests

| Key chord | Description                            |
|-----------+----------------------------------------|
| =C-c C-a=   | Run all tests in the current directory |
| =C-c C-,=   | Run all tests in the current file      |
| =C-c M-,=   | Run the current test at the point      |

#+begin_src emacs-lisp
(use-package bats-mode
  :ensure
  :after (sh-mode))
#+end_src

**** In-buffer linting (shellcheck)

Shellcheck is an external tool which lints shell scripts.

#+begin_src emacs-lisp
(use-package sh-script
  :after (flycheck)
  :ensure-system-package shellcheck
  :config
  ;;; Define a flycheck checker for shellcheck
  ;;; From: https://github.com/flycheck/flycheck/blob/0f144f13a07e202169acb63880d989cb41787759/doc/developer/developing.rst#writing-more-complex-checkers
  (flycheck-define-checker sh-shellcheck
    "A shell script syntax and style checker using Shellcheck.

    See URL `https://github.com/koalaman/shellcheck/'."
    :command ("shellcheck"
              "--format" "checkstyle"
              "--shell" (eval (symbol-name sh-shell))
              (option-flag "--external-sources"
                           flycheck-shellcheck-follow-sources)
              (option "--exclude" flycheck-shellcheck-excluded-warnings list
                      flycheck-option-comma-separated-list)
              "-")
    :standard-input t
    :modes sh-mode
    :error-parser flycheck-parse-checkstyle
    :error-filter (lambda (errors)
                    (flycheck-remove-error-file-names "-" errors))
    :predicate (lambda () (memq sh-shell '(bash ksh88 sh)))
    :verify
    (lambda (_)
      (let ((supported (memq sh-shell '(bash ksh88 sh))))
        (list (flycheck-verification-result-new
               :label (format "Shell %s supported" sh-shell)
               :message (if supported "yes" "no")
               :face (if supports-shell 'success '(bold warning))))))
    :error-explainer
    (lambda (err)
      (let ((error-code (flycheck-error-id err))
            (url "https://github.com/koalaman/shellcheck/wiki/%S"))
        (and error-code `(url . ,(format url error-code)))))))
#+end_src

*** Cascading Style Sheets (CSS)
:PROPERTIES:
:CUSTOM_ID: h:486B4E4F-FC3B-41AB-991D-37651C0BF9A8
:END:

#+begin_quote
Cascading Style Sheets (CSS) is a stylesheet language used to describe
the presentation of a document written in HTML or XML (including XML
dialects such as SVG, MathML or XHTML). CSS describes how elements
should be rendered on screen, on paper, in speech, or on other media.

CSS is among the core languages of the open web and is standardized
across Web browsers according to W3C specifications.
#+end_quote

The Mozilla Developer Network (MDN) web documentation is a delightfully
accessible reference for many web related technologies. The [[https://developer.mozilla.org/en-US/docs/Web/CSS][MDN section
on CSS]] includes tutorials, and reference documentation - pro gratis.

=css-mode= is a built-in faculty of Emacs. This configuration ensures
that the indentation level within a =css-mode= buffer is set to 2
whitespace characters, rather than the default 4 whitespace characters.

#+begin_src emacs-lisp
(use-package css-mode
  :config
  (setq css-indent-offset 2))
#+end_src

*** Caddy - a powerful, extensible platform to serve web traffic
:PROPERTIES:
:CUSTOM_ID: h:7F4FEA13-C395-48D0-8F8F-D3B27F2F8486
:END:

#+begin_quote
Caddy is a powerful, extensible platform to serve your sites,
services, and apps, written in Go. Although most people use it as a
web server or proxy, it is an excellent choice for a:

web server
reverse proxy
sidecar proxy
load balancer
API gateway
ingress controller
system manager
process supervisor
task scheduler
(any long-running process)

and operates primarily at L4 (transport layer) and L7 (application
layer) of the OSI model, though it has the ability to work with other
layers.

Configuration is both dynamic and exportable with Caddy's
API. Although no config files required, you can still use them; most
people's favorite way of configuring Caddy is using the Caddyfile. The
format of the config document takes many forms with config adapters,
but Caddy's native config language is JSON.

Caddy compiles for all major platforms and has no runtime
dependencies.
#+end_quote

The Caddy project provides [[https://caddyserver.com/docs/quick-starts][in-depth documentation of its programmable
API and Caddyfile format]].

This section adds syntax highlighting for editing the configuration
files used to influence the behavior of instances of the Caddy web
server.

#+begin_src emacs-lisp
(use-package caddyfile-mode
  :ensure)
#+end_src

*** Docker
:PROPERTIES:
:CUSTOM_ID: h:2461A489-4BE5-4C9D-B00A-C1B37EF6F1CE
:END:

#+begin_quote
Docker is a set of platform as a service (PaaS) products that use
OS-level virtualization to deliver software in packages called
containers. Containers are isolated from one another and bundle their
own software, libraries and configuration files; they can communicate
with each other through well-defined channels. All containers are run
by a single operating system kernel and therefore use fewer resources
than virtual machines.
#+end_quote

**** Dockerfile syntax highlighting and basic =docker= client wrappers
:PROPERTIES:
:CUSTOM_ID: h:BFBD773A-0E1D-4D89-BCF3-23AC06CBCDC2
:END:

Instructions on how to build a container images with Docker's build
tools are described in the =Dockerfile= format. While this is by no
means the only way to build container images, it is a widely used
method of doing so. The [[https://docs.docker.com/engine/reference/builder/][=Dockerfile= format's reference documentation]]
describes the format's syntax in detail.

When editing a =Dockerfile=, the following configuration enable Emacs to
perform syntax highlighting. Additionally, it provides a wrapper around
the =docker= client command-line interface. This makes it possible to
perform =docker= commands from directly inside Emacs. Such as:

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :ensure
  :ensure-system-package docker)
#+end_src

**** Using tramp to gain access to docker containers
:PROPERTIES:
:CUSTOM_ID: h:A2592ECF-33D3-4939-B2DC-013F68DE0559
:END:

Use =docker-tramp= to allow editing of files inside running
containers. When building docker images there can be a high cost to
productivity if one is to rebuild the container when testing out minor
changes like tweaking a minor config setting. This allows us to open a
tramp session in a running container see results more quickly than
rebuilding the container every time. Caveat, unless those changes are
preserved in a volume mount they disappear when the container exits so
use docker-tramp with caution.

To use =C-x C-f /docker:<user>@<container-id>:<path-to-file> RET=.

#+begin_src emacs-lisp
(use-package docker-tramp
  :after (tramp)
  :ensure)
#+end_src

*** The Go programming language (golang)
:PROPERTIES:
:CUSTOM_ID: h:A83D883C-030E-4E53-9012-4AEA1FE4FD61
:END:

#+begin_quote
Go is an open source programming language that makes it easy to build
simple, reliable, and efficient software.
#+end_quote

While =Go= has gained in popularity in recent years, my contact with it
is mostly limited to internals and extensions to the Kubernetes
orchestration tool. As such, this configuration is not very
sophisticated, and mostly appropriate - I'd imagine to the casual user
of =Go=.

The following adds syntax highlighting and basic tooling to interact
with =golang= projects. The only notable bit of configuration is that
this adds a =before-save-hook= to run the =gofmt= utility on a buffer
before its contents are flushed to disk.

#+begin_src emacs-lisp
(use-package go-mode
  :ensure
  :hook
  (before-save-hook . gofmt-before-save))
#+end_src

*** JavaScript
:PROPERTIES:
:CUSTOM_ID: h:E3E82ED2-7A81-4B20-A3E9-2DE51D068344
:END:

#+begin_quote
JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled
programming language with first-class functions. While it is most
well-known as the scripting language for Web pages, many non-browser
environments also use it, such as Node.js, Apache CouchDB and Adobe
Acrobat. JavaScript is a prototype-based, multi-paradigm,
single-threaded, dynamic language, supporting object-oriented,
imperative, and declarative (e.g. functional programming) styles.
#+end_quote

The Mozilla Developer Network (MDN) web documentation is a delightfully
accessible reference for many web related technologies. The [[https://developer.mozilla.org/en-US/docs/Web/javascript][MDN section
on JavaScript]] includes tutorials and reference documentation - pro gratis.

There are many modes for working with JavaScript inside of Emacs. Most
represent iterations of supporting older versions of ECMAScript - the
language specification which JavaScript runtimes implement.

While Emacs does have a built-in =js-mode=, the sometimes maligned
=js2-mode= offers some more advanced capabilities. =js2-mode= checks syntax
on-the-fly using a built in parser written in elisp - it actually
validates the buffer's code as it's typed.

Some notable configurations:

- Intends are made using two whitespace characters.
- Many of the built-in functions of ECMA will be highlighted as syntax.
- Errors parsing the JavaScript document will be highlighted.
- The parser will print warnings about JavaScript strict-mode
  violations. These are common pitfalls in the language specification
  which can lead to unintended, or difficult to debug behavior at
  run-time.

#+begin_src emacs-lisp
(use-package js2-mode
  :ensure
  :mode (
         ("\\.js$'" . js2-mode)
         ("\\.json$" . js2-mode))
  :interpreter (("node" . js2-mode))
  :config
  (setq js2-basic-offset 2)
  (setq js2-highlight-level 3)
  (setq js2-mode-show-parse-errors t)
  (setq js2-mode-show-strict-warnings t))
#+end_src

**** In-buffer linting

This section configures in-buffer linting for JavaScript via the =eslint=
library.

NOTE: this particular configuration is specific to an employer's setup.
It expects the =eslint= program to be present in
=./node_modules/.bin/eslint=.

#+begin_src emacs-lisp
(use-package js2-mode
  :after (flycheck)
  :config
  (setq-default flycheck-disabled-checkers (append flycheck-disabled-checkers '(javascript-jshint)))
  (flycheck-add-mode 'javascript-eslint 'js-mode)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (setq flycheck-javascript-eslint-executable "node_modules/.bin/eslint"))
#+end_src

*** Markdown
:PROPERTIES:
:CUSTOM_ID: h:38D051A4-2CFF-49EE-910B-81A00FAD18E6
:END:

As much as Org is superior as a markup tool, Markdown is unavoidable
when collaborating with other human beings on the internet. This
configuration is concerned with little more than basic syntax
highlighting of Markdown documents.

#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure)
#+end_src

*** Ruby

This section provides configuration for interacting with the Ruby
programming language. Emacs has a built-in =ruby-mode= which works
exceptionally well out of the box. This bit associates some additional
file types with the =ruby-mode= - like Rakefiles, gemspecs, Gemfiles, and
more.

Some more details on the configuration settings here:

- =ruby-insert-encoding-magic-comment= is disabled to prevent the
  automatic insertion of an encoding metadata comment into each =ruby-mode=
  buffer.
- =ruby-deep-indent-paren= is disabled to ensure that indentation follows
  consistent rules - 2 spaces - rather than indenting to whatever column
  the opening delimiter is oriented.
- =ruby-indent-tabs-mode= is disabled to prevent the insertion of tabs as
  indentation characters.

#+begin_src emacs-lisp
(use-package ruby-mode
  :mode
  (("\\.rb$" . ruby-mode)
   ("\\.rake$" . ruby-mode)
   ("Rakefile$" . ruby-mode)
   ("\\.gemspec$" . ruby-mode)
   ("\\.ru$" . ruby-mode)
   ("Gemfile$" . ruby-mode)
   ("Guardfile$" . ruby-mode))
  :config
  (setq ruby-insert-encoding-magic-comment nil
        ruby-deep-indent-paren nil
        ruby-indent-tabs-mode nil))
#+end_src

**** In-buffer evaluation

This section extends the functionality of =ruby-mode= buffers such that
they, or portions of them, can be sent to an external ruby process for
evaluation. The results of the evaluation can then be placed in a
comment in the buffer. This is achieved via the =rcodetools= gem and the
integrating code contained in this section.

Use the =C-c C-c= key chord to send the content of a =ruby-mode= buffer for
evaluation.

Since everything in Ruby is an expression, the value of anything can
inspected by adding a line comment on the item to be inspected. For
example:

#+begin_example ruby
wumpus = "found me!"
wumpus                          # => "found me!"
#+end_example

#+begin_src emacs-lisp
(use-package ruby-mode
  :bind (("C-c C-c" . xmp))
  :config
  (progn
    ;;; rcodetools.el -- annotation / accurate completion / browsing documentation

    ;;; Copyright (c) 2006-2008 rubikitch <rubikitch@ruby-lang.org>
    ;;;
    ;;; Use and distribution subject to the terms of the Ruby license.

    (defvar xmpfilter-command-name "ruby -S xmpfilter --dev --fork --detect-rbtest"
      "The xmpfilter command name.")
    (defvar rct-doc-command-name "ruby -S rct-doc --dev --fork --detect-rbtest"
      "The rct-doc command name.")
    (defvar rct-complete-command-name "ruby -S rct-complete --dev --fork --detect-rbtest"
      "The rct-complete command name.")
    (defvar ruby-toggle-file-command-name "ruby -S ruby-toggle-file"
      "The ruby-toggle-file command name.")
    (defvar rct-fork-command-name "ruby -S rct-fork")
    (defvar rct-option-history nil)                ;internal
    (defvar rct-option-local nil)     ;internal
    (make-variable-buffer-local 'rct-option-local)
    (defvar rct-debug nil
      "If non-nil, output debug message into *Messages*.")
    ;; (setq rct-debug t)

    (defadvice comment-dwim (around rct-hack activate)
      "If comment-dwim is successively called, add => mark."
      (if (and (eq major-mode 'ruby-mode)
               (eq last-command 'comment-dwim)
               ;; TODO =>check
               )
          (insert "=>")
        ad-do-it))
    ;; To remove this advice.
    ;; (progn (ad-disable-advice 'comment-dwim 'around 'rct-hack) (ad-update 'comment-dwim))

    (defun rct-current-line ()
      "Return the vertical position of point..."
      (+ (count-lines (point-min) (point))
         (if (= (current-column) 0) 1 0)))

    (defun rct-save-position (proc)
      "Evaluate proc with saving current-line/current-column/window-start."
      (let ((line (rct-current-line))
            (col  (current-column))
            (wstart (window-start)))
        (funcall proc)
        (goto-char (point-min))
        (forward-line (1- line))
        (move-to-column col)
        (set-window-start (selected-window) wstart)))

    (defun rct-interactive ()
      "All the rcodetools-related commands with prefix args read rcodetools' common option. And store option into buffer-local variable."
      (list
       (let ((option (or rct-option-local "")))
         (if current-prefix-arg
             (setq rct-option-local
                   (read-from-minibuffer "rcodetools option: " option nil nil 'rct-option-history))
           option))))

    (defun rct-shell-command (command &optional buffer)
      "Replacement for `(shell-command-on-region (point-min) (point-max) command buffer t' because of encoding problem."
      (let ((input-rb (concat (make-temp-name "xmptmp-in") ".rb"))
            (output-rb (concat (make-temp-name "xmptmp-out") ".rb"))
            (coding-system-for-read buffer-file-coding-system))
        (write-region (point-min) (point-max) input-rb nil 'nodisp)
        (shell-command
         (rct-debuglog (format "%s %s > %s" command input-rb output-rb))
         t " *rct-error*")
        (with-current-buffer (or buffer (current-buffer))
          (insert-file-contents output-rb nil nil nil t))
        (delete-file input-rb)
        (delete-file output-rb)))

    (defvar xmpfilter-command-function 'xmpfilter-command)
    (defun xmp (&optional option)
      "Run xmpfilter for annotation/test/spec on whole buffer.
See also `rct-interactive'. "
      (interactive (rct-interactive))
      (rct-save-position
       (lambda ()
         (rct-shell-command (funcall xmpfilter-command-function option)))))

    (defun xmpfilter-command (&optional option)
      "The xmpfilter command line, DWIM."
      (setq option (or option ""))
      (flet ((in-block (beg-re)
                       (save-excursion
                         (goto-char (point-min))
                         (when (re-search-forward beg-re nil t)
                           (let ((s (point)) e)
                             (when (re-search-forward "^end\n" nil t)
                               (setq e (point))
                               (goto-char s)
                               (re-search-forward "# => *$" e t)))))))
            (cond ((in-block "^class.+< Test::Unit::TestCase$")
                   (format "%s --unittest %s" xmpfilter-command-name option))
                  ((in-block "^\\(describe\\|context\\).+do$")
                   (format "%s --spec %s" xmpfilter-command-name option))
                  (t
                   (format "%s %s" xmpfilter-command-name option)))))

;;;; Completion
    (defvar rct-method-completion-table nil) ;internal
    (defvar rct-complete-symbol-function 'rct-complete-symbol--normal
      "Function to use rct-complete-symbol.")
    ;; (setq rct-complete-symbol-function 'rct-complete-symbol--icicles)
    (defvar rct-use-test-script t
      "Whether rct-complete/rct-doc use test scripts.")

    (defun rct-complete-symbol (&optional option)
      "Perform ruby method and class completion on the text around point.
This command only calls a function according to `rct-complete-symbol-function'.
See also `rct-interactive', `rct-complete-symbol--normal', and `rct-complete-symbol--icicles'."
      (interactive (rct-interactive))
      (call-interactively rct-complete-symbol-function))

    (defun rct-complete-symbol--normal (&optional option)
      "Perform ruby method and class completion on the text around point.
See also `rct-interactive'."
      (interactive (rct-interactive))
      (let ((end (point)) beg
            pattern alist
            completion)
        (setq completion (rct-try-completion)) ; set also pattern / completion
        (save-excursion
          (search-backward pattern)
          (setq beg (point)))
        (cond ((eq completion t)            ;sole completion
               (message "%s" "Sole completion"))
              ((null completion)            ;no completions
               (message "Can't find completion for \"%s\"" pattern)
               (ding))
              ((not (string= pattern completion)) ;partial completion
               (delete-region beg end)      ;delete word
               (insert completion)
               (message ""))
              (t
               (message "Making completion list...")
               (with-output-to-temp-buffer "*Completions*"
                 (display-completion-list
                  (all-completions pattern alist)))
               (message "Making completion list...%s" "done")))))

    ;; (define-key ruby-mode-map "\M-\C-i" 'rct-complete-symbol)

    (defun rct-debuglog (logmsg)
      "if `rct-debug' is non-nil, output LOGMSG into *Messages*. Returns LOGMSG."
      (if rct-debug
          (message "%s" logmsg))
      logmsg)

    (defun rct-exec-and-eval (command opt)
      "Execute rct-complete/rct-doc and evaluate the output."
      (let ((eval-buffer  (get-buffer-create " *rct-eval*")))
        ;; copy to temporary buffer to do completion at non-EOL.
        (rct-shell-command
         (format "%s %s %s --line=%d --column=%d %s"
                 command opt (or rct-option-local "")
                 (rct-current-line)
                 ;; specify column in BYTE
                 (string-bytes
                  (encode-coding-string
                   (buffer-substring (point-at-bol) (point))
                   buffer-file-coding-system))
                 (if rct-use-test-script (rct-test-script-option-string) ""))
         eval-buffer)
        (message "")
        (eval (with-current-buffer eval-buffer
                (goto-char 1)
                (unwind-protect
                    (read (current-buffer))
                  (unless rct-debug (kill-buffer eval-buffer)))))))

    (defun rct-test-script-option-string ()
      (if (null buffer-file-name)
          ""
        (let ((test-buf (rct-find-test-script-buffer))
              (bfn buffer-file-name)
              bfn2 t-opt test-filename)
          (if (and test-buf
                   (setq bfn2 (buffer-local-value 'buffer-file-name test-buf))
                   (file-exists-p bfn2))
              ;; pass test script's filename and lineno
              (with-current-buffer test-buf
                (setq t-opt (format "%s@%s" buffer-file-name (rct-current-line)))
                (format "-t %s --filename=%s" t-opt bfn))
            ""))))

    (require 'cl)

    (defun rct-find-test-script-buffer (&optional buffer-list)
      "Find the latest used Ruby test script buffer."
      (setq buffer-list (or buffer-list (buffer-list)))
      (dolist (buf buffer-list)
        (with-current-buffer buf
          (if (and buffer-file-name (string-match "test.*\.rb$" buffer-file-name))
              (return buf)))))

    ;; (defun rct-find-test-method (buffer)
    ;;   "Find test method on point on BUFFER."
    ;;   (with-current-buffer buffer
    ;;     (save-excursion
    ;;       (forward-line 1)
    ;;       (if (re-search-backward "^ *def *\\(test_[A-Za-z0-9?!_]+\\)" nil t)
    ;;           (match-string 1)))))

    (defun rct-try-completion ()
      "Evaluate the output of rct-complete."
      (rct-exec-and-eval rct-complete-command-name "--completion-emacs"))

;;;; TAGS or Ri
    (autoload 'ri "ri-ruby" nil t)
    (defvar rct-find-tag-if-available t
      "If non-nil and the method location is in TAGS, go to the location instead of show documentation.")
    (defun rct-ri (&optional option)
      "Browse Ri document at the point.
If `rct-find-tag-if-available' is non-nil, search the definition using TAGS.

See also `rct-interactive'. "
      (interactive (rct-interactive))
      (rct-exec-and-eval
       rct-doc-command-name
       (concat "--ri-emacs --use-method-analyzer "
               (if (buffer-file-name)
                   (concat "--filename=" (buffer-file-name))
                 ""))))

    (defun rct-find-tag-or-ri (fullname)
      (if (not rct-find-tag-if-available)
          (ri fullname)
        (condition-case err
            (let ()
              (visit-tags-table-buffer)
              (find-tag-in-order (concat "::" fullname) 'search-forward '(tag-exact-match-p) nil  "containing" t))
          (error
           (ri fullname)))))

;;;;
    (defun ruby-toggle-buffer ()
      "Open a related file to the current buffer. test<=>impl."
      (interactive)
      (find-file (shell-command-to-string
                  (format "%s %s" ruby-toggle-file-command-name buffer-file-name))))

;;;; rct-fork support
    (defun rct-fork (options)
      "Run rct-fork.
Rct-fork makes xmpfilter and completion MUCH FASTER because it pre-loads heavy libraries.
When rct-fork is running, the mode-line indicates it to avoid unnecessary run.
To kill rct-fork process, use \\[rct-fork-kill].
"
      (interactive (list
                    (read-string "rct-fork options (-e CODE -I LIBDIR -r LIB): "
                                 (rct-fork-default-options))))
      (rct-fork-kill)
      (rct-fork-minor-mode 1)
      (start-process-shell-command
       "rct-fork" "*rct-fork*" rct-fork-command-name options))

    (defun rct-fork-default-options ()
      "Default options for rct-fork by collecting requires."
      (mapconcat
       (lambda (lib) (format "-r %s" lib))
       (save-excursion
         (goto-char (point-min))
         (loop while (re-search-forward "\\<require\\> ['\"]\\([^'\"]+\\)['\"]" nil t)
               collect (match-string-no-properties 1)))
       " "))

    (defun rct-fork-kill ()
      "Kill rct-fork process invoked by \\[rct-fork]."
      (interactive)
      (when rct-fork-minor-mode
        (rct-fork-minor-mode -1)
        (interrupt-process "rct-fork")))
    (define-minor-mode rct-fork-minor-mode
      "This minor mode is turned on when rct-fork is run.
It is nothing but an indicator."
      :lighter " <rct-fork>" :global t)

;;;; unit tests
    (when (and (fboundp 'expectations))
      (require 'ruby-mode)
      (require 'el-mock nil t)
      (expectations
       (desc "comment-dwim advice")
       (expect "# =>"
               (with-temp-buffer
                 (ruby-mode)
                 (setq last-command nil)
                 (call-interactively 'comment-dwim)
                 (setq last-command 'comment-dwim)
                 (call-interactively 'comment-dwim)
                 (buffer-string)))
       (expect (regexp "^1 +# =>")
               (with-temp-buffer
                 (ruby-mode)
                 (insert "1")
                 (setq last-command nil)
                 (call-interactively 'comment-dwim)
                 (setq last-command 'comment-dwim)
                 (call-interactively 'comment-dwim)
                 (buffer-string)))

       (desc "rct-current-line")
       (expect 1
               (with-temp-buffer
                 (rct-current-line)))
       (expect 1
               (with-temp-buffer
                 (insert "1")
                 (rct-current-line)))
       (expect 2
               (with-temp-buffer
                 (insert "1\n")
                 (rct-current-line)))
       (expect 2
               (with-temp-buffer
                 (insert "1\n2")
                 (rct-current-line)))

       (desc "rct-save-position")
       (expect (mock (set-window-start * 7) => nil)
               (stub window-start => 7)
               (with-temp-buffer
                 (insert "abcdef\nghi")
                 (rct-save-position #'ignore)))
       (expect 2
               (with-temp-buffer
                 (stub window-start => 1)
                 (stub set-window-start => nil)
                 (insert "abcdef\nghi")
                 (rct-save-position #'ignore)
                 (rct-current-line)))
       (expect 3
               (with-temp-buffer
                 (stub window-start => 1)
                 (stub set-window-start => nil)
                 (insert "abcdef\nghi")
                 (rct-save-position #'ignore)
                 (current-column)))

       (desc "rct-interactive")
       (expect '("read")
               (let ((current-prefix-arg t))
                 (stub read-from-minibuffer => "read")
                 (rct-interactive)))
       (expect '("-S ruby19")
               (let ((current-prefix-arg nil)
                     (rct-option-local "-S ruby19"))
                 (stub read-from-minibuffer => "read")
                 (rct-interactive)))
       (expect '("")
               (let ((current-prefix-arg nil)
                     (rct-option-local))
                 (stub read-from-minibuffer => "read")
                 (rct-interactive)))

       (desc "rct-shell-command")
       (expect "1+1 # => 2\n"
               (with-temp-buffer
                 (insert "1+1 # =>\n")
                 (rct-shell-command "xmpfilter")
                 (buffer-string)))

       (desc "xmp")

       (desc "xmpfilter-command")
       (expect "xmpfilter --rails"
               (let ((xmpfilter-command-name "xmpfilter"))
                 (with-temp-buffer
                   (insert "class TestFoo < Test::Unit::TestCase\n")
                   (xmpfilter-command "--rails"))))
       (expect "xmpfilter "
               (let ((xmpfilter-command-name "xmpfilter"))
                 (with-temp-buffer
                   (insert "context 'foo' do\n")
                   (xmpfilter-command))))
       (expect "xmpfilter "
               (let ((xmpfilter-command-name "xmpfilter"))
                 (with-temp-buffer
                   (insert "describe Array do\n")
                   (xmpfilter-command))))
       (expect "xmpfilter --unittest --rails"
               (let ((xmpfilter-command-name "xmpfilter"))
                 (with-temp-buffer
                   (insert "class TestFoo < Test::Unit::TestCase\n"
                           "  def test_0\n"
                           "    1 + 1 # =>\n"
                           "  end\n"
                           "end\n")
                   (xmpfilter-command "--rails"))))
       (expect "xmpfilter --spec "
               (let ((xmpfilter-command-name "xmpfilter"))
                 (with-temp-buffer
                   (insert "context 'foo' do\n"
                           "  specify \"foo\" do\n"
                           "    1 + 1 # =>\n"
                           "  end\n"
                           "end\n")
                   (xmpfilter-command))))
       (expect "xmpfilter --spec "
               (let ((xmpfilter-command-name "xmpfilter"))
                 (with-temp-buffer
                   (insert "describe Array do\n"
                           "  it \"foo\" do\n"
                           "    [1] + [1] # =>\n"
                           "  end\n"
                           "end\n")
                   (xmpfilter-command))))
       (expect "xmpfilter "
               (let ((xmpfilter-command-name "xmpfilter"))
                 (with-temp-buffer
                   (insert "1 + 2\n")
                   (xmpfilter-command))))

       (desc "rct-fork")
       (expect t
               (stub start-process-shell-command => t)
               (stub interrupt-process => t)
               (rct-fork "-r activesupport")
               rct-fork-minor-mode)
       (expect nil
               (stub start-process-shell-command => t)
               (stub interrupt-process => t)
               (rct-fork "-r activesupport")
               (rct-fork-kill)
               rct-fork-minor-mode)
       ))

    (provide 'rcodetools)
    ))
#+end_src

**** In-buffer linting

This section configures in-buffer linting for Ruby via the =rubocop=
library.

NOTE: this particular configuration is specific to an employer's setup.
It expects the =rubocop= program to be runnable via a binstub in =./bin/rubocop=.

#+begin_src emacs-lisp
(use-package ruby-mode
  :after (flycheck)
  :config
  (setq flycheck-ruby-rubocop-executable "bin/rubocop"))
#+end_src

**** Automatic insertion of =end= keywords

This configuration provides similar functionality to =electric-pair-mode=
(See: [[#h:6A355747-FED5-44FB-955A-A4D32FBC39A0][Configure 'electric' behavior]]) but for automatic insertion of =end=
keywords.

#+begin_src emacs-lisp
(use-package ruby-end
  :ensure)
#+end_src

**** Ruby specifications (rspec)

This section integrates Emacs with the =rspec= Behavior Driven Development
framework. This is useful in targeting sections of a specification or
suite of specifications. Some interactions of note:

| Key chord | Description                                             |
|-----------+---------------------------------------------------------|
| =C-c , s=   | Verify the example or method defined at the point       |
| =C-c , v=   | Verify the spec file associated with the current buffer |
| =C-c , a=   | Run the entire specification suite                      |
| =C-c , r=   | Re-run the last verification process                    |
|           |                                                         |

#+begin_src emacs-lisp
(use-package inf-ruby
  :ensure)

(use-package rspec-mode
  :ensure
  :after (inf-ruby)
  :config
  (setq compilation-scroll-output 'first-error)
  :hook ((after-init-hook . inf-ruby-switch-setup)
         (rspec-compilation-mode-hook . (lambda ()
                                          (company-mode -1)))))
#+end_src

**** Embedded ruby (.erb) templates

ERB is a template language which can be use to build dynamically
produce documents in various formats - HTML, YAML, etc. This section
configures Emacs for basic interaction with these kinds of templates.

***** HTML

This configuration uses the built-in =web-mode= package for interacting
with =.html.erb= templates.

#+begin_src emacs-lisp
(use-package web-mode
  :mode ("\\.html.erb$" . web-mode)
  :config
  (setq web-mode-markup-indent-offset 2))
#+end_src

***** YAML

This configuration uses the =yaml-mode= package for interacting with
=.yaml.erb= templates.

#+begin_src emacs-lisp
(use-package yaml
  :mode (("\\.yml.erb$" . yaml-mode)
         ("\\.yaml.erb$" . yaml-mode))
  :hook (yaml-mode-hook . (lambda ()
                            (turn-off-auto-fill))))
#+end_src

*** Rust

#+begin_quote
Rust. The Rust programming language helps you write faster, more
reliable software. High-level ergonomics and low-level control are often
at odds in programming language design; Rust challenges that conflict.
Through balancing powerful technical capacity and a great developer
experience, Rust gives you the option to control low-level details (such
as memory usage) without all the hassle traditionally associated with
such control.
#+end_quote

This section configures Emacs for work with the Rust programming
language. My primary contact with this language is working through [[https://doc.rust-lang.org/book/title-page.html][The
Rust Programming Language]] book - also available locally via =rustup doc
--book=. As such, the configuration here is rather basic. Some notable
features:

- A "Language Server Protocol" process; an external process
  used to perform contextual documentation and assist in running certain
  tools - such as =rustfmt=.
- =rustfmt=, the rust formatter, is run as a =before-save-hook=.

#+begin_src emacs-lisp
(use-package lsp-mode
  :ensure
  :hook ((rust-mode . lsp-deferred))
  :commands (lsp lsp-deferred))

(use-package rust-mode
  :after (lsp-mode)
  :ensure
  :hook ((before-save-hook . (lambda ()
                               (when (eq 'rust-mode major-mode)
                                 (lsp-format-buffer))))))
#+end_src

**** Cargo

This section adds a simple interface over the =rust= build and package
management tool =cargo=.

#+begin_src emacs-lisp
(use-package cargo
  :after (rust)
  :ensure)
#+end_src

**** In-buffer linting (flycheck-rust)

This section enables in-buffer linting of rust code via =flycheck= (See:
[[#h:42BE413C-9A59-4ED2-A614-D3F3E500CF05][Linters]])

#+begin_src emacs-lisp
(use-package flycheck-rust
  :after (flycheck rust)
  :ensure
  :config
  (with-eval-after-load 'rust-mode
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))
#+end_src

*** Web

The =web-mode= provides tools for working with complex web resources and
various tempting resources.

#+begin_src emacs-lisp
(use-package web-mode
  :ensure)
#+end_src

*** YAML Ain't Markup Language (YAML)

#+begin_quote
Yaml is a human-readable data serialization language. It's commonly used
for configuration files in applications where data is stored or
transmitted.YAML (a recursive acronym for "YAML Ain't Markup Language")
is a human-readable data-serialization language. It is commonly used for
configuration files and in applications where data is being stored or
transmitted. YAML targets many of the same communications applications
as Extensible Markup Language (XML) but has a minimal syntax which
intentionally differs from SGML. It uses both Python-style
indentation to indicate nesting, and a more compact format that uses
[...] for lists and {...} for maps making YAML 1.2 a superset of
JSON.
#+end_quote

This section configures basic support for working with YAML files and
associates

#+begin_src emacs-lisp
(use-package yaml-mode
  :mode (("\\.yml$" . yaml-mode)
         ("\\.yaml$" . yaml-mode))
  :ensure)
#+end_src

** Line length (column count)
:PROPERTIES:
:CUSTOM_ID: h:C0C927DF-EF91-428C-81C1-D07846CABBA3
:END:

The column count is set to 72. The standard line length is 80
characters, so having it at something less allows for such things as
quoting plain text, indenting, etc. =git= commit messages also make good
use of this method. The column count is used by =auto-fill-mode= and
similar tools (or when manually invoking text formatting with
=fill-paragraph= or equivalent---normally bound to =M-q=).

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default fill-column 72)
  :hook (after-init-hook . column-number-mode))
#+end_src

** Paragraphs and fill-mode
:PROPERTIES:
:CUSTOM_ID: h:FD38C107-0C54-4685-ADD2-7692C360EC9A
:END:

Let us first configure how paragraphs should be treated. These settings
are configured to be most compatible with collaborative documents. Since
most folks are not writing in monospaced font faces, they tend to use
only a single space after a =.= character to end their sentences. Setting
=sentence-end-double-space= to nil is intended to accommodate that
preference.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq sentence-end-double-space nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq sentence-end-without-period nil))
#+end_src

Now we need to make sure we run the minor mode that keeps paragraphs
within the column [[#h:C0C927DF-EF91-428C-81C1-D07846CABBA3][limit I prefer]]: you can always do it manually for the
current paragraph or the active region with =fill-paragraph=, bound by
default to =M-q=.

By targeting =text-mode= we also affect every major mode derived from it,
which means that we correctly do not get this utility in
programming-related modes (in principle, those come from =prog-mode=).
The adaptive mode improves the handling of things like bulleted and
numbered lists, where it recognizes the text's prefix and tries to align
to it rather than the absolute beginning of the line.

#+begin_src emacs-lisp
(use-package emacs
  :diminish auto-fill-function
  :config
  (setq adaptive-fill-mode t)

  (defun indiebrain/unfill-region-or-paragraph (&optional region)
    "Unfill paragraph or, when active, the region.
Join all lines in a region, if active, while respecting any empty
lines (so multiple paragraphs are not joined, just unfilled). If
no region is active, operate on the paragraph. The idea is to
produce the opposite effect of both `fill-paragraph' and
`fill-region'."
    (interactive)
    (let ((fill-column most-positive-fixnum))
      (if (use-region-p)
          (fill-region (region-beginning) (region-end))
        (fill-paragraph nil region))))

  :hook (text-mode-hook . (lambda ()
                            (turn-on-auto-fill)))
  :bind ("M-Q" . indiebrain/unfill-region-or-paragraph))
#+end_src

** Recognize subwords
:PROPERTIES:
:CUSTOM_ID: h:547D9EA7-51C5-4796-8752-39DEED4E966A
:END:

The =subword-mode= documentation (=C-h f subword-mode=)is informative and
extensive. This alters the way Emacs understands word boundaries. So,
/camelCaseWords/ are exposed as their constituents rather than one long
word, meaning that motions will behave accordingly.

#+begin_src emacs-lisp
(use-package subword
  :diminish
  :hook (prog-mode-hook . subword-mode))
#+end_src

** Comment lines, regions, boxes, etc
:PROPERTIES:
:CUSTOM_ID: h:EDBCBE3C-16C7-4967-8106-74BE9DE62453
:END:

Just some basic configurations for commenting structured text. This is
mostly a placeholder for potentially more targeted and detailed settings
that would involve per-mode hooks.

The purpose of my reviewed key bindings is to make them more consistent.
Helps with mnemonics. They also are more ergonomic. To this end, I
have the following:

- The standard commenting function is now bound to the simple =C-;=.
  This runs a "do what I meant" function I have defined, whose detailed
  documentation can be read below.
- =C-:= (=C-S-;=) will kill the comment on the current line. This is
  particularly helpful when the comment follows text you would like to
  keep. The operation can be performed regardless of where the point is
  on the line. *Some modes disable this behavior* (e.g. trying it on
  source code inside of org-mode—for those cases, focus the block with
  =C-c '=).
- The =M-;= will just append a comment to the line, rather than the
  default =comment-dwim=.

Note that =C-;= is occupied by some =flyspell= command that I have no
use for (disabled in the relevant package declaration).

Lastly, use =M-j= (alias =C-M-j=) when you want to continue an existing
comment on a new line with respect for the current indentation. If you
are not inside of a comment, this will just create an indentation-aware
new line.

#+begin_src emacs-lisp
(use-package newcomment
  :config
  (setq comment-empty-lines t)
  (setq comment-fill-column nil)
  (setq comment-multi-line t)
  (setq comment-style 'multi-line)

  (defun indiebrain/comment-dwim (&optional arg)
    "Alternative to `comment-dwim': offers a simple wrapper
around `comment-line' and `comment-dwim'.

If the region is active, then toggle the comment status of the
region or, if the major mode defines as much, of all the lines
implied by the region boundaries.

Else toggle the comment status of the line at point."
    (interactive "*P")
    (if (use-region-p)
        (comment-dwim arg)
      (save-excursion
        (comment-line arg))))

  :bind (("C-;" . indiebrain/comment-dwim)
         ("C-:" . comment-kill)
         ("M-;" . comment-indent)
         ("C-x C-;" . comment-box)))
#+end_src

** Configure 'electric' behavior
:PROPERTIES:
:CUSTOM_ID: h:6A355747-FED5-44FB-955A-A4D32FBC39A0
:END:

Emacs labels as "electric" any behavior that involves contextual
auto-insertion of characters. This is a summary of my settings:

- Indent automatically.
- If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs. Only do so if there is no alphabetic
  character after the cursor.
- The cryptic numbers in the pairs set, correspond to curly single and
  double quotes and these =«»=. The contents of this set are always
  inserted in pairs, regardless of major mode.
  + To get those numbers, evaluate =(string-to-char CHAR)= where CHAR is
    the one you are interested in. For example, get the literal tab's
    character with =(string-to-char "\t")=.
- While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one. So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
- Do not skip over whitespace when operating on pairs. Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over. I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
- The whitespace characters are space (=\s=), tab (=\t=), and newline (=\n=).
- The rest concern the conditions for transforming quotes into their
  curly equivalents. I keep this disabled, because curly quotes are
  distinct characters. It is difficult to search for them. Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.

#+begin_src emacs-lisp
(use-package electric
  :config
  (setq electric-pair-inhibit-predicate'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars
        '(9
          10
          32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  :hook (after-init-hook . (lambda ()
                             (electric-indent-mode 1)
                             (electric-pair-mode -1)
                             (electric-quote-mode -1))))
#+end_src

** Parentheses (show-parens-mode)
:PROPERTIES:
:CUSTOM_ID: h:FC008164-5230-4660-BC3C-CF76327B3431
:END:

Configure the mode that highlights matching delimiters or parentheses.

Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing. It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=. The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity. This means the beginning or end of
  the line, with space in between.
- Do not highlight a match when the point is on the inside of the
  parenthesis.

#+begin_src emacs-lisp
(use-package paren
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  :hook (after-init-hook . show-paren-mode))
#+end_src

** Tabs, indentation, and the TAB key
:PROPERTIES:
:CUSTOM_ID: h:3E30D7B6-0044-4F4D-B9D4-62A599CEA964
:END:

Emacs tends to perform alignments by mixing tabs with spaces, which /can
lead to misalignments/ depending on certain variables such as the size of
the tab. As such, I am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customize them via hooks.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq-default tab-always-indent 'complete)
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil))
#+end_src

** Spell checking (flyspell)
:PROPERTIES:
:CUSTOM_ID: h:DB14B9F0-C8CA-4841-A295-62C7A673620D
:END:

The =flyspell= package enables in-buffer spell checking and correction. It
relies on the external GNU =aspell= program to perform the spell checking
and provide correction support. The below configuration sets up the
default dictionary to use "American English" and enables automatic spell
checking when editing prose.

#+begin_src emacs-lisp
(use-package flyspell
  :config
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-program-name "aspell")
  (setq ispell-dictionary "en_US")

  :bind (:map flyspell-mode-map
              ("C-;" . nil))
  :hook (text-mode-hook . (lambda ()
                            (flyspell-mode))))
#+end_src

** Grammar checking (artbollocks)

[[https://github.com/sachac/artbollocks-mode/blob/master/artbollocks-mode.el][artbollocks-mode]] helps avoid cliches and poor grammar when writing
prose. It does NOT employ any fancy Natural Language processing expert
systems and requires no external libraries. Its internals are a set of
regular expressions designed to detect:

- Lexical Illustions :: When a word appears next to itself, but the
  human brain omits it from the read content. Example: Paris in the *the*
  spring.
- Passive voice :: When the object of a sentence acts on the sentence's
  subject. Example: The road was crossed by the chicken.
- Weasel Words / Phrases :: Filler words or expressions. The tend to
  sound technically relevant, but convey nothing to the reader.
  Examples: very, remarkably, few, there are a number of.
- Jargon :: Obscure and often pretentious language marked by
  circumlocutions and long words.

=artbollocks-mode= intends to help improve writing about art, yet it is
generally useful enough for most types of writing. Jargon tends to be
topical; this make the jargon check a bit odd at times. One may consider
customizing the =artbollocks-mode= package to better suit the type of
writing performed - overriding the regular expression
=artbollocks-jargon-regex= or event disabling the jargon checker via
=artbollocks-jargon=.

#+begin_src emacs-lisp
(use-package artbollocks-mode
  :ensure
  :hook (text-mode-hook . (lambda ()
                            (artbollocks-mode)))
  :config
  (setq artbollocks-jargon nil))
#+end_src

** Linters
:PROPERTIES:
:CUSTOM_ID: h:42BE413C-9A59-4ED2-A614-D3F3E500CF05
:END:

The Flycheck package is similar to the built-in =flymake= package, however
it comes with many more language-specific backends and is extensible for
use with external linting tools.

#+begin_src emacs-lisp
(use-package flycheck
  :ensure)
#+end_src

** Emacs live documentation (eldoc)
:PROPERTIES:
:CUSTOM_ID: h:FB1827C2-73D7-4977-9C46-58FE5F89B7F8
:END:

When editing elisp, this mode will display useful information about the
construct at point in the echo area. For functions it will display the
list of arguments they accept. While it will show the first
sentence of a variable's documentation string.

#+begin_src emacs-lisp
(use-package eldoc
  :diminish
  :config
  (global-eldoc-mode 1))
#+end_src

* History and state
:PROPERTIES:
:CUSTOM_ID: h:66B0BE0D-DBB4-4816-A074-D0BA03F2416E
:END:
** Emacs server and desktop
:PROPERTIES:
:CUSTOM_ID: h:fed47a29-eb36-4154-b2ec-4491fc3a9443
:END:

The following uses the first /running/ process of Emacs as the one others
may connect to. This means that calling =emacsclient= (with or without
=--create-frame=), will share the same buffer list and data as the
original running process, aka "the server". The server persists for as
long as there is an Emacs frame attached to it.

#+begin_src emacs-lisp
(use-package server
  :hook (after-init-hook . server-start))
#+end_src

And here we make sure that Emacs starts in the =*scratch*= buffer, no
matter what.

#+begin_src emacs-lisp
(use-package emacs
  :init
  (setq initial-buffer-choice t)
  (setq inhibit-startup-echo-area-message "max") ; read the docstring
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-buffer-menu t))
#+end_src

** Record various types of history
:PROPERTIES:
:CUSTOM_ID: h:2AF3BD7F-9E52-42D7-8E81-D6017E027C4E
:END:

This is a built-in minor mode that keeps track of the files you have
opened, allowing you revisit them faster. Its true power consists in
the fact that its data, maintained in =recentf-list=, is a simple
variable. This means that we can access it through any relevant piece
of elisp functionality.

To that end, the functions I define herein are meant to either control
the contents of the list or allow me to access them through my
completion framework or a dedicated file listing.

Note that there exists a built-in =recentf-open-files= function for
accessing the recent files through a bespoke buffer. I find that I have
no use for it.

#+begin_src emacs-lisp
(use-package recentf
  :config
  (setq recentf-save-file "~/.emacs.d/recentf")
  (setq recentf-max-saved-items 200)
  (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))

  (defun indiebrain/recentf-keep-predicate (file)
    "Additional conditions for saving in `recentf-list'.
Add this function to `recentf-keep'.

NEEDS REVIEW."
    (cond
     ((file-directory-p file) (file-readable-p file))))
  (add-to-list 'recentf-keep 'indiebrain/recentf-keep-default-predicate)

  (defun indiebrain/recentf (&optional input)
    "Select item from `recentf-list' using completion.
Use INPUT as an initial, yet editable, filter.

The user's $HOME directory is abbreviated as a tilde."
    (interactive)
    (let* ((files (mapcar 'abbreviate-file-name recentf-list))
           (f (completing-read "Open recentf entry: " files nil t
                               (when input input))))
      (find-file f)))

  (defun indiebrain/recentf-dirs (&optional arg)
    "Select directory from `recentf-list' using completion.
With \\[universal-argument] present the list in a `dired' buffer.
This buffer is meant to be reused by subsequent invocations of
this command (otherwise you need to remove the `when' expression.

Without \\[universal-argument], the user's $HOME directory is
abbreviated as a tilde.  In the Dired buffer paths are absolute."
    (interactive "P")
    (let* ((list (mapcar 'abbreviate-file-name recentf-list))
           (dirs (delete-dups
                  (mapcar (lambda (file)
                            (if (file-directory-p file)
                                (directory-file-name file)
                              (substring (file-name-directory file) 0 -1)))
                          list)))
           (buf "*Recentf Dired*")
           (default-directory "~"))
      (when (get-buffer buf)
        (kill-buffer buf))
      (if arg
          (dired (cons (generate-new-buffer-name buf) dirs))
        (find-file
         (completing-read "Recent dirs: " dirs nil t)))))

  :hook (after-init-hook . recentf-mode)
  :bind (("s-r" . indiebrain/recentf)
         ("C-x C-r" . indiebrain/recentf-dirs)))
#+end_src

*** Minibuffer history (savehist-mode)
:PROPERTIES:
:CUSTOM_ID: h:5E6FFCFA-74BC-47A6-9799-CEBEDA82AFB9
:END:

Keeps a record of interactions with the minibuffer. Emacs will remember
your input and choices and will surface the desired results towards the
top as the most likely candidates.

#+begin_src emacs-lisp
(use-package savehist
  :config
  (setq savehist-file "~/.emacs.d/savehist")
  (setq history-length 1000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  :hook (after-init-hook . savehist-mode))
#+end_src

*** Record cursor position
:PROPERTIES:
:CUSTOM_ID: h:19651D0F-6F2F-4FB6-BFE9-63832DDF90AC
:END:

Just remember where the point is in any given file. This can often be a
subtle reminder of what you were doing the last time you visited that
file, allowing you to pick up from there.

#+begin_src emacs-lisp
(use-package saveplace
  :config
  (setq save-place-file "~/.emacs.d/saveplace")
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
#+end_src

*** Backups
:PROPERTIES:
:CUSTOM_ID: h:333576D9-A2A7-4B4C-ABEB-F5A65ECD0464
:END:

And here are some settings pertaining to backups. I rarely need those,
but I prefer to be safe in the knowledge that if something goes awry
there is something to fall back to.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq backup-directory-alist
        '(("." . "~/.emacs.d/backup/")))
  (setq backup-by-copying t)
  (setq version-control t)
  (setq delete-old-versions t)
  (setq kept-new-versions 6)
  (setq kept-old-versions 2)
  (setq create-lockfiles nil)
  (setq tramp-backup-directory-alist backup-directory-alist))
#+end_src
