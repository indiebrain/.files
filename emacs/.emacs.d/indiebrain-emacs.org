#+TITLE: GNU Emacs package configuration file
#+AUTHOR: Aaron Kuehler
#+EMAIL: aaron.kuehler+public@gmail.com
#+OPTIONS: toc:nil
#+STARTUP: content
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))
#+MACRO: emacs-development-version (eval (substring (emacs-version) 0 17))

+ Created: 2020-11-26
+ Updated: *{{{export-date}}}*.
+ Emacs Version: {{{emacs-development-version}}}.
+ File history:
  [[https://github.com/indiebrain/.files/commits/master/emacs/.emacs.d/indiebrain-emacs.org][<https://github.com/indiebrain/.files/commits/master/emacs/.emacs.d/indiebrian-emacs.org]].

#+TOC: headlines 8 insert TOC here, with eight headline levels

* Overview
:PROPERTIES:
:CUSTOM_ID: h:feb4358b-68f8-40fd-88f0-142ef22d0c11
:END:
** Canonical links to this document
:PROPERTIES:
:CUSTOM_ID: h:134904bf-3f3a-43a9-8be0-17dab61b76d6
:END:

- Git Repo :: https://github.com/indiebrain/.files/

** What is this?
:PROPERTIES:
:CUSTOM_ID: h:330004be-9269-41e0-bd2a-2a897c0c1bd4
:END:

This document, refered to in the source code as =indiebrain-emacs.org=,
contains the build of my GNU Emacs configuration. It is designed using
[[https://en.wikipedia.org/wiki/Literate_programming][Donald Knuth's concept of "Literate Programming"]]; a combination of prose
intended to add context for human readers and inline code blocks used
for execution by a computer. Literate programming allows us to take an
expressive and deliberate approach to generating code and documentation.
Emacs' =org-babel= mode enables the parsing of this document such that the
=emacs-lisp= code blocks contained herein constitute the majority of
configuration used to nudge a vanilla Emacs process into a shape I find
useful. The rest of the content is for humans - and any other machine
capable of extracting meaning from the natural language contextual
clues - to better understand the purpose and rationale behind including
the surrounding bits of configuration.

Each section contains a - hopefully - deeply contextual discussion of
the code contained therein. I welcome feedback if something seems
misrepresented, incomplete, or unclear. Please submit a ticket on the
repository itself describing the section in question, a quotation of the
prose in question, and a suggestion of what you expected in its stead.

In more practical terms, this is just an =org-mode= document. It contains
code blocks which represent all /package configurations/ for my Emacs
setup. To generate the proper Emacs lisp configuration code, the =init.el=
contains just be bare essentials to extract the code blocks contained
herein.

This document, and style of executable documentaion, draws from an array
of sources. Some inspirations warrant specific attention as their study
would better inform the reader to the mindset assumed by the author. The
[[https://www.gnu.org/software/emacs/manual/][GNU Emacs Manuals]], Protesilaos Stavrou's [[https://protesilaos.com/codelog/2019-12-20-vlog-switch-emacs/]["All about switching to Emacs"]],
and [[https://www.masteringemacs.org/][Mickey Petersen's "Mastering Emacs"]] serve as the foundation of
technical foundation and inspiration to use Emacs in the first place.
The kernel of inspiration belongs to the [[https://www.youtube.com/watch?v%3DSzA2YODtgK4][talk]] delivered by Harry R.
Schwartz entitled "Getting started with Org mode". The form of this
document is critically influenced by the vast, and excellent work of
[[https://protesilaos.com][Protesilaos Stavrou]]. My gratitude to ALL of those whose work influences
this document.

** Initialization
:PROPERTIES:
:CUSTOM_ID: h:4f872bdd-4cc9-41ef-b01d-57a9705ec6e5
:END:

*** Main macros and other contents of my =init.el= (for Emacs 28)
:PROPERTIES:
:CUSTOM_ID: h:f919d17d-7326-4c43-8df2-4b5c3ea981a5
:END:

The =indiebrain-emacs.org= is loaded from an other file, named =init.el= per the
Emacs conventions. Mine includes some helper macros for package
configuration and is otherwise designed to initialise the package lists
and load the file with my configurations (i.e. the present document).

*Those macros are integral parts of my setup*, as they control the
configuration of all packages declared herein. In particular:

- =indiebrain-emacs-builtin-package= is used for libraries that are either
  shipped with Emacs or are part of my dotfiles' directory. The latter
  class consists of all those =indiebrain-*.el= files, as well as a few others.
  What this macro does is to =require= the given feature and then evaluate
  all of its forms (variables, key bindings, hooks, etc.).

- =indiebrain-emacs-elpa-package= controls packages installed from some
  Emacs Lisp Package Archive, like MELPA or GNU ELPA. This macro will
  load the package if it is already installed and then evaluate all of
  its forms. If the package is not installed, it will produce a warning
  telling the user that all the uninstalled-yet-declared packages can be
  downloaded in one go with the command =indiebrain-emacs-install-ensured=
  (though read further below about auto-installing packages).

- =indiebrain-emacs-manual-package= handles packages installed manually
  via their Git repository. Each of those repos must be inside
  =(locate-user-emacs-file "contrib-lisp")= (typically available at
  =~/.emacs.d/contrib-lisp=). The macro will load the package normally and
  configure it accordingly if it exists at the desired path, else it
  will log a warning about what file path it expects to read. In
  concrete terms, if you want =package-A= you must first place all of its
  files at =~/.emacs.d/contrib-lisp/package-A=.

*I must stress that no package is automatically installed by default:* the
user is expected to do so on their own either by calling a command or by
providing their explicit consent to the auto-installation of packages
from Emacs Lisp Package Archives. The idea is to avoid the malpractice
of installing software without asking the user to opt in to such a deal.
To actually instruct my declared packages to be installed automatically,
a user must create a new file called =basic-init.el=, place it in the same
directory as my =init.el= and =indiebrain-emacs.org= and include in it this form:
=(setq indiebrain-emacs-autoinstall-elpa t)=.

#+include: init.el src emacs-lisp :tangle no

The =init.el= (reproduced further below) also sets some variables to their
desired values and provides a couple of functions that control the start
and end phases of my Emacs sessions.

- =indiebrain-emacs-build-config= is the final function from my part that runs
  before terminating the running Emacs process. It regenerates my
  configurations and byte compiles the output. This speeds things up
  the next time I launch Emacs, while it also ensures that I am always
  running the latest version of my setup.

- =indiebrain-emacs-load-config= will either load the output of the
  aforementioned function or, if that is not available, parse the
  literate program that holds my code (this Org file if you are viewing
  the source code or the document that produces the HTML of this web
  page). Either way, it load my configurations.

#+include: init.el src emacs-lisp :tangle no

*** "Early Init" for Emacs 27+
:PROPERTIES:
:CUSTOM_ID: h:e131b8a0-4ef4-471b-aca5-47623e482802
:END:

Starting with Emacs 27.1, requires an =early-init.el= to control things
with greater precision. My code is as follows:

#+include: early-init.el src emacs-lisp :tangle no

** About the source code version of this document
:PROPERTIES:
:CUSTOM_ID: h:2172c967-89a4-474b-9435-98c3cd6b47ac
:END:

In the =org-mode= version of this document, I make sure that the
above-referenced code blocks are not declared as an =emacs-lisp= source
but rather as mere examples, so they are not accidentally parsed by the
actual setup.

Actual code blocks are wrapped between =#+begin_src= and =#+end_src= tags
(not visible in the website version of this page). For Emacs 27.1, such
templates can be quickly inserted with =C-c C-,= (this works both for
empty blocks and active regions).

As for the settings included herein, you can learn /even more/ about them
by using Emacs' built-in documentation facilities (also read my note on
[[#h:425FEDB1-05B5-4D89-81CC-222C5ADA1986][How do you learn Emacs?]]).

Additionally, you will notice some metadata tags specific to =org-mode=
below each heading. These are generated by the functions that are
defined in the package configurations for Org mode. The idea is to keep
anchor tags consistent when generating a new HTML version of this
document.

This metadata also makes it possible to create immutable internal links,
whenever a reference is needed. To create such links, you can use =C-c l=
to capture the unique ID of the current section and then =C-c C-l= to
create a link.

** COPYING
:PROPERTIES:
:CUSTOM_ID: h:1b9e6455-ba10-4683-88d4-738ecc41cdf6
:END:

Copyright (c) 2012-2020 Aaron Kuehler

This file is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this file. If not, see <http://www.gnu.org/licenses/>.

* Base settings
:PROPERTIES:
:CUSTOM_ID: h:cfc86036-2629-41df-868c-f3e4e105976c
:END:

This section contains tweaks to default configuration required prior to
the configuration of everything else.

** Exposing =$PATH= to Emacs on MacOS hosts
:PROPERTIES:
:CUSTOM_ID: h:9568f5a7-cb99-441c-b904-01f7a31a3464
:END:

When Emacs runs on a MacOS host, the user's =$PATH= is not accessible to
the Emacs process. This is problematic when Emacs attempts to use
external programs to support its functions - =ispell= as a back end for
Flyspell for example. =exec-path-from-shell= allows configuration of the
=$PATH= the Emacs process will use when attempting to lookup
programs. This is only executed if Emacs can detect that it is running
on a MacOS host.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'exec-path-from-shell
  (when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize)
  (setq exec-path (cons "/opt/local/bin" exec-path))
  (setenv "PATH" (concat "/opt/local/bin:" (getenv "PATH")))))
#+end_src

** Common auxiliary functions (indiebrain-common.el)
:PROPERTIES:
:CUSTOM_ID: h:157F0024-DD4A-4419-9AE6-980122752FEC
:END:

There are a few utilities that I keep re-using in various parts of my
Emacs code base. To keep things modular, I place them all in a dedicated
=indiebrain-common.el= file, which can then be marked as a dependency by
other libraries of mine. As such, all we do here is load the file.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-common)
#+end_src

And here is =indiebrain-common.el= in its totality. It is available as a file
in [[https://github.com/indiebrain/.files][my dotfiles' repo]] (same for all my Emacs libraries):

#+include: indiebrain-lisp/indiebrain-common.el src emacs-lisp :tangle no

** Common custom functions (indiebrain-simple.el)
:PROPERTIES:
:CUSTOM_ID: h:0908107A-9CDA-4C20-B797-1FAA17F1880F
:END:

=indiebrain-simple.el= contains a wide range of commands that are broadly in
line with the built-in =simple.el= and =lisp.el= libraries. While I could
offer an overview of each item in my library, I feel the code and
concomitant documentation strings are clear enough for you to peruse the
source directly (reproduced further below).

Given that this is a foundational piece of my Emacs setup, it is the
appropriate place to re-bind or free up some common key combinations

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-simple
  (setq indiebrain-simple-insert-pair-alist
    '(("' Single quote"        . (39 39))     ; ' '
      ("\" Double quotes"      . (34 34))     ; " "
      ("` Elisp quote"         . (96 39))     ; ` '
      ("‘ Single apostrophe"   . (8216 8217)) ; ‘ ’
      ("“ Double apostrophes"  . (8220 8221)) ; “ ”
      ("( Parentheses"         . (40 41))     ; ( )
      ("{ Curly brackets"      . (123 125))   ; { }
      ("[ Square brackets"     . (91 93))     ; [ ]
      ("< Angled brackets"     . (60 62))     ; < >
      ("« Εισαγωγικά Gr quote" . (171 187))   ; « »
      ("= Equals signs"        . (61 61))     ; = =
      ("~ Tilde"               . (126 126))   ; ~ ~
      ("* Asterisks"           . (42 42))     ; * *
      ("_ underscores"         . (95 95))))   ; _ _
  (setq indiebrain-simple-date-specifier "%F")
  (setq indiebrain-simple-time-specifier "%R %z")
  (setq delete-pair-blink-delay 0.15) ; Emacs28 -- see `indiebrain-simple-delete-pair-dwim'

  ;; General commands
  (let ((map global-map))
    (define-key map (kbd "<insert>") nil)
    (define-key map (kbd "C-z") nil)
    (define-key map (kbd "C-x C-z") nil)
    (define-key map (kbd "C-h h") nil)
    (define-key map (kbd "M-`") nil)
    (define-key map (kbd "s-h") #'indiebrain-simple-describe-symbol)
    (define-key map (kbd "C-h K") #'describe-keymap) ; overrides `Info-goto-emacs-key-command-node'
    ;; Commands for lines
    (define-key map (kbd "C-S-w") #'indiebrain-simple-copy-line-or-region)
    (define-key map (kbd "C-S-y") #'indiebrain-simple-yank-replace-line-or-region)
    (define-key map (kbd "M-SPC") #'cycle-spacing)
    (define-key map (kbd "M-o") #'delete-blank-lines)   ; alias for C-x C-o
    (define-key map (kbd "M-k") #'indiebrain-simple-kill-line-backward)
    (define-key map (kbd "C-S-n") #'indiebrain-simple-multi-line-next)
    (define-key map (kbd "C-S-p") #'indiebrain-simple-multi-line-prev)
    (define-key map (kbd "<C-return>") #'indiebrain-simple-new-line-below)
    (define-key map (kbd "<C-S-return>") #'indiebrain-simple-new-line-above)
    ;; Commands for text insertion or manipulation
    (define-key map (kbd "C-=") #'indiebrain-simple-insert-date)
    (define-key map (kbd "C-<") #'indiebrain-simple-escape-url)
    (define-key map (kbd "C-'") #'indiebrain-simple-insert-pair-completion)
    (define-key map (kbd "M-'") #'indiebrain-simple-insert-pair-completion)
    (define-key map (kbd "M-\\") #'indiebrain-simple-delete-pair-dwim)
    (define-key map (kbd "C-M-;") #'indiebrain-simple-cite-region)
    (define-key map (kbd "C-M-^") #'indiebrain-simple-insert-undercaret)
    (define-key map (kbd "<C-M-backspace>") #'backward-kill-sexp)
    (define-key map (kbd "M-c") #'capitalize-dwim)
    (define-key map (kbd "M-l") #'downcase-dwim)        ; "lower" case
    (define-key map (kbd "M-u") #'upcase-dwim)
    ;; Commands for object transposition
    (define-key map (kbd "C-t") #'indiebrain-simple-transpose-chars)
    (define-key map (kbd "C-x C-t") #'indiebrain-simple-transpose-lines)
    (define-key map (kbd "C-S-t") #'indiebrain-simple-transpose-paragraphs)
    (define-key map (kbd "C-x M-t") #'indiebrain-simple-transpose-sentences)
    (define-key map (kbd "C-M-t") #'indiebrain-simple-transpose-sexps)
    (define-key map (kbd "M-t") #'indiebrain-simple-transpose-words)
    ;; Commands for marking objects
    (define-key map (kbd "M-@") #'indiebrain-simple-mark-word)       ; replaces `mark-word'
    (define-key map (kbd "C-M-SPC") #'indiebrain-simple-mark-construct-dwim)
    (define-key map (kbd "C-M-d") #'indiebrain-simple-downward-list)
    ;; Commands for paragraphs
    (define-key map (kbd "M-Q") #'indiebrain-simple-unfill-region-or-paragraph)
    ;; Commands for windows
    (define-key map (kbd "s-m") #'indiebrain-simple-monocle)
    ;; Commands for buffers
    (define-key map (kbd "M-=") #'count-words)
    (define-key map (kbd "<C-f2>") #'indiebrain-simple-rename-file-and-buffer)
    (define-key map (kbd "s-k") #'indiebrain-simple-kill-buffer-current)))
#+end_src

These are the contents of the =indiebrain-simple.el= library (find the file in
[[https://github.com/indiebrain/.files][my dotfiles' repo]] (as with all my Elisp code)):

#+include: indiebrain-lisp/indiebrain-simple.el src emacs-lisp :tangle no

** indiebrain-pulse.el (highlight cursor position)
:PROPERTIES:
:CUSTOM_ID: h:F97AC431-302D-4F96-9123-4D11319988E6
:END:

=pulse.el= is a library that provides utilities for highlighting the
region or area around point. It is meant to be used by other packages
as a means of offering visual feedback, as is the case with, for
example, =M-.= (=xref-find-definitions=).

While =indiebrain-pulse.el= (complete code further below) is a thin wrapper that
provides some extensions that are useful to my workflow. Specifically,
it declares a new face and defines a command that implements it:
=indiebrain-pulse-pulse-line=. This is useful to quickly highlight the line and
buffer I am on, but can also be utilised by other tools that move the
point an arbitrary distance.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-pulse
  (setq indiebrain-pulse-pulse-command-list
    '(recenter-top-bottom
      reposition-window
      bookmark-jump
      other-window))
  (indiebrain-pulse-advice-commands-mode 1)
  (define-key global-map (kbd "<s-escape>") #'indiebrain-pulse-pulse-line))
#+end_src

This is the code for =indiebrain-pulse.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]], in case
you wish to get the file):

#+include: indiebrain-lisp/indiebrain-pulse.el src emacs-lisp :tangle no

** Put customisation settings in a disposable "custom.el"
:PROPERTIES:
:CUSTOM_ID: h:853316B9-5FD4-480D-9601-7AE68EED4C13
:END:

When you install a package or use the customization interfaces to tweak
things to your liking, Emacs will append a piece of Elisp to your init
file. In my experience, this is a common source of inconsistencies,
arising from a conflict between the user's code and what is stored in
that =custom= snippet.

As it does not seem possible to outright disable this behavior, I
instruct Emacs to place all "custom" code in a temporary file that
never gets loaded. This feels kinda hacky but is better than having
some arbitrary code that you accidentally evaluated from messing up
with your carefully designed (and version-controlled) configuration.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'cus-edit
  ;; Disable the damn thing
  (setq custom-file (make-temp-file "emacs-custom-")))
#+end_src

** Load the color-theme (modus-themes)
:PROPERTIES:
:CUSTOM_ID: h:e8c1d68e-aebf-499c-b394-807fbd525624
:END:

Emacs version 28 incorporated the wonderfully complete [[https://protesilaos.com/modus-themes/]["Modus" themes by
Protesilaos Stravrou]].

The Modus themes optimize for accessible readability. They conform with
the highest standard for colour contrast between foreground and
background values. This stands for a minimum contrast ratio of 7:1, also
known as the WCAG AAA standard (the highest of its kind).

The themes are "Modus Operandi" (light) and "Modus Vivendi" (dark). The
source code is available [[https://gitlab.com/protesilaos/modus-themes][on their GitLab page]] while you can read the
HTML version of [[https://protesilaos.com/modus-themes][their manual on their website]]. If you have the package
installed or are using Emacs >=28, you can read the manual from the
built-in Info reader. Evaluate: =(info "(modus-themes) Top")=.

The manual covers everything from the basics to more advanced,
"do-it-yourself" cases.

The list of supported packages is comprehensive and a lot of work goes
into getting the details right. Plus, there are *lots of customization
options* to tweak the looks of the themes (note though that the values I
set for those variables in the following code block are not indicative
of my preferences, as I always try different combinations to test
things).

Lastly, if you are curious about the underlying methodology, read the
essay [[https://protesilaos.com/codelog/2020-03-17-design-modus-themes-emacs/][on the design of the Modus themes]] (2020-03-17). And here are some
more resources from Protesilaos' website for those who are really into
the minutia and wish to get a glimpse of how much work goes into this
project:

+ [[https://protesilaos.com/codelog/2020-05-10-modus-operandi-palette-review/][Modus Operandi theme subtle palette review]] (2020-05-10)
+ [[https://protesilaos.com/codelog/2020-06-13-modus-vivendi-palette-review/][Modus Vivendi theme subtle palette review]] (2020-06-13)
+ [[https://protesilaos.com/codelog/2020-07-04-modus-themes-faint-colours/][Modus themes: new "faint syntax" option]] (2020-07-04)
+ [[https://protesilaos.com/codelog/2020-07-08-modus-themes-nuanced-colours/][Modus themes: major review of "nuanced" colours]] (2020-07-08)
+ [[https://protesilaos.com/codelog/2020-08-09-modus-themes-paren-match/][Modus themes: review "paren-match" colours]] (2020-08-09)
+ [[https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/][Notes for aspiring Emacs theme developers]] (2020-08-28)
+ [[https://protesilaos.com/codelog/2020-09-14-modus-themes-review-blues/][Modus themes: report on the review of the main blue colours]] (2020-09-14)
+ [[https://protesilaos.com/codelog/2020-12-27-modus-themes-review-rainbow-delimiters/][Modus themes: review rainbow-delimiters faces]] (2020-12-27)
+ [[https://protesilaos.com/codelog/2021-01-11-modus-themes-review-select-faint-colours/][Modus themes: review of select "faint" colours]] (2021-01-11)
+ [[https://protesilaos.com/codelog/2021-02-25-modus-themes-diffs-deuteranopia/][The Modus themes now cover deuteranopia in diffs]] (2021-02-25)
+ [[https://protesilaos.com/codelog/2021-05-19-modus-themes-status-update/][Status update on the Modus themes for Emacs]] (2021-05-19)

And if you do enjoy reading such entries, then you may also wish to
check the [[https://protesilaos.com/modus-themes-changelog/][Change Log of the Modus themes]].

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'modus-themes
  ;; Add all your customizations prior to loading the themes
  ;;
  ;; NOTE: these are not my preferences!  I am always testing various
  ;; configurations. Though I still like what I have here.
  (setq modus-themes-operandi-color-overrides
        '((bg-main . "#f9f5d7")))

  (setq modus-themes-vivendi-color-overrides
        '((bg-main . "#1d2021")))

  (setq modus-themes-slanted-constructs nil
    modus-themes-bold-constructs nil
    modus-themes-no-mixed-fonts nil
    modus-themes-subtle-line-numbers t
    modus-themes-success-deuteranopia t
    modus-themes-inhibit-reload nil ; only applies to `customize-set-variable' and related

    modus-themes-fringes nil ; {nil,'subtle,'intense}

    ;; Options for `modus-themes-lang-checkers': nil,
    ;; 'straight-underline, 'subtle-foreground,
    ;; 'subtle-foreground-straight-underline, 'intense-foreground,
    ;; 'intense-foreground-straight-underline, 'colored-background
    modus-themes-lang-checkers nil

    ;; Options for `modus-themes-mode-line': nil, '3d, 'moody,
    ;; 'borderless, 'borderless-3d, 'borderless-moody, 'accented,
    ;; 'accented-3d, 'accented-moody, 'borderless-accented,
    ;; 'borderless-accented-3d, 'borderless-accented-moody
    modus-themes-mode-line 'accented-moody

    ;; Options for `modus-themes-syntax': nil, 'faint,
    ;; 'yellow-comments, 'green-strings,
    ;; 'yellow-comments-green-strings, 'alt-syntax,
    ;; 'alt-syntax-yellow-comments, 'faint-yellow-comments
    modus-themes-syntax nil

    ;; Options for `modus-themes-hl-line': nil, 'intense-background,
    ;; 'accented-background, 'underline-neutral,
    ;; 'underline-accented, 'underline-only-neutral,
    ;; 'underline-only-accented
    modus-themes-hl-line 'accented-background

    modus-themes-paren-match 'intense ; {nil,'subtle-bold,'intense,'intense-bold}

    ;; Options for `modus-themes-links': nil, 'faint,
    ;; 'neutral-underline, 'faint-neutral-underline, 'no-underline,
    ;; 'underline-only, 'neutral-underline-only
    modus-themes-links 'neutral-underline

    ;; Options for `modus-themes-prompts': nil, 'subtle-accented,
    ;; 'intense-accented, 'subtle-gray, 'intense-gray
    modus-themes-prompts nil

    modus-themes-completions nil ; {nil,'moderate,'opinionated}

    modus-themes-mail-citations 'faint ; {nil,'faint,'monochrome}

    ;; Options for `modus-themes-region': nil, 'no-extend, 'bg-only,
    ;; 'bg-only-no-extend, 'accent, 'accent-no-extend
    modus-themes-region nil

    ;; Options for `modus-themes-diffs': nil, 'desaturated,
    ;; 'bg-only, 'deuteranopia, 'fg-only-deuteranopia
    modus-themes-diffs nil

    modus-themes-org-blocks nil ; {nil,'gray-background,'tinted-background} (also read doc string)

    modus-themes-org-agenda ; this is an alist: read the manual or its doc string
    '((header-block . (variable-pitch scale-title))
      (header-date . (grayscale workaholic bold-today))
      (scheduled . uniform)
      (habit . traffic-light-deuteranopia))

    modus-themes-headings ; this is an alist: read the manual or its doc string
    '((1 . rainbow-section)
      (t . rainbow-no-bold))

    modus-themes-variable-pitch-ui nil
    modus-themes-variable-pitch-headings nil
    modus-themes-scale-headings nil
    modus-themes-scale-1 1.1
    modus-themes-scale-2 1.15
    modus-themes-scale-3 1.21
    modus-themes-scale-4 1.27
    modus-themes-scale-title 1.33)

  ;; Load the theme files before enabling a theme (else you get an error).
  (modus-themes-load-themes)

  ;; Enable the theme at startup. This is done after loading the files.
  ;; You only need `modus-themes-load-operandi' for the light theme or
  ;; `modus-themes-load-vivendi' for the dark one. What I have here is
  ;; a simple test to load a light/dark theme based on some general time
  ;; ranges (just accounting for the hour and without checking for the
  ;; actual sunrise/sunset times). Plus we have `modus-themes-toggle'
  ;; to switch themes at will.
  (let ((time (string-to-number (format-time-string "%H"))))
    (if (and (> time 5) (< time 18))
    (modus-themes-load-operandi)
      (modus-themes-load-vivendi)))

  ;; Also check my package configurations for `indiebrain-fonts' because I use
  ;; the `modus-themes-after-load-theme-hook' for some typeface-related
  ;; tweaks (as those are made at the "face" level).
  (define-key global-map (kbd "<f5>") #'modus-themes-toggle))
#+end_src

** Typeface configurations
:PROPERTIES:
:CUSTOM_ID: h:92da7adc-eba1-4892-b74c-bd602861efea
:END:

*** Font configurations (indiebrain-fonts.el)
:PROPERTIES:
:CUSTOM_ID: h:8C74519F-4C17-4E61-8D35-E5AA89F37C6C
:END:

Any font I choose must conform with the following:

- support Latin character sets;
- be readable at small sizes and look okay at large sizes;
- offer both roman and italic variants, preferably with corresponding
  bold weights;
- not be too thin or at least have multiple weights from which to choose
  from;
- not have too short of an x-height, which makes combinations of text
  and numbers or delimiters somewhat unbalanced;
- not have a name that directly advertises some brand (e.g. "Helvetica"
  is fine as a name, even though a certain corporation tried associate
  itself with the font; but "CORPORATION Sans" is not);
- not be flamboyant by seeking to call too much attention to its details
  or by exaggerating some glyph shapes;
- be equally readable against light and dark backdrops (for instance,
  bitmap fonts are not legible on a white background);
- use the =*.ttf= spec which yields the best results on GNU/Linux.

While there are good free/libre options available, only a handful of
them cover these demanding needs. Some look good at large point sizes.
Some do not have italics, ans so on.

Moving on to my configurations, =indiebrain-fonts.el= covers my typeface
requirements. At its heart is =indiebrain-fonts-typeface-sets-alist=. It
contains associations of property lists (an alist of plists), each of
which pertains to a give display type. For example, when I am doing a
video presentation, I require font configurations that differ from what
I normally use. So I have a =video= key in the alist to accommodate that
particular need. Those associations provide granular control over font
attributes, as they specify both mono and proportionately spaced font
families, each with their corresponding weights and heights.

The command =indiebrain-fonts-set-fonts= prompts with completion for a display
type. It gives options like =laptop=, =desktop=, =video=, which are drawn
from the =indiebrain-fonts-typeface-sets-alist=. When called from Lisp it expects a
=DISPLAY= argument, which is a symbol that matches the car of a cons cell
in the aforementioned alist.

=indiebrain-fonts-fonts-per-monitor= sets the appropriate font family and
size depending on whether I am only on my laptop or have connected to it
an external monitor. In the latter case we use the =desktop= display type.

As noted above, =indiebrain-fonts-typeface-sets-alist= associates a list of
typefaces with desired weights, including for their bold variation. This
is useful when the active theme (e.g. [[https://protesilaos.com/modus-themes/][Modus themes]]) parameterizes the
exact value of a bold weight, by calling =:inherit bold= instead of
specifying =:weight bold=. The former applies the =bold= face, whereas the
latter sets the weight at a constant number, which typically is 700.
Thus, when using such a theme that way, we can configure the =:weight= of
the =bold= face to, e.g., =semibold= and have that propagate across all the
faces that the theme defines.

Now a some notes about setting fonts in Emacs.

While there are many ways to define a baseline or fallback font family,
I find that the most consistent one in terms of overall configuration is
to do it at the "face" level (read the docstring of =set-face-attribute=).
Faces are the domain of themes, though themes are just Elisp programs
hence there is no real distinction here and it is perfectly fine to have
one program define some properties of a face while another specifies
some others. The key is to make those complementary, so that one does
not override the other. Put concretely, =indiebrain-fonts.el= sets
properties such as =:family=, while my themes handle things like colors.

To appreciate this point, consider that in Emacs parlance a "face"
signifies a construct that bundles up together several display
attributes, such as a foreground and a background color, as well as all
typography-related values. Multiple assignments of value can expand the
face's specifications, except when one explicitly overrules a given
property.

There are three faces that are of immediate interest to =indiebrain-fonts.el=:
the =default=, =variable-pitch=, and =fixed-pitch=. The first is the Emacs
frame's main typeface, the second specifies a proportionately spaced
font, and the third does the same for a monospaced family. There are
various scenaria where text on display renders in =variable-pitch=, while
others must remain in =fixed-pitch=. For example, let =org-mode= inline code
present in its monospaced font while using a variable width typeface for
the main text, or just use =variable-pitch= for User Interface elements
such as the mode line to economize on spacing, and so on. Again, the
Modus themes cover that niche out-of-the-box (and offer relevant
customization options). We call this a "mixed font" setup: the easiest
way to get to it is to enable =variable-pitch-mode=.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-fonts
  ;; This is defined in Emacs C code: it belongs to font settings.
  (setq x-underline-at-descent-line t)

  ;; Make sure to read the `indiebrain-fonts-typeface-sets-alist' doc string,
  ;; as it explains what those property lists should contain.
  (setq indiebrain-fonts-typeface-sets-alist
    '((laptop . ( :fixed-pitch-family "Hack"
              :fixed-pitch-regular-weight normal
              :fixed-pitch-heavy-weight bold
              :fixed-pitch-height 125
              :fixed-pitch-line-spacing 1
              :variable-pitch-family "Helvetica"
              :variable-pitch-height 0.9
              :variable-pitch-regular-weight normal))

      (desktop . ( :fixed-pitch-family "Hack"
               :fixed-pitch-regular-weight normal
               :fixed-pitch-heavy-weight bold
               :fixed-pitch-height 125
               :fixed-pitch-line-spacing nil
               :variable-pitch-family "Helvetica"
               :variable-pitch-height 0.9
               :variable-pitch-regular-weight normal))

      (presentation . ( :fixed-pitch-family "Hack"
                :fixed-pitch-regular-weight normal
                :fixed-pitch-heavy-weight bold
                :fixed-pitch-height 150
                :fixed-pitch-line-spacing nil
                :variable-pitch-family "Helvetica"
                :variable-pitch-height 1.0
                :variable-pitch-regular-weight normal))))

  ;; The value of `indiebrain-fonts-laptop-desktop-keys-list' becomes '(laptop
  ;; desktop) based on the car of the first two cons cells found in
  ;; `indiebrain-fonts-typeface-sets-alist'. The assumption is that those
  ;; contain sets from smaller to larger display types.
  (setq indiebrain-fonts-laptop-desktop-keys-list
    (indiebrain-fonts-laptop-desktop-keys))

  ;; This is the breakpoint, in pixels, for determining whether we are
  ;; on the small or large screen layout. The number here is my
  ;; laptop's screen width, while it expands beyond that when I connect
  ;; it to an external monitor (how I normally set it up on my desk).
  (setq indiebrain-fonts-max-small-resolution-width 1366)

  ;; And this just sets the right font depending on whether my laptop is
  ;; connected to an external monitor or not.
  (indiebrain-fonts-fonts-per-monitor)

  ;; See theme section for this hook and also read the doc string of
  ;; `indiebrain-fonts-restore-last'.
  (add-hook 'modus-themes-after-load-theme-hook #'indiebrain-fonts-restore-last)

  (define-key global-map (kbd "C-c f") #'indiebrain-fonts-set-fonts))
#+end_src

This is the source code of =indiebrain-fonts.el= (you can always find the file
if you directly clone [[https://github.com/indiebrain/.files/][my dotfiles' repo]]).

#+include: indiebrain-lisp/indiebrain-fonts.el src emacs-lisp :tangle no

*** Simple font suitability test
:PROPERTIES:
:CUSTOM_ID: h:EF4B146D-090B-4303-B413-80517BF9BB18
:END:

Here is a test I have come up with to make an initial assessment of the
overall quality of a monospaced font that is meant to work well in a
programming context: /can you discern each character at a quick glance?/
If yes, your choice of typeface is good /prima facie/, otherwise search
for something else.

Note that this test is not perfect, since many typefaces fall short in
less obvious ways, such as the space between the characters. Also note
that the website version of this document may not accurately represent
the typeface I am using.

#+begin_example
()[]{}<>«»‹›
6bB8&
0ODdoaoOQGC
I1tilIJL|
!¡ij
5$§SsS5
17ZzZ2
9gqpG6
hnmMN
uvvwWuuwvy
x×X
.,·°%
¡!¿?
:;
`''"‘’“”
—-~≈=≠+*_
…⋯
...

Sample character set
Check for monospacing and Greek glyphs

ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
~!@#$%^&*+
`'"‘’“”.,;:…
()[]{}—-_=|<>/\
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
αβγδεζηθικλμνξοπρστυφχψω

// NOTE that I got this from Hack's website:
// https://source-foundry.github.io/Hack/font-specimen.html
//  The four boxing wizards jump
#include <stdio.h> // <= quickly.
int main(int argc, char **argv) {
  long il1[]={1-2/3.4,5+6==7/8};
  int OxFaced=0xBAD||"[{(CQUINE";
  unsigned O0,l1,Z2,S5,G6,B8__XY;
  printf("@$Hamburgefo%c`",'\n');
  return ~7&8^9?0:l1|!"j->k+=*w";
}
#+end_example

*** Bidirectional writing and ~so-long.el~
:PROPERTIES:
:CUSTOM_ID: h:eb3413b9-d8bc-44a8-ae00-f4ce39831542
:END:

Emacs supports all kinds of languages. However, I only ever read/write
with the Latin alphabet. So, while I appreciate the fact that Emacs can
naively handle other scripts, I have no use for that particular feature.
Setting the default directional-ity to what my languages use can help
improve the responsiveness of Emacs in some cases.

Consistent performance is the reason to also enable =global-so-long-mode=,
built into Emacs versions >= 27, which allows the active major mode to
gracefully adapt to buffers with very long lines. What "very long" means
is, of course, configurable: =M-x find-library so-long= covers several
customization options, though I find that the defaults require no
further intervention from my part.

The code below is a minor adaptation of the insights of Alain M. Lafon
in the [[https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html][Comprehensive guide on handling long lines in Emacs]] (2020-09-29).

#+begin_src emacs-lisp
(setq-default bidi-paragraph-direction 'left-to-right)
(setq bidi-inhibit-bpa t)

(indiebrain-emacs-builtin-package 'so-long
  (global-so-long-mode 1))
#+end_src

** Repeatable key chords (repeat-mode)
:PROPERTIES:
:CUSTOM_ID: h:644E0EDA-B4FD-44EA-80D0-ACE2CC78C50B
:END:

Emacs28 comes with a built-in utility for repeating selected commands in
a more convenient fashion. Once =repeat-mode= is enabled, a key binding
or chord that invokes a command succesfully can be repeated by typing in
its tail or whatever the developer specifies. So =other-window= may be
used like this: =C-x o=, =o=, =o= to switch three windows, instead of =C-x o=,
=C-x o=, =C-x o=.

This is achieved by furnishing transient keymaps that get activated
right after the command they belong to and only once the command in
question has been added to the =repeat-map=. Here is a sample from
=window.el=:

#+begin_example emacs-lisp
(defvar resize-window-repeat-map
  (let ((map (make-sparse-keymap)))
    ;; Standard keys:
    (define-key map "^" 'enlarge-window)
    (define-key map "}" 'enlarge-window-horizontally)
    (define-key map "{" 'shrink-window-horizontally) ; indiebrain note: those three are C-x KEY
    ;; Additional keys:
    (define-key map "v" 'shrink-window) ; indiebrain note: this is not bound by default
    map)
  "Keymap to repeat window resizing commands. Used in `repeat-mode'.")
(put 'enlarge-window 'repeat-map 'resize-window-repeat-map)
(put 'enlarge-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window 'repeat-map 'resize-window-repeat-map)
#+end_example

Once the keymap exists and its commands are in the =repeat-map=, such as
with the above example, we do not have to recreate the entire setup if
all we need is to change key bindings: we just have to rebind the
commands to where it makes sense for us.

At any rate, all we need here is to activate =repeat-mode= and then
implement the repetition mechanism wherever we want.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'repeat
  (repeat-mode 1))
#+end_src

** Key chord hints (which-key.el)
:PROPERTIES:
:CUSTOM_ID: h:5F30C3F4-307B-4485-B51D-B52858D0C109
:END:

This library provides hints on the possible tails of a key chord. So if
you type =C-x r= and wait for =which-key-idle-delay=, a pop-up window will
appear showing you the keys you can use and the actions bound to them.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'which-key
  (setq which-key-dont-use-unicode t)
  (setq which-key-add-column-padding 2)
  (setq which-key-show-early-on-C-h t)
  (setq which-key-idle-delay most-positive-fixnum) ; to disable, set this to most-positive-fixnum
  (setq which-key-idle-secondary-delay 0.05)
  (setq which-key-popup-type 'side-window)
  (setq which-key-show-prefix 'echo)
  (setq which-key-max-display-columns 3)
  (setq which-key-separator "  ")
  (setq which-key-special-keys nil)
  (setq which-key-paging-key "<next>")
  (which-key-mode 1))	   ; to disable, set this to -1
#+end_src

* Selection candidates and search methods
:PROPERTIES:
:CUSTOM_ID: h:3672aa42-5caa-4fb1-a1ed-0f92a2705692
:END:

** Completion framework and extras
:PROPERTIES:
:CUSTOM_ID: h:efcb1075-f3de-4a66-b7fd-6f3db1813d64
:END:

Unlike the desktop metaphor, the optimal way to use Emacs is through
searching and narrowing selection candidates. Spend less time worrying
about where things are on the screen and more on how fast you can bring
them into focus. This is, of course, a matter of realigning priorities,
as we still wish to control every aspect of the interface, as we do
elsewhere in this document.

*** Orderless completion style (and indiebrain-orderless.el)
:PROPERTIES:
:CUSTOM_ID: h:645E204C-11E5-4280-B431-49403859F363
:END:

The, dare I say, /sublime/ [[https://github.com/oantolin/orderless]["orderless" package]] - developed by Omar Antolín
Camarena - provides the =orderless= completion style for efficient,
out-of-order grouped pattern matching. The search components can be of
several styles, such as regexp, flex, prefix, initialism (check its
README because there are lots of variations). Delimiters are literal
spaces by default, but are configurable and can match other characters,
with hyphens and slashes being likely choices. As such, Orderless can
supersede - and for most part improve upon - the completion styles that
come built into Emacs, adding to them the powerful out-of-order
capability.

All we do here is set up Orderless. The =orderless= completion style is
appended to the minibuffer's customisation option for =completion-styles=.
That is defined in Minibuffer configurations and extras.

My =indiebrain-orderless.el= contains the few minor tweaks I introduce (full
code further below).

1. It defines three style dispatchers. Those are single characters that
   acquire a special meaning while at the end of a given input:

   - With the equals sign appended to a sequence of characters, we call
     =indiebrain-orderless-literal-dispatcher= which instructs orderless to match
     that sequence as a literal string.

   - A comma at the end of a string of characters treats that group as
     an initialism, per =indiebrain-orderless-initialism-dispatcher=.

   - While a tilde (=indiebrain-orderless-flex-dispatcher=) makes it makes it a
     flex match.

2. =indiebrain-orderless-with-styles= is a function that changes the default
   pattern-matching styles on a per-command basis. The idea is to use a
   certain style for most completion sessions, but prioritise an
   alternative when needed. I use this with some Consult commands
   (Enhanced minibuffer commands (consult.el and indiebrain-consult.el)). The
   =indiebrain-orderless-default-styles= and =indiebrain-orderless-alternative-styles=
   variables are designed for this particular task.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-orderless
  (setq indiebrain-orderless-default-styles
    '(orderless-prefixes
      orderless-strict-leading-initialism
      orderless-regexp))
  (setq indiebrain-orderless-alternative-styles
    '(orderless-literal
      orderless-prefixes
      orderless-strict-leading-initialism
      orderless-regexp)))

(indiebrain-emacs-elpa-package 'orderless
  (setq orderless-component-separator " +")
  (setq orderless-matching-styles indiebrain-orderless-default-styles)
  (setq orderless-style-dispatchers
    '(indiebrain-orderless-literal-dispatcher
      indiebrain-orderless-initialism-dispatcher
      indiebrain-orderless-flex-dispatcher))
  ;; SPC should never complete: use it for `orderless' groups.
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "SPC") nil)
    (define-key map (kbd "?") nil)))
#+end_src

These are the contents of the =indiebrain-orderless.el= library (get the
file from [[https://github.com/indiebrain/.files][my dotfiles' repo]] (as with all my Elisp code)):

#+include: indiebrain-lisp/indiebrain-orderless.el src emacs-lisp :tangle no

*** Completion annotations (marginalia)
:PROPERTIES:
:CUSTOM_ID: h:7F724EDC-C79C-40CB-BF10-9EE9F8E57416
:END:

This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates. It
framework-agnostic, so it works with Selectrum, Icomplete vertical,
Embark's completions buffer, as well as the default completions' buffer.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'marginalia
  (setq marginalia-annotators
    '(marginalia-annotators-heavy
      marginalia-annotators-light))
  (marginalia-mode 1))
#+end_src

*** Minibuffer configurations and extras (indiebrain-minibuffer.el)
:PROPERTIES:
:CUSTOM_ID: h:813B4DC2-EB36-4825-90EE-299CA53A9AD1
:END:

The minibuffer is the epicentre of extended interactivity with all sorts
of Emacs workflows: to select a buffer, open a file, provide an answer
to some prompt, such as a number, regular expression, password, and so
on.

Emacs has built-in capabilities to perform two distinct tasks related to
such interactions:

+ Narrowing :: Use pattern matching algorithms to limit the list of
  choices (known as "candidates" or "completion candidates") to those
  matching the given input. There are several pattern matching styles
  already built-in, while we can opt to extend them further, as I do
  with Orderless (Orderless completion style (and
  indiebrain-orderless.el)).

+ Selecting :: Visualise the list of completion candidates and pick an
  item out of it using regular motions or concomitant extras. By
  default, Emacs visualises results in a special =*Completions*= buffer,
  which does not have lots of features and is not particularly pleasing
  to use.

There are third party completion frameworks that accomplish both of the
aforementioned, such as Ivy and Helm. While others focus on the latter,
namely, Selectrum and the built-in Icomplete. Then, there is also Embark
which has a facility to display completion candidates in a live updating
buffer (Embark is not about that task per se---read the details of
[[#h:E4A448DA-159D-4BDB-AE29-1118088EFE9D][Extended minibuffer actions and more (embark.el and indiebrain-embark.el)]]).

I have used Helm and Ivy in the past. While I enjoy the functionality
they provide, as of 2021-06-07 I've decided to move more toward more
focused, and modular tooling to better understand the inner workings my
Emacs configuration.

What my completion selection interface does in a nutshell:

- When minibuffer completion is invoked, a live updating =*Completions*=
  buffer is placed right above the minibuffer, displaying all completion
  candidates in a vertical list (meta data provided by Marginalia:
  [[#h:7F724EDC-C79C-40CB-BF10-9EE9F8E57416][Completion annotations (marginalia)]]). This only happens after some
  input has been provided, otherwise all you see is an empty minibuffer
  (though =indiebrain-minibuffer-toggle-completions= or any of the cycling
  motions will display the candidates).

  - The length of minimum input that triggers live completions when met or
    hides them when unmatched is controlled by the variable
    =indiebrain-minibuffer-minimum-input=.

  - =indiebrain-minibuffer-live-update-delay= controls how fast the
    live-updating Completions should respond to minibuffer input. I
    find that a short delay is better than none, because I usually type
    something quickly and do not need to peruse candidates in the
    meantime.

  - There are two variables =indiebrain-minibuffer-completion-blocklist=
    and =indiebrain-minibuffer-completion-passlist= that can be used to
    disable live completions altogether for select commands or bypass
    the minimum input threshold and the delay. I do not use those in
    practice, because the minimum input and the delay are good enough
    for my case.

- Using up/down motions or =C-n= and =C-p=, we can seamlessly switch from
  the minibuffer to the completions and vice versa by treating the two
  as a contiguous area. The implementation follows a "do the right
  thing" model where such a motion will switch between the minibuffer
  and the =*Completions*= only while moving towards each buffer's outer
  boundaries (top/bottom), otherwise it just proceeds in the given
  direction. For example, if we are in the minibuffer and use =C-n= we go
  to the top of the =*Completions*= buffer, while another =C-n= movers to
  the second completion candidate on the list (if any), until it
  eventually reaches the buffer's end, where a subsequent =C-n= switches
  back to the minibuffer.

- While completing file names, such as at the =find-file= prompt (which is
  bound to =C-x C-f= by default), it is possible to hide the current path
  by specifying a base directory either of the user's =$HOME= or the file
  system's absolute root. In other words, =~/= or =/= followed by any valid
  candidate will clear the minibuffer's contents while continuing with
  completion to the respective paths. This is very helpful when you are
  switching from a deeply nested directory into some other location. For
  instance, =~/.files/emacs/.emacs.d/= is what I get when I call =C-x C-f=
  from this file, so typing =~/.em<tab>= completes =~/.emacs.d/= and
  continues with the contents of that directory. Use =undo= (=C-/=) when you
  mistype something. This "file name shadowing" works while
  =file-name-shadow-mode= is enabled. User of Icomplete will be familiar
  with this functionality.

- For file name completion, the =M-backspace= exhibits a "do-what-I-mean"
  behaviour (=indiebrain-minibuffer-backward-updir=): when point is after
  a character, the backspace will just delete it as usual, but when it
  finds a directory signified by =/= it will instead remove the entirety
  of it. As such, =path/to/some/file/= with point at the very end will
  delete =file/= and so on. This is what the built-in Ido mode does and
  what Fido mode re-implements for Icomplete.

- By default, hitting =RET= in the =*Completions*= buffer will take the
  candidate and place it in the minibuffer. To actually complete the
  process, you need to confirm it again from there. I prefer to take a
  shortcut, hence =indiebrain-minibuffer-choose-completion-exit=.

- While we normally type in the minibuffer for narrowing and use the
  =*Completions*= to pick a candidate, we can also operate directly from
  the latter. =indiebrain-minibuffer-choose-completion-dwim= lets you
  append a candidate to the minibuffer and to act on it depending on the
  context. For completing buffers, this command will just switch to the
  desired buffer. For file names, it will append the path, and stay in
  the =*Completions*= from where we can append a candidate among those in
  the new list. Though my favourite mode of action is while interfacing
  with =completing-read-multiple= prompts, where it will append the
  candidate, add a =,= for the separator, and go back to the
  =*Completions*=, letting you pick another entry from those available.
  The elegance of this latter aspect is that my =indiebrain-common.el=
  contains a snippet which removes selected entries from the candidates,
  so we never input them twice (Common auxiliary functions
  (indiebrain-common.el)). This is the best =completing-read-multiple=
  experience I have had to date.

+ Another way to pick a completion is to target its line number. This
  is done with =indiebrain-minibuffer-choose-completion-number= which expects a
  prefix numeric argument and can be called from either the minibuffer
  or the Completions' buffer. For completeness, a numeric argument is
  expressed in the form of =C-u NUMBER=, though you can just hold down
  Ctrl or Meta hit a number and call the command. If the number is
  multiple digits long, start the prefix as usual, release the modifier
  key and continue inputting numbers (e.g. =M-5 0 1= is equal to =C-u 501=).

Finally, here is an overview of the settings covered herein:

+ Completion styles :: I mostly rely on the Orderless completion style.
  An exception is a niche functionality of the =partial-completion= style
  which is built-in: with it you can navigate to a filesystem path like
  =~/.l/s/fo= for =~/.local/share/fonts= (combine that with the file
  shadowing mentioned above, for a minimalist, decluttered flow). So I
  use those two styles to cover every case by default, while the
  variable =completion-category-overrides= can control the standard option
  of =completion-styles= on a per-category basis.

+ Recursive minibuffers :: I enable recursive minibuffers. This
  practically means that you can start something in the minibuffer,
  switch to another window, call the minibuffer again, run some
  commands, and then move back to what you initiated in the original
  minibuffer. Or simply call an =M-x= command while in the midst of a
  minibuffer session. To exit, hit =C-]= (=abort-recursive-edit=), though
  the regular =C-g= should also do the trick.

  The =minibuffer-depth-indicate-mode= will show a recursion indicator,
  represented as a number, next to the minibuffer prompt, if a recursive
  edit is in progress (also check Mode line recursion indicators).

+ Key bindings :: The key bindings in the pattern of =s-KEY= follow the
  principles I outline in my note about the use of the Super key. They
  are included here because they are related to minibuffer-centric
  actions. As for the various keys to perform completion, we have the
  following:

  - The =RET= key always chooses the current candidate and exits,
    regardless of whether it is called from inside the minibuffer or
    the Completions' buffer.

  - The =TAB= key completes the candidate when called from the
    minibuffer. If there are only a few candidates, repeated presses
    of the key cycle through them, again when called from the
    minibuffer. If the =TAB= is pressed inside the Completions' buffer
    it does either of two things: (i) when completing directories
    using =find-file= or equivalent, it expands the directory at point
    and moves to the minibuffer from where to continue with completion
    inside the selected directory, or (ii) it selects the current
    candidate if it is unique and/or a file and exits.

  - The =M-RET= key behaves exactly like =RET= except when dealing with
    prompts that accepts multiple inputs (=completing-read-multiple=).
    Those prompts have =[CRM]= label prefixed to them. In those cases,
    =M-RET= from inside the Completions' buffer selects the current
    candidate, inserts a delimiter, and goes back to the Completions
    buffer to repeat the process. To exit from that loop, you can use
    either =TAB= or =RET= based on what is noted above.

Also check my setup for the [[#h:5E6FFCFA-74BC-47A6-9799-CEBEDA82AFB9][Minibuffer history (savehist-mode)]]. After
several months of full time usage, I am confident in the built-in
mechanism's ability to sort things well enough and to surface the
results I am most likely interested in, based on previous selections.

Finally, the =indiebrain-minibuffer.el= file contains tweaks for the cursor's
appearance, depending on whether it is in the minibuffer or the
completions' buffer. The idea is to make the focus more noticeable.
For everything else, check Cursor appearance and tweaks.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'minibuffer
  (setq completion-styles
    '(substring initials flex partial-completion orderless))
  (setq completion-category-overrides
    '((file (styles . (partial-completion orderless)))))
  (setq completion-cycle-threshold 2)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters nil)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completion-auto-help t)
  (setq completion-ignore-case t)
  (setq-default case-fold-search t)   ; For general regexp

  ;; The following two are updated in Emacs 28. They concern the
  ;; *Completions* buffer.
  (setq completions-format 'one-column)
  (setq completions-detailed t)

  ;; Grouping of completions for Emacs 28
  ;;  FIXME 2021-05-21: the group headings break indiebrain-minibuffer cycling
  (setq completions-group nil)
  ;; (setq completions-group-sort 'alphabetical)
  ;; (setq completions-group-format
  ;;       (concat
  ;;        (propertize "    " 'face 'completions-group-separator)
  ;;        (propertize " %s " 'face 'completions-group-title)
  ;;        (propertize " " 'face 'completions-group-separator
  ;;                    'display '(space :align-to right))))

  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)

  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t) ; also check `use-short-answers' for Emacs28
  (setq resize-mini-windows t)
  (setq minibuffer-eldef-shorten-default t)

  (setq echo-keystrokes 0.25)           ; from the C source code

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  (add-hook 'completion-list-mode-hook #'indiebrain-common-truncate-lines-silently) ; from `indiebrain-common.el'

  ;; Defines, among others, aliases for common minibuffer commands to
  ;; Super-KEY. Normally these should go in individual package
  ;; configurations, but their grouping here makes things easier to
  ;; understand. Besides, they are related to the minibuffer.
  (define-key completion-list-mode-map (kbd "<tab>") #'choose-completion)
  (let ((map global-map))
    (define-key map (kbd "s-b") #'switch-to-buffer)
    (define-key map (kbd "s-B") #'switch-to-buffer-other-window)
    (define-key map (kbd "s-f") #'find-file)
    (define-key map (kbd "s-F") #'find-file-other-window)
    (define-key map (kbd "s-d") #'dired)
    (define-key map (kbd "s-D") #'dired-other-window))
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "C-j") #'exit-minibuffer)
    (define-key map (kbd "<tab>") #'minibuffer-force-complete))
  (let ((map minibuffer-local-must-match-map))
    ;; I use this prefix for other searches
    (define-key map (kbd "M-s") nil)))

(indiebrain-emacs-builtin-package 'indiebrain-minibuffer
  (setq-default indiebrain-minibuffer-mini-cursors t) ; also check `indiebrain-cursor.el'
  (setq indiebrain-minibuffer-remove-shadowed-file-names t)
  (setq indiebrain-minibuffer-minimum-input 3)
  (setq indiebrain-minibuffer-live-update-delay 0.5)

  ;; ;; NOTE: `indiebrain-minibuffer-completion-blocklist' can be used for
  ;; ;; commands with lots of candidates, depending also on how low
  ;; ;; `indiebrain-minibuffer-minimum-input' is. With my current settings,
  ;; ;; this is not required, otherwise I would use this list:
  ;;
  ;; '( describe-symbol describe-function
  ;;    describe-variable execute-extended-command
  ;;    insert-char)
  (setq indiebrain-minibuffer-completion-blocklist nil)

  ;; This is for commands that should always pop up the completions'
  ;; buffer. It circumvents the default method of waiting for some user
  ;; input (see `indiebrain-minibuffer-minimum-input') before displaying and
  ;; updating the completions' buffer.
  (setq indiebrain-minibuffer-completion-passlist
    '( dired-goto-file vc-retrieve-tag
       indiebrain-bongo-playlist-insert-playlist-file))

  (define-key global-map (kbd "s-v") #'indiebrain-minibuffer-focus-mini-or-completions)
  (let ((map completion-list-mode-map))
    (define-key map (kbd "h") #'indiebrain-simple-describe-symbol) ; from `indiebrain-simple.el'
    (define-key map (kbd "M-g") #'indiebrain-minibuffer-choose-completion-number)
    (define-key map (kbd "M-v") #'indiebrain-minibuffer-focus-minibuffer)
    (define-key map (kbd "C-g") #'indiebrain-minibuffer-keyboard-quit-dwim)
    (define-key map (kbd "C-n") #'indiebrain-minibuffer-next-completion-or-mini)
    (define-key map (kbd "<down>") #'indiebrain-minibuffer-next-completion-or-mini)
    (define-key map (kbd "C-p") #'indiebrain-minibuffer-previous-completion-or-mini)
    (define-key map (kbd "<up>") #'indiebrain-minibuffer-previous-completion-or-mini)
    (define-key map (kbd "<return>") #'indiebrain-minibuffer-choose-completion-exit)
    (define-key map (kbd "<M-return>") #'indiebrain-minibuffer-choose-completion-dwim)
    (define-key map (kbd "M-<") #'indiebrain-minibuffer-beginning-of-buffer)
    ;; Those are generic actions for the "*Completions*" buffer, though
    ;; I normally use `embark'.
    (define-key map (kbd "w") #'indiebrain-minibuffer-completions-kill-symbol-at-point)
    (define-key map (kbd "i") #'indiebrain-minibuffer-completions-insert-symbol-at-point)
    (define-key map (kbd "j") #'indiebrain-minibuffer-completions-insert-symbol-at-point-exit))
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "M-g") #'indiebrain-minibuffer-choose-completion-number)
    (define-key map (kbd "C-n") #'indiebrain-minibuffer-switch-to-completions-top)
    (define-key map (kbd "<down>") #'indiebrain-minibuffer-switch-to-completions-top)
    (define-key map (kbd "C-p") #'indiebrain-minibuffer-switch-to-completions-bottom)
    (define-key map (kbd "<up>") #'indiebrain-minibuffer-switch-to-completions-bottom)
    (define-key map (kbd "C-l") #'indiebrain-minibuffer-toggle-completions)) ; "list" mnemonic
  (let ((map minibuffer-local-filename-completion-map))
    (define-key map (kbd "<M-backspace>") #'indiebrain-minibuffer-backward-updir))
  (add-hook 'minibuffer-setup-hook #'indiebrain-minibuffer-mini-cursor)
  (add-hook 'completion-list-mode-hook #'indiebrain-minibuffer-completions-cursor)
  (add-hook 'completion-list-mode-hook #'indiebrain-minibuffer-hl-line)
  (add-hook 'completion-list-mode-hook #'indiebrain-minibuffer-display-line-numbers))
#+end_src

And here is =indiebrain-minibuffer.el= (from [[https://github.com/indiebrain/.files][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-minibuffer.el src emacs-lisp :tangle no

*** Enhanced minibuffer commands (consult.el and indiebrainconsult.el)
:PROPERTIES:
:CUSTOM_ID: h:882F6579-5CFD-4F33-852D-3291557879FF
:END:

Daniel Mendler's Consult is a welcome addition to the ecosystem of
modular, extensible tools that work with the standard minibuffer
completion mechanisms and, by extension, with every user interface that
largely conforms with them (Icomplete, Selectrum) or fully respects them
(Embark and [[https://github.com/minad/vertico][Daniel's own Vertico]]). For my case, this means that it works
with everything included in [[#h:efcb1075-f3de-4a66-b7fd-6f3db1813d64][Completion framework and extras]].

Consult's value proposition is two-fold: (1) remain aligned with the
Emacs completion paradigm, and (2) offer minibuffer-centric commands
that either enhance aspects of interactivity and functionality found in
existing commands or outright provide them from scratch.

Some Consult commands are drop-in replacements for built-in options. For
example =consult-complex-command= offers an improved interactive
experience over the default =repeat-complex-command=. Same principle for
=consult-goto-line= which displays the line numbers and offers a live
preview of where you are about to land.

Other commands enhance the defaults with a filtering mechanism that
targets candidates by their type. A case in point is =consult-imenu= which
recognises syntactic constructs that are variables, functions, macros
(configurable via =consult-imenu-narrow=, =consult-imenu-toplevel=).

This "filtering" mechanism, which is internally known as "narrowing",
can be accessed via a key binding for all commands that support it. In
my case, that key is the right angled bracket, or greater than sign (=>=)
from inside the minibuffer (configure =consult-narrow-key=). So you type
the narrow key and follow it up with another key that matches the
relevant targets. Hit backspace to remove the narrowing (users may wish
to set up [[#h:5F30C3F4-307B-4485-B51D-B52858D0C109][Key chord hints (which-key.el)]], though I just memorise what I
need, or call =consult-narrow-help=).

This narrowing-by-type mechanism can also be used without inputting the
=consult-narrow-key=, just by typing in the appropriate character and
inserting a space. For instance, to search only for functions in
=consult-imenu=, you type =f= and then a space. Consult will add an
indicator to the minibuffer prompt describing the active filter.

Another intriguing facility of Consult is its asynchronous call to
external processes, such as =grep= and =find=. Those calls can be configured
to return some output based on a minimum number of characters, while
they also allow for tweaks to their update delays. Interactivity is
already a given, meaning that you can continue typing and see the
results pop up. Furthermore, they implement a two-stage input scheme,
separated by a configurable delimiter (=#= by default and controlled with
=consult-async-default-split=):

- First you type in the pattern that should be sent to the external
  program. This is what triggers the asynchronous call. So your input
  looks like this: =#PATTERN=. The pattern will typically consist of some
  text or a regular expression, but can also include command line flags
  for the underlying CLI program (check Consult's documentation for the
  technicalities).

- Then you can add another field delimiter to instruct Consult to (i)
  keep the results that =#PATTERN= gave you and (ii) leverage Emacs' own
  mechanisms to further narrow the list. Now your input looks like this:
  =#PATTERN#MORE-PATTERNS=. The =#MORE-PATTERNS= will use whatever
  completion styles you have configured (check my =completion-styles=).

As already suggested, Consult provides previews for its commands. This
feature should work without any further intervention.

Consult can shine when used in tandem with Embark to produce buffers
that hold all the candidates of any given minibuffer completion command
([[#h:E4A448DA-159D-4BDB-AE29-1118088EFE9D][Extended minibuffer actions and more (embark.el and indiebrain-embark.el)]]).
For example, =embark-export= can be called from inside =consult-grep= (and
variants) to deliver a dedicated =grep-mode= buffer, which can then be
edited with the help of the =wgrep= package (check [[#h:8B7E1B4C-D129-4F7E-A4AB-DEF5531C9F9C][wgrep (writable grep)]]).
Use that to quickly refactor some pattern across your files.

Other nice extensions of Consult are (i) its ability to work as a
generic front-end for completion, and (ii) its preview facility for
registers. The former is done by =consult-completion-in-region= which
provides completion for commands such as =dabbrev-completion= or the TAB
key in programming buffers (see [[#h:3E30D7B6-0044-4F4D-B9D4-62A599CEA964][Tabs, indentation, and the TAB key]]).
While the latter is an overall prettier presentation for the familiar
register preview window (watch: [[https://protesilaos.com/codelog/2020-03-08-emacs-registers/][Primer on Emacs "registers"]]
(2020-03-08)).

As for registers themselves, Consult furnishes three commands, one
focused on minibuffer completion and two as do-what-I-mean alternatives
to the built-in facilities of storing and inserting---or jumping
to---registered data.

+ =consult-register= is what you use for completion. It searches through
  the contents of the registered compartments and, thus, works well when
  you have text-heavy registers that you need to filter through before
  inserting one at point.

+ =consult-register-store= will save a "thing" to the specified key. What
  the thing is depends on the context:

  + If the region is active, it will operate on the affected text.
  + If you call it with a numeric argument, it will store that number.
  + If no region is active and no numeric prefix is supplied, it will
    let you select between the current position (point), window
    configuration (window), set of frames with their window
    configurations (frameset), or keyboard macro (kmacro).

  This do-what-I-mean facility is complemented by an actions' menu that
  offers hints on the keys you can use to specify the desired step
  forward. For example, if you are operating on a region, =M-a= will let
  you append the text to the given register.

+ =consult-register-load= simplifies the mental workload of actually using
  a register. Unlike the Emacs default where you need to know in
  advance what type of data does the register holds in order to use the
  right action for it, Consult's version just handles that for you. All
  you have to do is instruct it to use the given register and it will
  know whether it should insert some text or jump to a point/frameset,
  etc.

In practice, I only ever use =consult-register= because I have already
developed muscle memory for the register-related actions. Though using
all three of the above is easier to learn and more consistent overall.

Note that my =indiebrian-consult.el= (reproduced after the following package
configurations) defines some /quick and dirty/ extensions or thin wrappers
around Consult commands. The former *will be reviewed* in favour of
better alternatives, even though they "simply work" with everything I
try.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'consult
  (setq consult-line-numbers-widen t)
  ;; ;; FIXME 2021-04-10: This does not work with `indiebrain-minibuffer.el'.
  ;; (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (setq consult-imenu-config
    '((emacs-lisp-mode :toplevel "Functions"
               :types ((?f "Functions" font-lock-function-name-face)
                   (?m "Macros"    font-lock-keyword-face)
                   (?p "Packages"  font-lock-constant-face)
                   (?t "Types"     font-lock-type-face)
                   (?v "Variables" font-lock-variable-name-face)))))
  (setq register-preview-delay 0.8
    register-preview-function #'consult-register-format)
  (setq consult-find-command "find . -iname *ARG* OPTS")
  (setq consult-preview-key 'any)

  ;; Enables previews inside the standard *Completions* buffer (what
  ;; `indiebrain-minibuffer.el' uses).
  (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x M-:") #'consult-complex-command)
    (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
    (define-key map (kbd "C-x M-k") #'consult-kmacro)
    (define-key map (kbd "M-g M-g") #'consult-goto-line)
    (define-key map (kbd "M-K") #'consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
    (define-key map (kbd "M-F") #'consult-focus-lines) ; same principle
    (define-key map (kbd "M-s M-b") #'consult-buffer)
    (define-key map (kbd "M-s M-f") #'consult-find)
    (define-key map (kbd "M-s M-g") #'consult-grep)
    (define-key map (kbd "M-s M-m") #'consult-mark)
    (define-key map (kbd "C-x r r") #'consult-register)) ; Use the register's prefix
  (define-key consult-narrow-map (kbd "?") #'consult-narrow-help))

(indiebrain-emacs-builtin-package 'indiebrain-consult
  (setq consult-project-root-function #'indiebrain-consult-project-root)
  (setq indiebrain-consult-command-centre-list
    '(consult-line
      indiebrain-consult-line
      consult-mark))
  (setq indiebrain-consult-command-top-list
    '(consult-outline
      consult-imenu
      indiebrain-consult-outline
      indiebrain-consult-imenu))
  (indiebrain-consult-set-up-hooks-mode 1)
  (let ((map global-map))
    (define-key map (kbd "M-s M-i") #'indiebrain-consult-imenu)
    (define-key map (kbd "M-s M-s") #'indiebrain-consult-outline)
    (define-key map (kbd "M-s M-y") #'indiebrain-consult-yank)
    (define-key map (kbd "M-s M-l") #'indiebrain-consult-line)))
#+end_src

Here is =indiebrian-consult.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: indiebrian-lisp/indiebrian-consult.el src emacs-lisp :tangle no

*** Extended minibuffer actions and more (embark.el and indiebrain-embark.el)
:PROPERTIES:
:CUSTOM_ID: h:E4A448DA-159D-4BDB-AE29-1118088EFE9D
:END:

Embark provides a unified framework of regular Emacs keymaps which let
you carry out /contextually relevant actions/ on *targets* through a common
*point of entry*, typically a /prefix key/.

- "Actions" are standard Emacs commands, such as =describe-symbol= or some
  interactive command you have defined that reads an argument from the
  minibuffer.

- "Targets" are semantically sensitive constructs, such as the symbol at
  point, a URL, a file name, the active region, or the current
  completion candidate in the minibuffer (or the completions'
  buffer---more on that in the next section). Embark has so-called
  "clasifiers" which help it determine the category that the target
  belongs to.

- The "contextually relevant [actions]" are defined in keymaps whose
  scope matches the category of the target. So =embark-file-map= holds all
  key and command assossiations for when Embark recognises a file name
  as its target. =embark-region-map= is for actions pertaining to the
  active region; =embark-buffer-map= for buffer names that you access
  through, say, =switch-to-buffer= (=C-x b=). And so on.

- As for the "point of entry" or "prefix key", it is an Embark command,
  such as =embark-act= or =embark-become=. Those activate the appropriate
  keymap, thus granting you access to the relevant commands.

Embark can act on individual targets (e.g. the region) or sets of
targets (e.g. the list of minibuffer completion candidates).

Emacs users are already familiar with this contextuality of Embark, even
though they may not realise it. Think, for example, that hitting the =j=
key in an =org-mode= buffer performs the action of inserting that letter
in the buffer: you type something. While the same =j= key performs a
different action in, say, a =dired-mode= buffer. There is no conflict
between those actions because each of them is bound to a distinct
keymap, and only one of those keymaps applies in their respective
context.

The beauty of Embark's design is that you configure its contextuality in
the exact same way you define all of your Emacs key bindings. So you can
bind any command to whatever key you want and confine that action to a
context you specify.

Learn more about the available keymaps with =M-x describe-keymap= and then
search for =embark=.

Now a few things about actions that you can gain access to by invoking
either of =embark-act= (most cases), or =embark-become= (where appropriate):

- To learn which keymap's contents get enabled in the present context,
  either set up =which-key.el=, or follow up the =embark-act= call with =C-h=
  (remember that this conforms with the Emacs convention of using =C-h= as
  a suffix to display help about possible key chords that complete what
  has already been typed in---if you are new to Emacs, consult my note
  on [[#h:425FEDB1-05B5-4D89-81CC-222C5ADA1986][How do you learn Emacs?]]). For the sake of user-friendliness, I do
  set up =which-key= in this document ([[#h:5F30C3F4-307B-4485-B51D-B52858D0C109][Key chord hints (which-key.el)]]) and
  apply the necessary tweaks in the following package configurations.

  - Keymaps aside, you can call /any command/ after invoking =embark-act=.
    This can be either with =M-x= or via a key binding. For example, if
    you want to grep for the symbol at point in the current project, you
    can do =embark-act= and then =C-x p g= (=project-find-regexp=) (also read
    [[#h:E5EAE6EE-BF12-4903-81BE-081372C046EB][Projects (project.el and indiebrain-project.el)]]). This will, of
    course, work as expected for commands that typically prompt you for
    something to operate on.

- You will often be targeting individual items, such as the current
  completion candidate in the minibuffer, or the symbol at point. You
  can, however, collect the entire set of targets and store it in a
  buffer, which you can then re-use at your convenience or save it on
  disk (with =write-file= bound to =C-x C-w= by default). This is done by
  the =embark-collect-snapshot= command, which you can always access
  through =embark-act=.

  - The "Embark Collect" buffer can be presented as a grid or a list,
    with the possibility to manually switch between the two by means of
    the =embark-collect-toggle-view= command. The list view offers more
    room to the side of each candidate. It can be used to display
    annotations (see [[#h:7F724EDC-C79C-40CB-BF10-9EE9F8E57416][Completion annotations (marginalia)]]), such as the
    first line of a variable's doc string and current value, a command's
    key binding, the buffer's underlying file system path if it is
    visiting a file, and so on.

  - Embark's "collect" buffer also has a live-updating version, which
    can be use to filter the list of targets. This particular feature
    can, in fact, be used as a medium for visualising the list of
    candidates in the active minibuffer session. I used that setup for
    several months together with the default minibuffer as part my
    bespoke completion framework, though as of 2021-04-02 I handle the
    live-updating completions' buffer independently of Embark
    ([[#h:813B4DC2-EB36-4825-90EE-299CA53A9AD1][Minibuffer configurations and extras (indiebrain-minibuffer.el)]]).

  - Other than producing a snapshot, Embark can also collect the targets
    and present them in a buffer whose major-mode is specialised to work
    on the category those targets belong to. This is done with the
    =embark-export= command. If you are targeting files, then the export
    takes you to a =dired-mode= buffer (also refer to this document's
    section on [[#h:2591A95A-FC9F-40DA-9E24-A327A453606D][Dired (directory editor, file manager)]]); buffers go to
    =ibuffer-mode= (check Ibuffer and extras); grep results in a =grep-mode=
    buffer, and so on.

Finally, a few words about =indiebrain-embark.el= that is reproduced after the
following block with the package configurations:

- Extra keymaps that integrate Embark with packages like =consult=
  ([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el and indiebrain-consult.el)]]).

- Tweaks to let =keycast= track and display Embark actions ([[#h:e8e51a73-e583-4250-ac26-15627cd93932][Keycast mode]]).

- A toggle for setting up =which-key= for the =embark-action-indicator=.
  This shows key hints but only for Embark actions, as I normally do not
  use them elsewhere (read [[#h:5F30C3F4-307B-4485-B51D-B52858D0C109][Key chord hints (which-key.el)]]).

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'embark
  (setq embark-collect-initial-view-alist
    '((file . list)
      (buffer . list)
      (symbol . list)
      (line . list)
      (xref-location . list)
      (kill-ring . zebra)
      (t . list)))
  (setq embark-quit-after-action t)     ; XXX: Read the doc string!
  (setq embark-collect-live-update-delay 0.5)
  (setq embark-collect-live-initial-delay 0.8)

  (define-key global-map (kbd "C-M-,") #'embark-act)
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "C-M-,") #'embark-act)
    (define-key map (kbd "C->") #'embark-become)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view)) ; parallel of `fill-paragraph'
  (let ((map embark-collect-mode-map))
    (define-key map (kbd "C-M-,") #'embark-act)
    (define-key map (kbd ",") #'embark-act)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view))
  (let ((map embark-region-map))
    (define-key map (kbd "a") #'align-regexp)
    (define-key map (kbd "i") #'epa-import-keys-region)
    (define-key map (kbd "s") #'sort-lines)
    (define-key map (kbd "u") #'untabify))
  (let ((map embark-symbol-map))
    (define-key map (kbd ".") #'embark-find-definition)
    (define-key map (kbd "k") #'describe-keymap)))

(indiebrain-emacs-builtin-package 'indiebrain-embark
  (indiebrain-embark-keymaps 1)
  (indiebrain-embark-setup-packages 1))
#+end_src

This is =indiebrain-embark.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-embark.el src emacs-lisp :tangle no

*** Projects (project.el and indiebrain-project.el)
:PROPERTIES:
:CUSTOM_ID: h:E5EAE6EE-BF12-4903-81BE-081372C046EB
:END:

Starting with Emacs 28, the current development target, =project.el=
contains lots of interesting additions that make it an all-round useful
tool. Chief among them is a new prefix key bound to =C-x p=. This has good
mnemonic value, like those for tabs (=C-x t=) and registers (=C-x r=).

A "project" is, in our case, a directory whose contents are related to
each other in terms of the end product they can provide. Think, for
example, how Emacs' source code is a single "project" that delivers the
program we use. In practical terms, a project is a version controlled
directory (or directory tree) governed by some program. For my case that
is =git= though other backends are supported (by virtue of VC---see
section on [[#h:A852E4F8-426C-4AA1-846E-41204B0D28C4][Version control framework (vc.el and indiebrain-vc.el)]] as
well as my related extras in Diff-mode (and indiebrain-diff.el
extensions)).

Using any of the commands listed in =C-x p C-h= will append the current
project to a list of "known projects", stored in the dynamically updated
=project--list= variable, whose contents are stored in a file defined by
=project-list-file= (remember that =C-h= can be added to any key sequence to
show its extensions and the commands associated with them). It is then
possible to switch between your projects and proceed to immediately
perform an action on them with =C-x p p=. A menu with possible commands
will appear once you select a project. That is customisable via
=project-switch-commands=.

Also note that =C-x p p= (=project-switch-project=) can be used to store a
new version-controlled directory in the =project--list=. Look for the =...
(choose a dir)= option.

Now an overview of the =indiebrain-project.el= commands, which build on
top of an otherwise comprehensive system (full code further below):

- =indiebrain-project-commit-log= produces a list with the most recent
  commits in the project. The default count is controlled by a
  customisation option: =indiebrain-project-commit-log-limit=. In case
  there is no project being acted upon, the command first prompts for
  completion against the project list.

- =indiebrain-project-find-subdir= provides completion for subdirectories
  in the current project. It opens the match in a Dired buffer. When no
  project is present, it prompts for completion.

- =indiebrain-project-magit-status= produces the =magit-status= buffer for
  the current project or prompts for completion.

- =indiebrain-project-retrieve-tag= lets you switch to an earlier tagged
  commit or branch using completion. As always, when no project is
  present, it asks for one before doing its work.

To aid me in my work, I copied code from Manuel Uberti's website (also
referenced in the source code below this configuration block):

- [[https://www.manueluberti.eu/emacs/2020/11/14/extending-project/][Extending project.el]] (2020-11-14)
- [[https://www.manueluberti.eu/emacs/2020/11/21/flymake-projects/][Restricting Flymake to my projects]] (2020-11-21)

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'project
  ;; ;; Use this for Emacs 27 (I am on 28)
  ;; (add-to-list 'indiebrain-emacs-ensure-install 'project)
  (setq project-switch-commands
    '((?f "File" project-find-file)
      (?s "Subdir" indiebrain-project-find-subdir)
      (?g "Grep" project-find-regexp)
      (?d "Dired" project-dired)
      (?b "Buffer" project-switch-to-buffer)
      (?q "Query replace" project-query-replace-regexp)
      (?t "Tag switch" indiebrain-project-retrieve-tag)
      (?m "Magit" indiebrain-project-magit-status)
      (?v "VC dir" project-vc-dir)
      (?l "Log VC" indiebrain-project-commit-log)
      (?e "Eshell" project-eshell)))
  (define-key global-map (kbd "C-x p q") #'project-query-replace-regexp)) ; C-x p is `project-prefix-map'

(indiebrain-emacs-builtin-package 'indiebrain-project
  (setq indiebrain-project-project-roots '("~/Developer/" "~/src/github.com/Shopify/"))
  (setq indiebrain-project-commit-log-limit 25)
  (setq indiebrain-project-large-file-lines 1000)
  (let ((map global-map))
    (define-key map (kbd "C-x p <delete>") #'indiebrain-project-remove-project)
    (define-key map (kbd "C-x p l") #'indiebrain-project-commit-log)
    (define-key map (kbd "C-x p m") #'indiebrain-project-magit-status)
    (define-key map (kbd "C-x p s") #'indiebrain-project-find-subdir)
    (define-key map (kbd "C-x p t") #'indiebrain-project-retrieve-tag)))
#+end_src

This is =indiebrain-project.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-project.el src emacs-lisp :tangle no

*** Completion for recent files and directories (indiebrain-recentf.el)
:PROPERTIES:
:CUSTOM_ID: h:e7008b34-7a7f-40af-9f98-58d36c41f515
:END:

This is a built-in minor mode that keeps track of the files you have
opened, allowing you to revisit them faster. its true power consists in
the fact that its data, maintained in =recentf-list=, is a simple
variable. this means that we can access it through any relevant piece of
elisp functionality.

To that end, the functions defined in =indiebrain-recentf.el= either
control the contents of the list or allow me to access them through my
completion framework or a dedicated file listing.

Note that there exists a built-in =recentf-open-files= function for
accessing the recent files through a bespoke buffer. Though, I have
no use for it.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'recentf
  (setq recentf-save-file (locate-user-emacs-file "recentf"))
  (setq recentf-max-saved-items 200)
  (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))
  (add-hook 'after-init-hook #'recentf-mode))

(indiebrain-emacs-builtin-package 'indiebrain-recentf
  (add-to-list 'recentf-keep 'indiebrain-recentf-keep-predicate)
  (let ((map global-map))
    (define-key map (kbd "s-r") #'indiebrain-recentf-recent-files)
    (define-key map (kbd "C-x C-r") #'indiebrain-recentf-recent-dirs)))
#+end_src

This is a copy of =indiebrain-recentf.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-recentf.el src emacs-lisp :tangle no

*** In-buffer completions
:PROPERTIES:
:CUSTOM_ID: h:86E59081-F057-4B7C-969E-012487A87EDC
:END:

**** Complete anything (company-mode)
:PROPERTIES:
:CUSTOM_ID: h:B8B2DC60-8BF5-4569-AA29-02B335AEFAAD
:END:

The "[[https://company-mode.github.io/][Complete Anything]]" (=company=) package is an extensible text
completion framework which comes with several backends. =company-mode= is
disabled by default. This configuration only enables =company-mode= in
buffers dealing with programming languages. More details on this are
available in the [[#h:8A4237AB-61F5-498A-8E32-390EB783DA37][Programming Language specific support]] section of this
document.

This configures the behavior of =company-mode= itself, such that:

- The completion pop-over will display completion candidates after the point
  has been idle in front of a token after 300ms.
- When the completion pop-over is present, the selection may be changed
  by pressing =C-n= to move the selection to next candidate, or
  =C-p= to move to the previous candidate, in the completion list.
- To choose a completion candidate use =RET= or =C-:=.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'company
  (setq company-idle-delay 0.3)
  (let ((map company-active-map))
    (define-key map (kbd "C-n") #'company-select-next)
    (define-key map (kbd "C-p") #'company-select-previous)
    (define-key map (kbd "C-:") #'company-select-complete))

  (dolist (mode '( text-mode-hook prog-mode-hook ))
    (add-hook mode #'company-mode)))
#+end_src

**** Dabbrev (dynamic word completion)
:PROPERTIES:
:CUSTOM_ID: h:9FBCA9EB-0666-4757-B870-CCB6F8D627C7
:END:

This is Emacs' own approach to dynamic/arbitrary text completion inside
the buffer: "dynamic abbreviation" or else =dabbrev=. This mechanism works
by reading all text before point to find a suitable match. Different
scenaria determine whether it should also look forward and in other
buffers. In essence, Dabbrev helps you re-type what you already have.

With =dabbrev-expand= we make an attempt to complete the text at point.
Repeated invocations will cycle through the candidates. No feedback is
provided, much in the same way yanking from the kill-ring works (though
for Emacs28 =yank-pop= on =M-y= will use completion if the previous command
was not =yank= on =C-y=). To complete a phrase, matching the last successful
=dabbrev-expand=, you need to supply an empty space and call the command
again. This will match the next word, and so on for N words.

Whereas =dabbrev-completion= benefits from minibuffer interactivity and
the pattern matching styles in effect ([[#h:efcb1075-f3de-4a66-b7fd-6f3db1813d64][Completion framework and extras]]).

The =dabbrev-abbrev-char-regexp= is configured to match both regular words
and symbols (e.g. words separated by hyphens). This makes it equally
suitable for code and ordinary language.

While the =dabbrev-abbrev-skip-leading-regexp= is instructed to also
expand words and symbols that start with any of these: =$=, =*=, =/=, ===, =~=, ='=.
This regexp may be expanded in the future, but the idea is to be able to
perform completion in contexts where the known word/symbol is preceded
by a special character. For example, in the =org-mode= version of this
document, all inline code must be placed between the equals sign. So
now typing the ===, then a letter, will still allow me to expand text
based on that input.

To check what I have on regular expressions, see further below my
configurations and documentation for re-builder (regexp-builder).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'dabbrev
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)
  (let ((map global-map))
    (define-key map (kbd "M-/") #'dabbrev-expand)
    (define-key map (kbd "s-/") #'dabbrev-completion)))
#+end_src

**** Skeletons and abbreviations
:PROPERTIES:
:CUSTOM_ID: h:33C1D108-513A-4672-89D8-D99092FBABB4
:END:

This section stores all the "skeletons" I define. These are snippets of
text, typically templates or code statements, that are meant to speed up
typing. While abbreviations are shorter versions of terms that
automatically expand into what they correspond to. I combine skeletons
with abbreviations.

*Please note that these will be very simplistic at first.* I am aware that
they can be abstracted using elisp—need to learn more on that front.
Also note that wherever you see =" _ "= it signifies the position of the
cursor after the skeleton has been inserted.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'abbrev
  (setq abbrev-file-name (locate-user-emacs-file "abbrevs"))
  (setq only-global-abbrevs nil)

  ;;;;;;;;;;;;;;;;;;;;;;
  ;; simple skeletons ;;
  ;;;;;;;;;;;;;;;;;;;;;;
  (define-skeleton indiebrain-com-skeleton
    "Adds a link to my website while prompting for a possible
  extension."
    "Insert website extension: "
    "https://aaronkuehler.com/" str "")
  (define-abbrev global-abbrev-table "meweb"
    "" 'indiebrain-com-skeleton)

  (define-skeleton indiebrain-git-skeleton
    "Adds a link to my GitHub account while prompting for a possible
  extension. Makes it easy to link to my various git repos."
    "Repository name: "
    "https://github.com/indiebrain/" str "")
  (define-abbrev global-abbrev-table "megit"
    "" 'indiebrain-git-skeleton)

  (let ((map global-map))
    (define-key map (kbd "C-x a e") #'expand-abbrev) ; default, just here for visibility
    (define-key map (kbd "C-x a u") #'unexpand-abbrev))
  (add-hook 'text-mode-hook #'abbrev-mode)
  (add-hook 'git-commit-mode-hook #'abbrev-mode))
#+end_src

** Configurations for—or extensions to—built-in search commands
:PROPERTIES:
:CUSTOM_ID: h:F8450875-4A6A-4820-A1F8-EAD091C13AB8
:END:

These enhance the functionality of tools that are already
shipped with Emacs.

*** Isearch, occur, grep, and extras (indiebrain-search.el)
:PROPERTIES:
:CUSTOM_ID: h:B45C2559-C230-44FD-855E-E0C7D99396D9
:END:

The built-in search mechanisms, defined in the libraries =isearch.el= and
=replace.el= are minimal in their presentation, yet powerful in their
applications. There are the main points of entry to the commands they
offer:

- =isearch-forward= (=C-s=) prompts for a string after point and offers live
  feedback on its progress. =isearch-backward= (=C-r=) moves in the opposite
  direction.

  - Two distinct keys may seem redundant at first, but you really
    appreciate this level of precision when recording keyboard macros.

  - Use =C-M-s= and =C-M-r= for running a search against a regular
    expression, or call =isearch-toggle-regexp= (=M-r=) after starting a
    regular isearch.

- =query-replace= (=M-%=) replaces all matches of a string and asks you for
  confirmation on each of them. If you check its help page (press =?=
  after invoking the command), you will learn that =!= stands for an
  affirmative answer to all, which is a standard in all such prompts.

  - =query-replace-regexp= (=C-M-%=) does the same for regular expressions.

- =occur= (=M-s o=) places all matches of a regular expression or string in
  a dedicated buffer. That can function as an index for moving to the
  relevant points in the buffer, but also as a means of refactoring all
  matches at once. Just make the =*Occur*= buffer editable with =e=. Running
  =occur= with a numeric argument provides N lines of context around the
  given match.

The beauty of the Occur and Replace commands is that they can be
initiated from within an active Isearch session, using the same keys.
So =C-s INPUT M-s o= will search for input and then run =occur= on it. Try
=C-h k C-s= to get a help menu with all the extra keys you can use with
=isearch=. These are the ones I use the most:

| Key chord | Description                  |
|-----------+------------------------------|
| C-s C-w   | Search char or word at point |
| M-s .     | Search for symbol at point   |
| M-s o     | Run `occur' on regexp        |
| M-s h r   | Highlight regexp             |
| M-s h u   | Undo the highlight           |
| C-s M-r   | Toggle regexp search         |
| M-%       | Run `query-replace'          |
| C-M-%     | `query-replace-regexp'       |

Every one of the above, except the first item, can be executed on their
own, or as extensions of =C-s= (and variants).

The Occur and Replace operations are aware of the active region, so if
you highlight, say, a paragraph and do =M-%= you will only replace matches
inside of that area (while not relevant to our point, this also works
for =undo= (=C-/=), which is super useful). Though one can achieve pretty
much the same result by leveraging Emacs' narrowing commands, like
=narrow-to-defun= (learn about all of them with =C-x n C-h=)

Now here is a neat trick I discovered a while ago that makes Isearch
even better for most tasks: the ability to interpret a space as a
wildcard. This is due to the combined effect of the values assigned to
the variables =search-whitespace-regexp=, =isearch-lax-whitespace=,
=isearch-regexp-lax-whitespace=. So you can now search for something like
=se di bu al= and it will return =setq display-buffer-alist=. And you can
still combine it with all of the aforementioned! Note that *this affects
regular searches* (the standard =C-s= and =C-r=). The regexp-sensitive
functions =C-M-s= and =C-M-r= remain in tact. You can always toggle
whitespace matching behaviour while performing a search, with =M-s SPC=
(revert back to just literal spaces).

Now on to my =indiebrain-search.el= library which provides some extensions to
an already well-designed architecture (the code is reproduced after the
package configurations).

- =indiebrain-search-isearch-other-end= simply places point at the opposite end
  of the current match. Particularly helpful while recording keyboard
  macros. This is to work around the default behaviour of Isearch which
  puts the point at either the beginning or the end of the match,
  depending on the direction it is moving in. For single words or
  balanced expressions this is not an issue because you can always
  confirm+exit a search by using a motion key (so, for example, move to
  the end of the matching word with =M-f=). There are, however, matches
  that are not limited to such boundaries, especially with the wildcard
  hack mentioned above. For those cases moving to the opposite end
  might require multiple key presses, which is bad when trying to record
  an efficient keyboard macro. Note though that you can achieve the
  same result by changing the direction the search is moving towards
  with =C-s= or =C-r=.

- =indiebrain-search-isearch-abort-dwim= deletes the entirety of the
  non-matching input while leaving the valid parts in place. Otherwise
  it behaves like a standard backward character deletion. The built-in
  method to remove the entirety of a mismatched input is to hit =C-g=
  following a failed search. However, I find that the choice of key
  binding can prove problematic, since =C-g= also exits a successful
  search, while I also prefer a "do-what-I-mean" behavior.

+ =indiebrain-search-isearch-replace-symbol= runs a forward-looking
  =query-replace= for the symbol at point. Simple and effective for
  quickly refactoring a given function/variable name (and one of the
  reasons why I have never needed an extra package for such tasks).

+ =indiebrain-search-isearch-beginning-of-buffer= and its counterpart
  =indiebrain-search-isearch-end-of-buffer= move to the first or last instance
  of the symbol at point. They also accept a numeric argument, which
  they interpret as an offset. In practice, this is the same as running
  =M-s . M-s <= or =M-s . M-s >=.

+ =indiebrain-search-occur-urls= gathers all URLs in the current buffer and
  places them in an Occur buffer /without their context/ while also making
  them clickable (we say that it "buttonises" them).

+ =indiebrain-search-occur-browse-url= gathers all URLs in the buffer and
  prompts you to select one with completion. It then browses that item
  using whatever browser you have for =browse-url-browser-function=.

+ =indiebrain-search-grep= runs a local grep in the current directory. With a
  prefix argument, it runs recursively instead. This is a thin wrapper
  around the built-in =lgrep= and =rgrep= commands: it makes the process
  faster by not asking for a directory and file extension pattern. All
  output is placed in a separate buffer. Note that I also have a
  variant for git-controlled projects: it is =indiebrain-vc-git-grep= from
  [[#h:A852E4F8-426C-4AA1-846E-41204B0D28C4][Version control framework (vc.el and indiebrain-vc.el)]]. Also note that
  Consult provides a live version: refer to the section on consult.el.
  (I normally use Consult and export the results with Embark, except for
  when I know exactly what I am looking for and want it in a buffer, so
  the added features are not needed).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'isearch
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  (define-key minibuffer-local-isearch-map (kbd "M-/") #'isearch-complete-edit)
  (let ((map isearch-mode-map))
    (define-key map (kbd "C-g") #'isearch-cancel) ; instead of `isearch-abort'
    (define-key map (kbd "M-/") #'isearch-complete)))

(indiebrain-emacs-builtin-package 'replace
  (setq list-matching-lines-jump-to-current-line t)
  (add-hook 'occur-mode-hook #'hl-line-mode)
  (add-hook 'occur-mode-hook #'indiebrain-common-truncate-lines-silently) ; from `indiebrain-common.el'
  (define-key global-map (kbd "M-s M-o") #'multi-occur)
  (define-key occur-mode-map (kbd "t") #'toggle-truncate-lines))

(indiebrain-emacs-builtin-package 'grep)

(indiebrain-emacs-builtin-package 'indiebrain-search
  (let ((map global-map))
    (define-key map (kbd "M-s %") #'indiebrain-search-isearch-replace-symbol)
    (define-key map (kbd "M-s M-<") #'indiebrain-search-isearch-beginning-of-buffer)
    (define-key map (kbd "M-s M->") #'indiebrain-search-isearch-end-of-buffer)
    (define-key map (kbd "M-s g") #'indiebrain-search-grep)
    (define-key map (kbd "M-s u") #'indiebrain-search-occur-urls)
    (define-key map (kbd "M-s M-u") #'indiebrain-search-occur-browse-url))
  (let ((map isearch-mode-map))
    (define-key map (kbd "<up>") #'indiebrain-search-isearch-repeat-backward)
    (define-key map (kbd "<down>") #'indiebrain-search-isearch-repeat-forward)
    (define-key map (kbd "<backspace>") #'indiebrain-search-isearch-abort-dwim)
    (define-key map (kbd "<C-return>") #'indiebrain-search-isearch-other-end)))
#+end_src

Here is =indiebrain-search.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-search.el src emacs-lisp :tangle no

*** Test regular expressions (re-builder)
:PROPERTIES:
:CUSTOM_ID: h:1218CF4F-688B-4C12-B877-13BD2AA61DD2
:END:

Emacs offers a built-in tool for testing regular expressions: invoke it
with the =regexp-builder= or =re-builder= command. It pops up a buffer at
the bottom of the current window, which lets you test a regular
expression on the contents of the buffer from where the command was
called. By default, =re-builder= uses Emacs-style notation, where escape
sequences are written as a double backslash. You can switch between the
various styles by using =C-c TAB= inside of the regexp builder's buffer. I
choose to keep this style as the default as it is what I also use when
writing a pattern in some Elisp file.

To learn more about regular expressions, read the relevant pages in the
official manual by evaluating this: =(info "(emacs) Regexps")=. Also
consider watching Prot's ~35 minute-long video [[https://protesilaos.com/codelog/2020-01-23-emacs-regexp-primer/][primer on Emacs regexp]]
(2020-01-23). If you actually need to do a regexp-aware query and
replace operation that performs an arbitrary elisp function on a group
check Prot's article on how to use [[https://protesilaos.com/codelog/2021-03-03-emacs-query-replace-downcase/][query-replace-regexp to downcase
matches]] (2021-03-03). Remember that you can always get interactivity by
first using something like =isearch-forward-regexp= and then switching to
the =query-replace= operation with =M-%= (in this case, =query-replace=
automatically becomes regexp-aware).

Also check: [[#h:B45C2559-C230-44FD-855E-E0C7D99396D9][Isearch, occur, grep, and extras (indiebrain-search.el)]].

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 're-builder
  (setq reb-re-syntax 'read))
#+end_src

*** wgrep (writable grep)
:PROPERTIES:
:CUSTOM_ID: h:8B7E1B4C-D129-4F7E-A4AB-DEF5531C9F9C
:END:

With =wgrep= we can directly edit the results of a =grep= and save the
changes to all affected buffers. In principle, this is the same as what
the built-in =occur= offers. We can use it to operate on a list of matches
by leveraging the full power of Emacs' editing capabilities (e.g.
keyboard macros, query and replace a regexp...).

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'wgrep
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  (let ((map grep-mode-map))
    (define-key map (kbd "e") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-x C-q") #'wgrep-change-to-wgrep-mode)
    (define-key map (kbd "C-c C-c") #'wgrep-finish-edit)))
#+end_src

*** Cross-references (xref.el)
:PROPERTIES:
:CUSTOM_ID: h:1E1AE04E-36E1-42EF-BCA5-C7AEFB6ACEDE
:END:

Xref provides helpful commands for code navigation and discovery, such
as =xref-find-definitions= (=M-.=) and its counterpart =xref-pop-marker-stack=
(=M-,=). It is a library that gets used by a variety of tools, including
=project.el= (see [[#h:E5EAE6EE-BF12-4903-81BE-081372C046EB][Projects (project.el and indiebrain-project.el)]]).

Here are just the basics.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'xref
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ; for M-.
  (setq xref-show-xrefs-function #'xref-show-definitions-buffer) ; for grep and the like
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'ripgrep))
#+end_src

**** Mode-specific new buffer templates (autoinsert and indiebrain-autoinsert.el)
:PROPERTIES:
:CUSTOM_ID: h:257EEAC8-6E60-4C53-8F08-452E6AF4AA59
:END:

The builtin =autoinsert= library provides the ability to define structured
templates for the initial content of new buffers based on their major
mode. This is useful when dealing with highly structured code files -
such as my custom emacs-lisp files in =~/.emacs.d/indiebrain-lisp=. When I
create a new emacs-lisp library (=.el= file) =autoinsert= will fillin the
boilerplate metdata comments. =autoinsert= map a file suffix pattern or
major mode name to a teplate - these are referred to a the "condition"
and "action" repesectively. The "action" or tempalte is defined using
the builtin skeleton language (see =C-h f skeleton-insert=). The list
of automatic text insertions is maintained in =auto-insert-alist= a few -
useful to me - insertions are provided by default (namely the emacs-lisp
insertion).

However, I work with a varitey of langages and tools for which no
default insertions are defined. The =indiebrain-autoinsert.el= library -
reproduced below defines my custom insertions. My custom insertions are
collated into the =indiebrain-autoinsert-auto-insert-lists= and registerd
with =autoinsert= via the =indiebrain-autoinsert-register-insertions=
function.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'autoinsert
  (auto-insert-mode t)
  (setq auto-insert-query nil))

(indiebrain-emacs-builtin-package 'indiebrain-autoinsert
  (indiebrain-autoinsert-register-insertions))
#+end_src

Those are the contents of the =indiebrain-autoinsert.el= library (find the file in [[https://github.com/indiebrain/.files][my
dotfiles' repo)]]:

#+include: indiebrain-lisp/indiebrain-autoinsert.el src emacs-lisp :tangle no

* Directory, buffer, window management
:PROPERTIES:
:CUSTOM_ID: h:3b94740d-e1ce-4016-991c-4fa35b76a719
:END:
** Dired (directory editor, file manager)
:PROPERTIES:
:CUSTOM_ID: h:2591A95A-FC9F-40DA-9E24-A327A453606D
:END:

The directory editor abbreviated as "Dired" (which I pronounce like
"tired", "mired", etc.) is a built-in tool that performs file management
operations inside of an Emacs buffer. It is simply superb!  I use it
daily for a number of tasks.

You can interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run shell
commands, combine Dired with regular editing capabilities as part of a
keyboard macro, search[+replace] across multiple files, encrypt/decrypt
files, and more. Combine that with the possibility of matching items
with regular expressions, such as for marking items or narrowing the
list, or creating an editable Dired buffer and you have everything you
need to maximise your productivity.

Check some of Prot's dired focused videos:

- [[https://protesilaos.com/codelog/2019-08-12-emacs-dired-tweaks/][Dired tweaks and refinements]] (2019-08-12).
- [[https://protesilaos.com/codelog/2019-09-03-emacs-dired-macros/][Use Dired and keyboard macros]] (2019-09-03).
- [[https://protesilaos.com/codelog/2019-09-19-dired-narrow/][Techniques to narrow Dired]] (2019-09-19).
- [[https://protesilaos.com/codelog/2019-11-16-emacs-dired-chmod/][Change multi-file permissions with Dired]] (2019-11-16).
- [[https://protesilaos.com/codelog/2019-11-13-emacs-bongo-music/][Music management with Dired and Bongo]] (2019-11-13).
- [[https://protesilaos.com/codelog/2019-11-18-emacs-dired-bongo/][Dired+Bongo and macros to handle music playlists]] (2019-11-18).
- [[https://protesilaos.com/codelog/2019-12-08-emacs-multi-replace/][Search and replace across multiple files (not Dired-specific)]] (2019-12-08).

The following package configurations are fairly comprehensive. First an
overview of the options I specify:

- Copy and delete recursively. No need to be prompted about each action.

- While in detailed view, search only file names when point is on one of
  them, else apply the query to all the rest.

- Deletion sends items to the system's Trash, making it safer than the
  standard =rm=. The trash can be a life-saver, as it lets you restore
  deleted files (check: dired-like mode for the trash (trashed.el)).

- Reformat output. Sort directories first. Show dotfiles and place them
  before anything else. Omit implicit directories (the single and double
  dots). Use human-readable size units. To learn everything about these
  switches, you need to read the manpage of =ls=. You can do so with =M-x
  man RET ls= or =M-x woman=.

  - Note that =dired-listing-switches= and =find-ls-option= are configured
    to show hidden directories and files /before/ their non-hidden
    counterparts. If you want to reverse this order, you must include
    the =-X= option (such as =-AFXhlv --group-directories-first=).

- Hide all the details by default (permissions, size, etc.). Those can
  easily be toggled on with the left parenthesis. Also enable
  highlighting of the current line (=hl-line-mode=), which makes it even
  easier to spot the current item (I do not enable this globally,
  because I only want it for line-oriented interfaces, such as Dired's,
  but not for text editing).

- While having two dired buffers open, the rename and copy operations
  will place the path of the inactive one as the target destination.
  When multiple dired buffers are present, this works between the
  current and most recently used ones.

- For Emacs 27.1 or higher, Dired can automatically create destination
  directories for its copy and rename operations. So you can, for
  example, move (copy or rename) =file= to =/non-existent-path/file= and you
  will get what you want right away.

- For Emacs 27.1 or higher, renaming a file of a version-controlled
  repository (git) will be done using the appropriate VC mechanism. This
  is to ensure that file name changes are tracked correctly (also check:
  Version control framework (vc.el and indiebrainvc.el)).

- The commands with the =contrib/= prefix in =dired-aux= are copied from the
  [[https://github.com/oantolin/emacs-config][Emacs configurations of Omar Antolín Camarena]]. They let you insert the
  path of a bookmarked directory while facing a =find-file= or =dired=
  minibuffer prompt. This is useful when you are performing an action
  such as copying or renaming a file, with the desired destination being
  the bookmark of choice.

And here are a few words about the more specialised parts of the Dired
ecosystem:

- Dired subtree :: This third-party package offers tree-style
  navigation, meaning that the subdirectories of the current Dired
  buffer can be expanded and contracted in place. It is possible to
  perform the same kind of folding on their subdirectories, and so on.

  This is, in my opinion, a far more intuitive interaction than the
  default way of inserting subdirectories in the current buffer below
  their parent (type =i= over the target dir). There still are uses for
  that technique (and quite powerful at that), but tree-style navigation
  is easier for day-to-day tasks, especially when all you want is a
  quick peek at a directory's contents.

- Dired extras (dired-x) :: These are some additional features that are
  shipped with Emacs. The one I need the most is =dired-jump= and its
  "other window" variant. These are among my favourite commands. They
  will always take you to the directory that contains the current
  buffer. (Note for Emacs 28 users: =dired-jump= is now part of the main
  Dired library).

  'Jumping' works even when you are inside buffers that do not visit
  files, such as Magit, Diff, or Eshell: it just takes you to the
  =default-directory= or its parent. This is its most valuable quality!
  Edit a file then proceed to do some file management, then invoke
  =previous-buffer= or =winner-undo= to go back to where you were (I have a
  few key bindings for those in the Window configuration section).
  Everything happens naturally. Emacs' interconnectedness at its best!

  The other neat features of =dired-x= are (1) its ability to open Info
  files in place (=dired-info= command, bound to =I=), and (2) to open all
  marked files at once (=dired-do-find-marked-files= bound to =F= by
  default).

- Writable Dired (wdired) :: This is the standard editable state of a
  dired buffer. You can access it with =C-x C-q=. Write changes to files
  or directories, as if it were a regular buffer, then confirm them with
  =C-c C-c=. This practically means that you can rename files and change
  permissions (when the detailed list is available). Note that while
  renaming a file, any forward slash is treated like a directory and *is
  created directly* upon successful exit. Combine this utility with
  keyboard macros, rectangle edits, or =query-replace= and you have one
  supremely powerful tool at your disposal.

- Image dired :: This built-in library offers facilities for generating
  thumbnails out of a selection of images and displaying them in a
  separate buffer. An external program is needed to convert the images
  into thumbnails: =imagemagick=. Other useful external packages are
  =optipng= and =sxiv=. The former is for operating on PNG files, while the
  latter is a lightweight image viewer. I feel this process is a bit
  cumbersome and can be very slow if you try to generate lots of images
  at once. The culprit is the image converter. As such, only use this
  for smaller collections. Besides, Emacs can open an image in a buffer
  and that works well for viewing individual items.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'dired
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
    "-AGFhlv")
  (setq dired-dwim-target t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p) ; also see `dired-do-revert-buffer'

  ;; (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode))

(indiebrain-emacs-builtin-package 'dired-aux
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)
  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))

  ;; Those two functions are copied from the Emacs config of Omar
  ;; Antolín Camarena: <https://github.com/oantolin/emacs-config>.
  (defun contrib/cdb--bookmarked-directories ()
    (bookmark-maybe-load-default-file)
    (cl-loop for (name . props) in bookmark-alist
         for fn = (cdr (assq 'filename props))
         when (and fn (string-suffix-p "/" fn))
         collect (cons name fn)))

  (defun contrib/cd-bookmark (bm)
    "Insert the path of a bookmarked directory."
    (interactive
     (list (let ((enable-recursive-minibuffers t))
         (completing-read
          "Directory: " (contrib/cdb--bookmarked-directories) nil t))))
    (when (minibufferp)
      (delete-region (minibuffer-prompt-end) (point-max)))
    (insert (cdr (assoc bm (contrib/cdb--bookmarked-directories)))))

  (let ((map dired-mode-map))
    (define-key map (kbd "C-+") #'dired-create-empty-file)
    (define-key map (kbd "M-s f") #'nil)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action)) ; Emacs 28
  (define-key minibuffer-local-filename-completion-map (kbd "C-c d") #'contrib/cd-bookmark))

;; ;; NOTE 2021-05-10: I do not use `find-dired' and related commands
;; ;; because there are other tools that offer a better interface, such
;; ;; as `consult-find', `consult-grep', `project-find-file',
;; ;; `project-find-regexp', `indiebrain-vc-git-grep'.
;; (indiebrain-emacs-builtin-package 'find-dired
;;   (setq find-ls-option
;;         '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
;;   (setq find-name-arg "-iname"))

(indiebrain-emacs-builtin-package 'indiebrain-dired
 (let ((map dired-mode-map))
   (define-key map (kbd "M-n") #'indiebrain-dired-subdirectory-next)
   (define-key map (kbd "C-c C-n") #'indiebrain-dired-subdirectory-next)
   (define-key map (kbd "M-p") #'indiebrain-dired-subdirectory-previous)
   (define-key map (kbd "C-c C-p") #'indiebrain-dired-subdirectory-next)))

(indiebrain-emacs-builtin-package 'dired-x
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  (let ((map global-map))
    (define-key map (kbd "C-x C-j") #'dired-jump)
    (define-key map (kbd "s-j") #'dired-jump)
    (define-key map (kbd "C-x 4 C-j") #'dired-jump-other-window)
    (define-key map (kbd "s-J") #'dired-jump-other-window))
  (define-key dired-mode-map (kbd "I") #'dired-info))

(indiebrain-emacs-elpa-package 'dired-subtree
  (setq dired-subtree-use-backgrounds nil)
  (let ((map dired-mode-map))
    (define-key map (kbd "<tab>") #'dired-subtree-toggle)
    (define-key map (kbd "<C-tab>") #'dired-subtree-cycle)
    (define-key map (kbd "<backtab>") #'dired-subtree-remove))) ; S-TAB

(indiebrain-emacs-builtin-package 'wdired
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(indiebrain-emacs-builtin-package 'image-dired
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  (define-key image-dired-thumbnail-mode-map
    (kbd "<return>") #'image-dired-thumbnail-display-external))
#+end_src

These are the contents of =indiebrain-dired.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-dired.el src emacs-lisp :tangle no

*** dired-like mode for the trash (trashed.el)
:PROPERTIES:
:CUSTOM_ID: h:FFF4BBA4-13D3-444E-818E-BED4772FD4A0
:END:

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash. Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked. Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'trashed
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

** Working with buffers
:PROPERTIES:
:CUSTOM_ID: h:3911977F-D9EC-4282-A904-EE88545395A4
:END:

*** Keymap for buffers (Emacs28)
:PROPERTIES:
:CUSTOM_ID: h:7A29FFA7-9889-4EF0-B197-89CF4468471F
:END:

Starting with Emacs version 28, there is a keymap that can be accessed
with the =C-x x= sequence. This new keymap (=ctl-x-x-map=), is meant to be
used for commands that pertain to the current buffer. What I have here
are just some tweaks to make it work the way I prefer.

#+begin_src emacs-lisp
(let ((map ctl-x-x-map))              ; Emacs 28
  (define-key map "e" #'eval-buffer)
  (define-key map "f" #'follow-mode)  ; override `font-lock-update'
  (define-key map "r" #'rename-uniquely))

(with-eval-after-load 'org
  (define-key ctl-x-x-map "i" #'contrib/org-id-headlines)
  (define-key ctl-x-x-map "h" #'indiebrain/ox-html))
#+end_src

*** Unique names for buffers
:PROPERTIES:
:CUSTOM_ID: h:5D0FA19F-1495-4722-9E89-781FF9C0C875
:END:

These settings make it easier to work with multiple buffers. When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their element of differentiation in accordance with the style
of =uniquify-buffer-name-style=. While =uniquify-strip-common-suffix= will
remove the part of the file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'uniquify
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

*** Ibuffer and extras (dired-like buffer list manager)
:PROPERTIES:
:CUSTOM_ID: h:12B23861-390B-49AD-8BDA-3609F5CE7EAA
:END:

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=. Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall. For this
reason I bind it to =C-x C-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:2591A95A-FC9F-40DA-9E24-A327A453606D][Dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= or =query-replace-regexp= on marked buffers.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package configurations, these are my tweaks
to the default behaviour and presentation:

- Prompt for confirmation only when deleting a modified buffer.
- Hide the summary.
- Do not open on the other window; use the current one.
- Do not show empty filter groups.
- Do not cycle movements. So do not go to the top when moving downward
  at the last item on the list.

The =indiebrain-ibuffer.el= library contains the following enhancements
(copied in its entirety below the package configurations):

- =indiebrain-ibuffer-buffers-major-mode= produces a filtered list of buffers
  that match the major mode of the current buffer and lets you pick one
  using minibuffer completion. With an optional prefix argument (=C-u=)
  it places the results in an Ibuffer list.

- =indiebrain-ibuffer-buffers-vc-root= filters the list to items that
  match the current buffer's version-controlled directory. In practice,
  this fills the same niche as the built-in =project-switch-to-buffer=
  (for Emacs 28+), with the crucial difference that it neither reads
  from nor writes to the list of known projects (also check my
  configurations for [[#h:E5EAE6EE-BF12-4903-81BE-081372C046EB][Projects (project.el and indiebrain-project.el)]]).
  When called with an optional prefix argument, this command puts its
  matching candidates in an Ibuffer view.

This method informs other tools that this type of completion
pertains to buffers, so they can adapt accordingly. See, in particular,
[[#h:E4A448DA-159D-4BDB-AE29-1118088EFE9D][Extended minibuffer actions and more (embark.el and indiebrain-embark.el)]].

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'ibuffer
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
    '((mark modified read-only locked " "
        (name 40 40 :left :elide)
        " "
        (size 9 -1 :right)
        " "
        (mode 16 16 :left :elide)
        " " filename-and-process)
      (mark " "
        (name 16 -1)
        " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook #'hl-line-mode)
  (define-key global-map (kbd "C-x C-b") #'ibuffer)
  (let ((map ibuffer-mode-map))
    (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
    (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
    (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
    (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
    (define-key map (kbd "/ g") #'ibuffer-filter-by-content)))

(indiebrain-emacs-builtin-package 'indiebrain-ibuffer
  (let ((map global-map))
    (define-key map (kbd "M-s b") #'indiebrain-ibuffer-buffers-major-mode)
    (define-key map (kbd "M-s v") #'indiebrain-ibuffer-buffers-vc-root)))
#+end_src

Here is =indiebrain-ibuffer.el= (find everything in [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-ibuffer.el src emacs-lisp :tangle no

*** Scratch buffers per-major-mode
:PROPERTIES:
:CUSTOM_ID: h:5F13EFA3-5714-4E20-91ED-1945E6F8B8CF
:END:

This package will produce a buffer that matches the major mode of the
one you are currently in. Use it with =M-x scratch=. Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead. Simple yet
super effective!

The =indiebrain/scratch-buffer-setup= simply adds some text in the buffer
and renames it appropriately for the sake of easier discovery. I got the
idea of copying the region from [[https://gist.github.com/eev2/52edbfdb645e26aefec19226c0ca7ad0][a snippet shared by eev2 on GitHub]].

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'scratch
  ;; TODO 2021-01-19: refine `indiebrain/scratch-buffer-setup'
  (defun indiebrain/scratch-buffer-setup ()
    "Add contents to `scratch' buffer and name it accordingly.
If region is active, add its contents to the new buffer."
    (let* ((mode major-mode)
       (string (format "Scratch buffer for: %s\n\n" mode))
       (region (with-current-buffer (current-buffer)
             (if (region-active-p)
             (buffer-substring-no-properties
              (region-beginning)
              (region-end)))
             ""))
       (text (concat string region)))
      (when scratch-buffer
    (save-excursion
      (insert text)
      (goto-char (point-min))
      (comment-region (point-at-bol) (point-at-eol)))
    (forward-line 2))
      (rename-buffer (format "*Scratch for %s*" mode) t)))
  (add-hook 'scratch-create-buffer-hook #'indiebrain/scratch-buffer-setup)
  (define-key global-map (kbd "C-c s") #'scratch))
#+end_src

** Window configuration
:PROPERTIES:
:CUSTOM_ID: h:D03674C2-AA9C-4B01-85A1-FE179C594224
:END:

Emacs' true power lies in its buffer management rather than its
multiplexing. The latter becomes inefficient at scale, since it tries to
emulate the limitations of the real world, namely, the placement of
things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item. There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

Granted, Emacs' multiplexing can be turned into a powerhouse as well,
covering everything from window placement rules, to the recording of
history and layouts, as well as directional or direct window navigation.

*** Window rules and basic tweaks (window.el)
:PROPERTIES:
:CUSTOM_ID: h:7409C6BD-FF1B-41CF-9483-D24E94933683
:END:

The =display-buffer-alist= is intended as a rule-set for controlling the
placement of windows. This is mostly needed for ancillary buffers, such
as shells, compilation output, and the like. The objective is to create
a more intuitive workflow where targeted buffer groups or types are
always shown at a given location, on the premise that predictability
improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window. These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
GNU Emacs Lisp Reference Manual (evaluate =(elisp) Displaying Buffers=).
Information can also be found at all times via =C-h f display-buffer= and,
for my particular settings, with =C-h f display-buffer-in-side-window=.

With regard to the key bindings you will find here, most combinations
are complementary to the standard ones, such as =C-x 1= being aliased as
=s-1=, =C-x o= turning into =s-o= and the like. They *do not replace* the
defaults: they just provide more convenient access to their
corresponding functions. Some involve the Super key, in accordance with
the norms described in the relevant note on the matter. Concerning the
=balance-windows-area= I find that it is less intrusive than the original
=balance-windows= normally bound to the same =C-x +=. Lastly, the
=resize-window-repeat-map= is for repeatable key chords that work with the
=repeat-mode= for Emacs28 (read my description of what it is and how to
set it up: [[#h:644E0EDA-B4FD-44EA-80D0-ACE2CC78C50B][Repeatable key chords (repeat-mode)]]).

Make sure to also review the other window-related keys in those
sections:

- [[#h:AA35C6B8-E21A-486B-A008-59CCC2894237][Window history (winner-mode)]].
- [[#h:16C42FC0-5A1E-4E76-B84F-E5314E54CD0E][Directional window motions (windmove)]].

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch Prot's [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07)

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'window
  (setq display-buffer-alist
    `(;; top side window
      ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
       (display-buffer-in-side-window)
       (window-height . 0.16)
       (side . top)
       (slot . 0))
      ("\\*Messages.*"
       (display-buffer-in-side-window)
       (window-height . 0.16)
       (side . top)
       (slot . 1))
      ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
       (display-buffer-in-side-window)
       (window-height . 0.16)
       (side . top)
       (slot . 2)
       (window-parameters . ((no-other-window . t))))
      ;; bottom side window
      ("\\*\\(Embark\\)?.*Completions.*"
       (display-buffer-in-side-window)
       (side . bottom)
       (slot . 0)
       (window-parameters . ((no-other-window . t)
                 (mode-line-format . none))))
      ;; left side window
      ("\\*Help.*"
       (display-buffer-in-side-window)
       (window-width . 0.20)       ; See the :hook
       (side . left)
       (slot . 0))
      ;; right side window
      ("\\*keycast\\*"
       (display-buffer-in-side-window)
       (dedicated . t)
       (window-width . 0.25)
       (side . right)
       (slot . -1)
       (window-parameters . ((no-other-window . t)
                 (mode-line-format . none))))
      ("\\*Faces\\*"
       (display-buffer-in-side-window)
       (window-width . 0.25)
       (side . right)
       (slot . 0))
      ("\\*Custom.*"
       (display-buffer-in-side-window)
       (window-width . 0.25)
       (side . right)
       (slot . 1))
      ;; bottom buffer (NOT side window)
      ("\\*\\vc-\\(incoming\\|outgoing\\).*"
       (display-buffer-at-bottom))
      ("\\*\\(Output\\|Register Preview\\).*"
       (display-buffer-at-bottom))
      ("\\*.*\\(e?shell\\|v?term\\).*"
       (display-buffer-reuse-mode-window display-buffer-at-bottom)
       (window-height . 0.2))
      ;; below current window
      ("\\*Calendar.*"
       (display-buffer-reuse-mode-window display-buffer-below-selected)
       (window-height . shrink-window-if-larger-than-buffer))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)
  (let ((map global-map))
    (define-key map (kbd "s-n") #'next-buffer)
    (define-key map (kbd "s-p") #'previous-buffer)
    (define-key map (kbd "s-o") #'other-window)
    (define-key map (kbd "s-2") #'split-window-below)
    (define-key map (kbd "s-3") #'split-window-right)
    (define-key map (kbd "s-0") #'delete-window)
    (define-key map (kbd "s-1") #'delete-other-windows)
    (define-key map (kbd "s-!") #'delete-other-windows-vertically) ; s-S-1
    (define-key map (kbd "s-5") #'delete-frame)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "s-q") #'window-toggle-side-windows)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'
  (let ((map resize-window-repeat-map))
    (define-key map ">" #'enlarge-window-horizontally)
    (define-key map "<" #'shrink-window-horizontally)))
#+end_src

*** Window history (winner-mode)
:PROPERTIES:
:CUSTOM_ID: h:AA35C6B8-E21A-486B-A008-59CCC2894237
:END:

Winner is a built-in tool that keeps a record of buffer and window
layout changes. It then allows us to move back and forth in the
history of said changes. I have it enabled by default, while I assign
its two main functions to Super and the right/left arrow keys.

Also check: [[#h:16C42FC0-5A1E-4E76-B84F-E5314E54CD0E][Directional window motions (windmove)]].

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'winner
  (add-hook 'after-init-hook #'winner-mode)
  (let ((map global-map))
    (define-key map (kbd "<M-s-right>") #'winner-redo)
    (define-key map (kbd "<M-s-left>") #'winner-undo)))
#+end_src

*** Directional window motions (windmove)
:PROPERTIES:
:CUSTOM_ID: h:16C42FC0-5A1E-4E76-B84F-E5314E54CD0E
:END:

Windmove is also built into Emacs. It provides functions for selecting a
window in any of the cardinal directions: a decent addition to the
simpler =other-window= command (=C-x o= by default). It also has commands
for deleting a window in the given direction as well as for switching
the current window with the one in the given direction. I do not need
the directional deletion motions, as they require extra key bindings
while I feel that it is easy enough to select a window and delete it
outright with =delete-window= (on =C-x 0= by default).

The =windmove-create-window= variable specifies what should happen when
trying to move past the edge of the frame. The idea with this is to
allow it to create a new window with the contents of the current buffer.
I tried it for a while but felt that the times it would interfere with
my layout by mistake where more than those it would actually speed up my
workflow.

Also read: [[#h:AA35C6B8-E21A-486B-A008-59CCC2894237][Window history (winner-mode)]].

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'windmove
  (setq windmove-create-window nil)     ; Emacs 27.1
  (let ((map global-map))
    (define-key map (kbd "<s-up>") #'windmove-up)
    (define-key map (kbd "<s-right>") #'windmove-right)
    (define-key map (kbd "<s-down>") #'windmove-down)
    (define-key map (kbd "<s-left>") #'windmove-left)
    (define-key map (kbd "<S-s-up>") #'windmove-swap-states-up)
    (define-key map (kbd "<S-s-right>") #'windmove-swap-states-right)
    (define-key map (kbd "<S-s-down>") #'windmove-swap-states-down)
    (define-key map (kbd "<S-s-left>") #'windmove-swap-states-left)))
#+end_src

*** Tabs for window layouts (and indiebrain-tab.el)
:PROPERTIES:
:CUSTOM_ID: h:15E74AF3-8988-47F1-BACC-4A90881114E0
:END:

Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers. Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale. Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:12B23861-390B-49AD-8BDA-3609F5CE7EAA][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organizing the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on. Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register).

For me tabs are useful as groups of buffers in a given window
configuration. I do not want a persistent bar with buttons that
introduces extra visual clutter. Switching to tabs is done through
completion, specifically =indiebrain-tab-select-tab-dwim=.

All settings I configure here are meant to work in accordance with this
abstract conception of "tabs are work spaces". Here are the main key
chords for =tab-bar= (they will all work properly if you keep the mode
active):

| Key     | Description                    |
|---------+--------------------------------|
| C-x t b | Open a buffer in a new tab     |
| C-x t d | Open a directory in a new tab  |
| C-x t f | Open a file in a new tab       |
| C-x t 0 | Close current tab              |
| C-x t 1 | Close all other tabs           |
| C-x t 2 | Open current buffer in new tab |

These are consistent with the standard commands for handling windows and
accessing buffers/files in the "other window" (the =C-x 4 KEY= pattern).
There is also a command for giving a name to the current tab, accessed
via =C-x t r=, though I find I do not use it.

Here my settings, followed by the entirety of =indiebrain-tab.el=.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'tab-bar
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-current)
  (setq tab-bar-format                  ; Emacs 28
    '(tab-bar-format-tabs
      tab-bar-separator
      tab-bar-format-align-right
      tab-bar-format-global))
  (tab-bar-mode -1)
  (tab-bar-history-mode -1)
  (let ((map global-map))
    (define-key map (kbd "C-x t n") #'tab-next)
    (define-key map (kbd "C-x t p") #'tab-previous)))

(indiebrain-emacs-builtin-package 'indiebrain-tab
  (let ((map global-map))
    (define-key map (kbd "<f8>") #'indiebrain-tab-tab-bar-toggle)
    (define-key map (kbd "C-x t t") #'indiebrain-tab-select-tab-dwim)
    (define-key map (kbd "s-t") #'indiebrain-tab-select-tab-dwim)))

;; ;; This is only included as a reference.
;; (indiebrain-emacs-builtin-package 'tab-line
;;   (global-tab-line-mode -1))
#+end_src

The =indiebrain-tab.el= code, which is in [[https://github.com/indiebrain/.files/][my dotfiles' repo]]:

#+include: indiebrain-lisp/indiebrain-tab.el src emacs-lisp :tangle no

**** Tab-bar tabs in the echo area (tab-bar-echo-area.el)
:PROPERTIES:
:CUSTOM_ID: h:DF768012-CA76-4F04-ABB4-C427CEFBAFB7
:END:

In the previous section on [[15e][Tabs for window layouts (and
indiebrain-tab.el)]], I explicitly disable the presentation of the tab
bar, even though I still use its functionality. This keeps the overall
aesthetics minimalist, which I like. The problem with such a
configuration is that we lose context: it is no longer possible to
determine the number of open tabs nor understand the position of the
current one in the list.

This is where Fritz Grabo's =tab-bar-echo-area.el= enters the fray: it
prints a message in the echo area showing the tab list, while it
highlights the current item. So we can retain both our minimalism and
the contextuality a bar offers. Simple, yet super effective!

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'tab-bar-echo-area
  (tab-bar-echo-area-mode 1))
#+end_src

**** Tab bar groups
:PROPERTIES:
:CUSTOM_ID: h:1BB2CBCE-E8D8-4F90-A41A-A257B8D0CBC7
:END:

Fritz Grabo, author of the wonderfully minimalist =tab-bar-echo-area=
(read section on [[#h:DF768012-CA76-4F04-ABB4-C427CEFBAFB7][Tab-bar tabs in the echo area (tab-bar-echo-area.el)]]),
has another neat package for grouping tabs using colour-coded labels.
Such functionality exists for Emacs28, which is the version I am
running, though Fritz's library currently has the advantage of applying
unique colours to each group.

Grouping helps me maintain a longer list of tabs without losing my sense
of place. This is particularly useful to my workflow when I need to keep
several tabs open that pertain to different topics.

It is possible to integrate those tab groups with the presentation of
=tab-bar-echo-area-mode=, by evaluating the helper function
=tab-bar-groups-activate-for-tab-bar-echo-area=. I prefer not to do that
because when I need to use groups, I am also likely to maintain several
open tabs in which case it is easier to keep the tab-bar visible at all
times (I toggle it on with =indiebrain-tab-tab-bar-toggle=).

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'tab-bar-groups
  (tab-bar-groups-activate)

  (let ((map tab-prefix-map))           ; the prefix is C-x t
    (define-key map (kbd "g 0") #'tab-bar-groups-close-group)
    (define-key map (kbd "g 2") #'tab-bar-groups-new-tab)
    (define-key map (kbd "g a") #'tab-bar-groups-assign-group)
    (define-key map (kbd "g g") #'tab-bar-groups-regroup-tabs)
    (define-key map (kbd "g d") #'tab-bar-groups-duplicate-tab)
    (define-key map (kbd "g e") #'tab-bar-groups-eject-tab)
    (define-key map (kbd "g r") #'tab-bar-groups-rename-group)))
#+end_src
*** Transposition and rotation of windows
:PROPERTIES:
:CUSTOM_ID: h:2190784A-A383-4991-B2F0-8980EA811254
:END:

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows. Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code. Do it with =M-x find-library transpose-frame=.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'transpose-frame
  (let ((map global-map))
    (define-key map (kbd "C-s-t") #'flop-frame) ; what I consider "transpose" in this context
    (define-key map (kbd "C-s-r") #'rotate-frame-clockwise)))
#+end_src
** Frame management
:PROPERTIES:
:CUSTOM_ID: h:F3B6698D-D3F0-4ACC-8AE0-84D5EF2874E3
:END:

The closest analogy to an Emacs "Frame" is what modern desktop
environments call a "window." I usually intend to run Emacs in a single
frame and use its built in window and buffer management systems to
manage my workflow. The only real functionality related to Emacs frames
that I like to expose is the ability to toggle the frame in/out of
full-screen mode. By default, this functionality is bound to the =[f11]=
key, however MacOS - which I use primarily for work (See more in [[#h:21C6323F-F376-450D-881F-6134998D3236][What is
your distro and/or window manager?]]) - map the =[f11]= key to some OS
functionality which I never desire (and have no idea how to disable
this.). So, as a work around, I redefine the =[f12]= key to toggle Emacs
frames into full-screen mode.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'frame
  (let ((map global-map))
    (define-key map [f12] #'toggle-frame-fullscreen)))
#+end_src

* Applications and utilities
:PROPERTIES:
:CUSTOM_ID: h:a927f3be-91fb-4ad7-a45e-48980a3b7941
:END:

Here we find configuration which extends Emacs to perform the role of
what would normally be considered the realm of a standalone
application - Calendars, TODO management, etc. This section is expected
to grow as I move more of my computing and workflow into the care of
Emacs.

** Custom extensions for "focus mode" (indiebrain-logos.el)
:PROPERTIES:
:CUSTOM_ID: h:DE9C418F-0C2D-4C3B-A4DF-AFE8BE0AB8BA
:END:

My =indiebrain-logos.el= (copied verbatim after the package configurations)
provides the necessary infrastructure for my preferred "focus mode"
aesthetic. Everything is controlled by =indiebrain-logos-focus-mode=. Bind that
to a key and you are good to go. An overview of its components, which
are contingent on other features:

- Olivetti (centred buffer content) :: I spend much of my time in Emacs
  reading and writing long form texts. It is nice to be able to easily
  toggle a mode that centres the buffer, allowing for greater comfort.
  Olivetti covers that niche very nicely. It is not aggressive in its
  requirements, which is important to play well with my paragraph and
  fill-mode settings ([[#h:FD38C107-0C54-4685-ADD2-7692C360EC9A][Paragraphs and fill-mode (indiebrain-fill.el)]]): it
  respects my existing line length and my preference for auto-filling
  text, while it does not introduce any kind of functionality beyond the
  scope of bringing the current window's buffer to the centre of the
  view. This is exactly what I need. Any other enhancement, such as a
  larger font size can be delegated to a specialised instrument. Thanks
  to Paul W. Rankin for providing such a nimble tool! For
  =indiebrain-logos= Olivetti always gets activated.

- =variable-pitch-mode= (mixed fonts) :: This is a built-in mode that
  remaps the =default= face's font family to a proportionately spaced one
  (also see [[#h:8C74519F-4C17-4E61-8D35-E5AA89F37C6C][Font configurations (indiebrain-fonts.el)]]). It can produce a
  prose-friendly presentation, especially if the =variable-pitch= face is
  set to some nice font family. As the effect is not particularly good
  in =prog-mode= buffers, due to misalignments in spacing and indentation,
  =indiebrain-logos= only applies variable width fonts in =text-mode=
  buffers. The activation is further controlled by
  =indiebrain-logos-variable-pitch= (off by default). Bear in mind that
  =variable-pitch-mode= is quite aggressive in its application, as it
  affects all other faces, unless the active theme (or some minor mode)
  makes provisions to retain fixed typographic spacing for those
  elements that require it, such as code blocks and inline code
  elements, tables, and indentation.

- =org-tree-slide= and =org-indent= :: The former is a third-party package
  and the latter is part of the Org distribution. What the first does
  is convert headings into pseudo slides. While the other indents
  content visually, without actually affecting the underlying initial
  spacing, to match the heading's depth. Those two are disabled by
  default and the =indiebrain-logos-org-presentation= toggle determines whether
  they should be activated.

- Scroll lock :: Sometimes you want the cursor to remain centred on the
  screen while your focus is on writing or reading. This is controlled
  by the variable =indiebrain-logos-scroll-lock= (off by default), which
  controls the activation of the built-in =scroll-lock-mode=.

- Modeline :: The variable =indiebrain-logos-hidden-modeline= (off by default)
  can be set to =t= to hide the modeline while entering the focused state.
  For me this is mostly useful for presentations.

- Fringes :: There is also a function that unconditionally disables
  fringes on the edge of the window. It ensures that we do not see that
  area and any indicators that may be placed on it while entering the
  focus state (refer to [[#h:C1565484-A5D5-4F12-9A2D-11D42262B822][Fringe mode]] for the relevant configurations,
  while their overall presentation is controlled by the active theme).

All those combined contribute to an outcome that is appropriate for long
reading or writing sessions, as well as presentations. I intentionally
do not introduce any font-resizing effect, as my needs vary in that
regard depending on the context (though do refer to the =indiebrain-fonts.el= I
linked to earlier).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'face-remap)

(indiebrain-emacs-elpa-package 'olivetti
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 80)
  (setq olivetti-recall-visual-line-mode-entry-state t))

(indiebrain-emacs-elpa-package 'org-tree-slide
  (setq org-tree-slide-breadcrumbs nil)
  (setq org-tree-slide-header nil)
  (setq org-tree-slide-slide-in-effect nil)
  (setq org-tree-slide-heading-emphasis nil)
  (setq org-tree-slide-cursor-init t)
  (setq org-tree-slide-modeline-display nil)
  (setq org-tree-slide-skip-done nil)
  (setq org-tree-slide-skip-comments t)
  (setq org-tree-slide-fold-subtrees-skipped t)
  (setq org-tree-slide-skip-outline-level 8)
  (setq org-tree-slide-never-touch-face t)
  (setq org-tree-slide-activate-message
    (format "Presentation %s" (propertize "ON" 'face 'success)))
  (setq org-tree-slide-deactivate-message
    (format "Presentation %s" (propertize "OFF" 'face 'error)))
  (let ((map org-tree-slide-mode-map))
    (define-key map (kbd "<C-down>") #'org-tree-slide-display-header-toggle)
    (define-key map (kbd "<C-right>") #'org-tree-slide-move-next-tree)
    (define-key map (kbd "<C-left>") #'org-tree-slide-move-previous-tree))
  (let ((map org-mode-map))
    (define-key org-mode-map (kbd "<f8>") 'org-tree-slide-mode)))

(indiebrain-emacs-builtin-package 'indiebrain-logos
  (setq indiebrain-logos-org-presentation nil)
  (setq indiebrain-logos-variable-pitch nil)
  (setq indiebrain-logos-scroll-lock nil)
  (setq indiebrain-logos-hidden-modeline t)
  (define-key global-map (kbd "<f9>") #'indiebrain-logos-focus-mode))
#+end_src

And here is =indiebrain-logos.el= in its totality. It is available as a file in
[[https://github.com/indiebrain/.files/][my dotfiles' repo]]:

#+include: indiebrain-lisp/indiebrain-logos.el src emacs-lisp :tangle no

** Version control tools
:PROPERTIES:
:CUSTOM_ID: h:8D43D636-8714-456E-9DD9-7E4BA630E7F3
:END:

*** Diff-mode (and indiebrain-diff.el extensions)
:PROPERTIES:
:CUSTOM_ID: h:166CA916-D535-4498-9EBE-4B3DC2A06FAF
:END:

This covers the standard =diff-mode.el=, which I use quite often, such as
while interfacing with the built-in Version Control framework (see the
section on [[#h:A852E4F8-426C-4AA1-846E-41204B0D28C4][Version control framework (vc.el and indiebrain-vc.el)]]).

Overview of my preferences for how diffs should look:

- Always start the buffer in a read-only state. A typo will mess things
  up when trying to apply a patch.
- After applying a diff hunk (=diff-apply-hunk= with =C-c C-a=) move on to
  the next one.
- Update hunk headers automatically following an edit to the diff.
- Do not show word-wise ("refined") changes upon activation. I prefer to
  do so manually. All such highlights are removed if you generate the
  buffer again (with =g= as expected) and the default is to not show
  word-wise changes.
- Do not prettify headers. I like the standard "patch" looks. It also
  makes it easier to copy the diff elsewhere.

Now some notes on my =indiebrain-diff.el= extensions, combined with a
description of the basics of =diff-mode= (as always you can get
documentation about the current buffer's major mode with =C-h m=-):

- =indiebrain-diff-buffer-dwim= will produce a diff that compares the current
  buffer to the last saved state of the underlying file. If the buffer
  has no unsaved edits, the command will produce a diff that compares
  the file to its last registered version-controlled state. Calling the
  command with an optional prefix argument (=C-u=) will enable word-wise
  highlighting across the diff.

- =indiebrain-diff-refine-cycle= is how I manually control word-wise diff
  highlights. This command has a buffer-local cyclic behaviour. The
  first time it is called, it acts on the diff hunk at point. Upon
  second invocation, it operates on the entire buffer. And on third call
  it removes the word-wise diffs altogether.

- =indiebrain-diff-narrow-dwim= narrows to the diff hunk at point. If narrowing
  is already present, it widens the buffer. When invoked with an
  optional prefix argument, it narrows to the current file.

- =C-c C-c= or =M-o= takes you to the point of the changes in the source
  file. If you run this of the diff hunk's heading, you go to the
  beginning of the context. But if you place the point somewhere inside
  of the diff's added changes or context, you will visit that exact
  position in the original file (does not work for removed text because
  technically it does not exist).

- When working with patches to source code, which are distributed e.g.
  through email, you can apply the current hunk with =C-c C-a= or test for
  compatibility with =C-c C-t=. This is a nice way to easily merge
  contributions from others, without having to go through the workflow
  of some proprietary Git/Version-Control forge.

- With =M-n= and =M-p= you move between hunks. With =M-}= and =M-{= or =M-N=, =M-P=
  do the same between files.

he =indiebrain-diff-*= commands are part of my =indiebrain-diff.el= library, reproduced
in its entirety after this set of package configurations.

*Pro tip:* enable =outline-minor-mode= to make diff sections foldable. Check
[[#h:87B9CD61-B963-4EE8-A90E-3BA1725DF6D3][Outline mode, outline minor mode, and extras (indiebrain-outline.el)]].

Also read these sections:

+ [[#h:E5EAE6EE-BF12-4903-81BE-081372C046EB][Projects (project.el and indiebrain-project.el)]].
+ [[#h:A852E4F8-426C-4AA1-846E-41204B0D28C4][Version control framework (vc.el and indiebrain-vc.el)]].

Changes to all tracked files are optionally highlighted in the fringe
thanks to the =diff-hl= package by Dmitry Gutov (refer to the section on
[[#h:E419F543-641F-4DD3-9D01-7834DF02794A][Line numbers and relevant indicators (indiebrain-sideline.el)]]). Any
rules that control the placement of VC-related (and other) buffers are
defined in the section on window rules and basic tweaks (specifically,
refer to the variable =display-buffer-alist=).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'diff-mode
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil)                ; I do it on demand
  (setq diff-font-lock-prettify nil)    ; better for patches
  ;; The following is further controlled by
  ;; `indiebrain-diff-modus-themes-diffs'
  (setq diff-font-lock-syntax 'hunk-also))

(indiebrain-emacs-builtin-package 'indiebrain-diff
  (indiebrain-diff-modus-themes-diffs)
  (add-hook 'modus-themes-after-load-theme-hook #'indiebrain-diff-modus-themes-diffs)

  (indiebrain-diff-extra-keywords 1)

  ;; `indiebrain-diff-buffer-dwim' replaces the default for `vc-diff' (which I
  ;; bind to another key---see VC section).
  (define-key global-map (kbd "C-x v =") #'indiebrain-diff-buffer-dwim)
  (let ((map diff-mode-map))
    (define-key map (kbd "C-c C-b") #'indiebrain-diff-refine-cycle) ; replace `diff-refine-hunk'
    (define-key map (kbd "C-c C-n") #'indiebrain-diff-narrow-dwim)))
#+end_src

This is =indiebrain-diff.el= (part of [[https://github.com/indiebrain/.files][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-diff.el src emacs-lisp :tangle no

*** Version control framework (vc.el and indiebrain-vc.el)
:PROPERTIES:
:CUSTOM_ID: h:A852E4F8-426C-4AA1-846E-41204B0D28C4
:END:

VC consists of set of libraries that provide the means for working with
several version control systems, else "backends". It is built into
Emacs. Compared with =magit= (see section on Magit configs), =vc= offers a
more abstract, buffer-oriented paradigm that does a fine job at covering
all basic versioning needs. It however never stands as Magit's peer when
it comes to the sheer coverage of Git features.

To my mind, VC and Magit can be used as part of the same setup. Employ
the former for common tasks such as viewing diffs and logs, committing
changes in bulk, pushing and pulling from a remote. And let Magit handle
the more involved and specialised cases of staging a partial diff,
rebasing commits interactively, writing a commit fixup, and so on.

Also refer to the section on Diff-mode (and indiebrain-diff.el
extensions) which includes various neat extras, such as extra
fontification rules for diff buffers.

Here is an overview of the keys I define, with only a few of them being
left to their default values (note that =indiebrain-diff-buffer-dwim= is
part of the =indiebrain-diff.el= that I linked to above):

| Command                                | C-x v prefix | Mnemonic          |
|----------------------------------------+--------------+-------------------|
| vc-annotate                            | a            |                   |
| vc-update                              | F            | Fetch and Fuse    |
| vc-push                                | P            |                   |
| vc-log-incoming                        | f            | Fetch only        |
| vc-log-outgoing                        | O            |                   |
| vc-create-tag                          | t            |                   |
| vc-retrieve-tag                        | b            | Branch/tag switch |
| vc-diff                                | d            | Diff current file |
| vc-root-diff                           | D            | Diff project      |
| indiebrain-diff-buffer-dwim            | =            | Equality check    |
| indiebrain-vc-project-or-dir           | p            | Project status    |
| indiebrain-vc-custom-log               | SPC          |                   |
| indiebrain-vc-git-patch-dwim           | c            | Create patch      |
| indiebrain-vc-git-show                 | s            | Show commit       |
| indiebrain-vc-git-grep                 | g            |                   |
| indiebrain-vc-git-log-grep             | G            |                   |
| indiebrain-vc-git-find-revision        | r            | Revisit version   |
| indiebrain-vc-git-blame-region-or-file | B            | Blame             |
| indiebrain-vc-git-log-insert-commits   | i            | Insert commit log |
| indiebrain-vc-git-reset                | R            | Reset (--soft)    |

My =indiebrain-vc.el= library (reproduced after the package
configurations) defines several commands that extend VC to suit my needs
as a Git user. Check the key maps I assign those commands to, in order
to further appreciate the scope of each action. In short:

- =indiebrain-vc-git-grep= is a simple wrapper around =vc-git-grep=. Instead of
  asking for a directory and a file extension pattern, it just prompts
  for a regexp and performs the search across the entire VC-controlled
  directory tree. All matches are placed directly in a buffer.

- =indiebrain-vc-git-log-edit-extract-file-name= is used in log-edit buffers to
  derive the file name of the item being committed. For example, as I
  am writing this, I may want to compose a summary of my changes like
  "indiebrain-emacs: expand VC section docs". The "indiebrain-emacs: " part comes
  directly from this command, which reads from the "indiebrain-emacs.org"
  file. If there are multiple files to be committed, then a minibuffer
  prompt asks to pick one among them. This helps me write clean and
  meaningful summaries.

- The commands =indiebrain-vc-git-log-edit-{next,previous,complete}-comment= are
  used to access information about previous commit messages that are
  stored in the dedicated ring. The next/previous operations will cycle
  through the ring in the given direction. While the "complete" command
  will use minibuffer completion to insert the select item at point.

- =indiebrain-vc-git-log-insert-commits= will simply insert at point N number of
  commits starting from the HEAD of the current project. The number is
  inserted at the minibuffer following a prompt. This runs the =git log=
  shell command in the background. If the command is not called from
  inside a version-controlled directory or if it is invoked with a
  prefix argument (=C-u=), it first asks for a project and eventually
  prints a log for it. Again, this is useful while writing the message
  of a commit, as I occasionally need to reference earlier changes.

- =indiebrain-vc-git-patch-dwim= produces a properly formatted patch for a
  given commit. The outputted file is saved in a directory that is
  selected via a minibuffer completion prompt: default candidates are
  stored in =indiebrain-vc-patch-output-dirs= and are complemented by the
  root of the current project.

  - When browsing a =log-view= buffer, the commit is the one around point.

  - When the region is active in Log View buffers, the command will
    capture the included range of commits, instead of just the one at
    point.

  - With a prefix argument (=C-u=), a minibuffer completion prompt will
    ask for a commit to use as the base in a range against HEAD. This
    will skip the check for the commit at point, though an active region
    in Log View buffers will still take precedence.

  - Beware of how Git interprets those ranges: the base commit is the
    one before the earliest in the range, so if you need to produce
    patches for the topmost 4 commits, you must include the last 5 in
    the region.

- =indiebrain-vc-git-checkout-remote= prompts for a remote branch and proceeds
  to checkout a local branch that is set up to track it. So if you have
  a remote named =origin/dev= it will do =git checkout -b dev origin/dev=.
  I only use this command inside VC-dir buffers.

- =indiebrain-vc-custom-log= prints a log of commits that matches a custom file
  set. This is of great value when you need to inspect the history of
  only some files rather than that of the entire repository. What files
  to choose is determined in two ways: (1) the file-at-point in Dired
  buffers, or all marked files, and (2) files in the current directory
  selected with minibuffer completion.

- =indiebrain-vc-log-view-toggle-entry-all= will toggle the visibility of all
  commits in a compact log view. I often employ this in tandem with
  =indiebrain-vc-custom-log=.

- =indiebrain-vc-git-show= lets you read a given commit that you access with
  completion. A simple and effective wrapper for =git show=.

- =indiebrain-vc-git-log-grep= provides a search utility for commit logs. It
  accepts a regular expression, which may just be a string, and shows
  all commits whose message includes that pattern. When called with a
  universal prefix argument (=C-u=), the log will also include the
  corresponding diff of each commit.

- =indiebrain-vc-git-find-revision= allows you to revisit a previous state of the
  current file, by selecting a commit with completion. Quite powerful
  when you want to search, for example, my dotemacs from when I first
  introduced a certain package, say, =indiebrain-vc.el=.

- =indiebrain-vc-git-reset= prompts for a commit to reset back to, using
  minibuffer completion. This is a "soft" undo process in that all
  changes are kept in place while any commits are removed. Remember to
  only do this for local logs as it is not good practice to reset
  publicly available histories: it will break the local copies of other
  users.

- =indiebrain-vc-git-log-reset= is like the above command, only that it is meant
  to be called from inside a Log View buffer (e.g. =vc-print-root-log=
  which is bound to =C-x v L= by default). The commit to reset back to is
  the one at point. Calling the command with a prefix argument (=C-u=)
  will change the meaning of the reset operation from a soft to a hard
  one. The latter deletes all commits up to the selected commit /and
  removes all changes/, so please be careful.

- =indiebrain-vc-project-or-dir= produces a =vc-dir= buffer for the current
  project (also see [[#h:E5EAE6EE-BF12-4903-81BE-081372C046EB][Projects (project.el and indiebrain-project.el)]]).
  With a =C-u= prefix argument the command limits the matches to the
  present directory.

- =indiebrain-vc-log-kill-hash= appends to the kill-ring the hash of the commit
  around point. It is meant to be used in =log-view= buffers.

- =indiebrain-vc-git-setup-mode= is a minor mode that refashions the log
  edit buffer while adding a small tweak to the log view buffers.

  - Normally the log edit buffer (what you use to write the commit
    message) will pop up in a window with a smaller window below it
    showing the files to be committed. The window layout does not
    automatically show the corresponding diff, while there is no readily
    available information as to what branch we are about to commit the
    changes to. So my minor mode removes the small window with the files
    and in its stead adds a comment block in the main message
    composition buffer (like the standard =git commit=). It then displays
    the diff window on one side and the edit buffer on the other (yes,
    just like Magit, though the order of the windows is always the
    same). The prior window configuration and the point are saved before
    entering the log edit session and immediately restored upon exit
    (either by committing the changes or aborting).

  - The behaviour of cycling the ring of prior commits is reworked to
    account for the custom git comment. In addition to back/forth
    motions through the ring's items (=M-p=, =M-n=), a command for picking a
    commit message with minibuffer completion is also made available in
    the stead of the generic commands for searching through the ring,
    with =M-s= or =M-r= (the defaults lack visual feedback and are, in my
    opinion, not appropriate for the task).

  - The =Amend= pseudo header is displayed by default to make it easier to
    edit the last commit, if necessary, and to raise awareness about
    this possibility.

  - For the log view buffers (commit logs) the minor mode instructs the
    command that expands the message of a commit on the current line to
    include more information from =git log= than what it normally would.
    It shows diff stats and affected file names, while also creating
    some much needed negative space for better usability. Those file
    names are not purely cosmetic, as they can now serve to power Emacs'
    contextuality and "future history" such as when you put point over
    the name and type =C-x p f= (=project-find-file=): the file at point
    becomes the default choice and the one you will also get with =M-n= in
    the minibuffer (=next-history-element=).

Finally, a few tips for acting in the log-edit buffer (remember to use
=C-h m= (=M-x describe-mode=) in every unfamiliar major mode and read the
manual for more on the matter):

- Use =C-c C-d= (=log-edit-show-diff=) to produce a diff of the changes
  to-be-committed. Of course this is of no use if my aforementioned
  minor mode is enabled. Still, it is good to know (by the way, this
  command also works in Magit's commit composition buffers).

- With =C-c C-w= (=log-edit-generate-changelog-from-diff=) generate an
  overview of documented changes to the given file set. While this may
  not be useful for everyday commits, it is mandatory when preparing
  patches for upstream Emacs (and probably other GNU projects).

- Normally the window layout is set up to include files for the given
  commit, but I disable that via my minor mode. You can opt to display
  them with =C-c C-f= (=log-edit-show-files=).

- =C-c C-k= (=log-edit-kill-buffer=) cancels the log editing process.

- =M-n= (=log-edit-next-comment=) and =M-p= (=log-edit-previous-comment=) let
  you cycle through prior commit messages.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'vc
  ;; Those offer various types of functionality, such as blaming,
  ;; viewing logs, showing a dedicated buffer with changes to affected
  ;; files.
  (require 'vc-annotate)
  (require 'vc-dir)
  (require 'vc-git)
  (require 'add-log)
  (require 'log-view)

  ;; This one is for editing commit messages.
  (require 'log-edit)
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil)

  ;; Note that `indiebrain-vc-git-setup-mode' will run the following when
  ;; activated:
  ;;
  ;;   (remove-hook 'log-edit-hook #'log-edit-show-files)
  ;;
  ;; If you need the window to pop back up, do it manually with C-c C-f
  ;; which calls `log-edit-show-files'.

  (setq vc-find-revision-no-save t)
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  ;; I use a different account for git commits
  (setq add-log-mailing-address "info@indiebrainesilaos.com")
  (setq add-log-keep-changes-together t)
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
    '("%d %h %ad %an: %s"
      ;; The first shy group matches the characters drawn by --graph.
      ;; We use numbered groups because `log-view-message-re' wants the
      ;; revision number to be group 1.
      "^\\(?:[*/\\|]+\\)\\(?:[*/\\| ]+\\)?\
\\(?2: ([^)]+) \\)?\\(?1:[0-9a-z]+\\) \
\\(?4:[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) \
\\(?3:.*?\\):"
      ((1 'log-view-message)
       (2 'change-log-list nil lax)
       (3 'change-log-name)
       (4 'change-log-date))))

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v a") #'vc-annotate) ; `vc-update-change-log' is not in git
    (define-key map (kbd "C-x v b") #'vc-retrieve-tag)  ; "branch" switch
    (define-key map (kbd "C-x v t") #'vc-create-tag)
    (define-key map (kbd "C-x v f") #'vc-log-incoming)  ; the actual git fetch
    (define-key map (kbd "C-x v o") #'vc-log-outgoing)
    (define-key map (kbd "C-x v F") #'vc-update)        ; "F" because "P" is push
    (define-key map (kbd "C-x v d") #'vc-diff))
  (let ((map vc-dir-mode-map))
    (define-key map (kbd "a") #'vc-annotate)
    (define-key map (kbd "b") #'vc-retrieve-tag)
    (define-key map (kbd "t") #'vc-create-tag)
    (define-key map (kbd "O") #'vc-log-outgoing)
    (define-key map (kbd "o") #'vc-dir-find-file-other-window)
    (define-key map (kbd "f") #'vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
    (define-key map (kbd "F") #'vc-update)       ; symmetric with P: `vc-push'
    (define-key map (kbd "d") #'vc-diff)         ; parallel to D: `vc-root-diff'
    (define-key map (kbd "k") #'vc-dir-clean-files)
    (define-key map (kbd "G") #'vc-revert)
    (let ((indiebrain-vc-git-branch-map (make-sparse-keymap)))
      (define-key map "B" indiebrain-vc-git-branch-map)
      (define-key indiebrain-vc-git-branch-map "n" #'vc-create-tag) ; new branch/tag
      (define-key indiebrain-vc-git-branch-map "s" #'vc-retrieve-tag) ; switch branch/tag
      (define-key indiebrain-vc-git-branch-map "c" #'indiebrain-vc-git-checkout-remote) ; "checkout" remote
      (define-key indiebrain-vc-git-branch-map "l" #'vc-print-branch-log))
    (let ((indiebrain-vc-git-stash-map (make-sparse-keymap)))
      (define-key map "S" indiebrain-vc-git-stash-map)
      (define-key indiebrain-vc-git-stash-map "c" 'vc-git-stash) ; "create" named stash
      (define-key indiebrain-vc-git-stash-map "s" 'vc-git-stash-snapshot)))
  (let ((map vc-git-stash-shared-map))
    (define-key map "a" 'vc-git-stash-apply-at-point)
    (define-key map "c" 'vc-git-stash) ; "create" named stash
    (define-key map "D" 'vc-git-stash-delete-at-point)
    (define-key map "p" 'vc-git-stash-pop-at-point)
    (define-key map "s" 'vc-git-stash-snapshot))
  (let ((map vc-annotate-mode-map))
    (define-key map (kbd "M-q") #'vc-annotate-toggle-annotation-visibility)
    (define-key map (kbd "C-c C-c") #'vc-annotate-goto-line)
    (define-key map (kbd "<return>") #'vc-annotate-find-revision-at-line))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<tab>") #'log-view-toggle-entry-display)
    (define-key map (kbd "<return>") #'log-view-find-revision)
    (define-key map (kbd "s") #'vc-log-search)
    (define-key map (kbd "o") #'vc-log-outgoing)
    (define-key map (kbd "f") #'vc-log-incoming)
    (define-key map (kbd "F") #'vc-update)
    (define-key map (kbd "P") #'vc-push)))

(indiebrain-emacs-builtin-package 'indiebrain-vc
  (setq indiebrain-vc-log-limit 100)
  (setq indiebrain-vc-log-bulk-action-limit 50)
  (setq indiebrain-vc-git-log-edit-show-commits t)
  (setq indiebrain-vc-git-log-edit-show-commit-count 10)
  (setq indiebrain-vc-shell-output "*indiebrain-vc-output*")
  (setq indiebrain-vc-patch-output-dirs (list "~/" "~/Desktop/"))
  (add-to-list' log-edit-headers-alist '("Amend"))

  ;; This refashions log view and log edit buffers
  (indiebrain-vc-git-setup-mode 1)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v i") #'indiebrain-vc-git-log-insert-commits)
    (define-key map (kbd "C-x v p") #'indiebrain-vc-project-or-dir)
    (define-key map (kbd "C-x v SPC") #'indiebrain-vc-custom-log)
    (define-key map (kbd "C-x v g") #'indiebrain-vc-git-grep)
    (define-key map (kbd "C-x v G") #'indiebrain-vc-git-log-grep)
    (define-key map (kbd "C-x v c") #'indiebrain-vc-git-patch-dwim)
    (define-key map (kbd "C-x v s") #'indiebrain-vc-git-show)
    (define-key map (kbd "C-x v r") #'indiebrain-vc-git-find-revision)
    (define-key map (kbd "C-x v B") #'indiebrain-vc-git-blame-region-or-file)
    (define-key map (kbd "C-x v R") #'indiebrain-vc-git-reset))
  (let ((map vc-git-log-edit-mode-map))
    (define-key map (kbd "C-C C-n") #'indiebrain-vc-git-log-edit-extract-file-name)
    (define-key map (kbd "C-C C-i") #'indiebrain-vc-git-log-insert-commits)
    ;; Also done by `indiebrain-vc-git-setup-mode', but I am putting it here
    ;; as well for visibility.
    (define-key map (kbd "C-c C-c") #'indiebrain-vc-git-log-edit-done)
    (define-key map (kbd "C-c C-a") #'indiebrain-vc-git-log-edit-toggle-amend)
    (define-key map (kbd "M-p") #'indiebrain-vc-git-log-edit-previous-comment)
    (define-key map (kbd "M-n") #'indiebrain-vc-git-log-edit-next-comment)
    (define-key map (kbd "M-s") #'indiebrain-vc-git-log-edit-complete-comment)
    (define-key map (kbd "M-r") #'indiebrain-vc-git-log-edit-complete-comment))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<C-tab>") #'indiebrain-vc-log-view-toggle-entry-all)
    (define-key map (kbd "c") #'indiebrain-vc-git-patch-dwim)
    (define-key map (kbd "R") #'indiebrain-vc-git-log-reset)
    (define-key map (kbd "w") #'indiebrain-vc-log-kill-hash)))
#+end_src

And here is =indiebrain-vc.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-vc.el src emacs-lisp :tangle no

*** Interactive and powerful git front-end (Magit and Forge)
:PROPERTIES:
:CUSTOM_ID: h:FEEF77DF-54C9-45F5-A54B-FB28DBA1765F
:END:

As noted in the section on the built-in [[#h:A852E4F8-426C-4AA1-846E-41204B0D28C4][Version Control framework]] I use
Magit for easy access to the /advanced features of Git/. While I rely on
the built-in tools for all day-to-day operations.

Magit offers a modal interface where the full power of =git= is neatly
organized in sets of keys that are directly accessible without holding
down any modifiers.

While inside the =magit-status= buffer, hit =?= to produce a transient menu
with the possible vectors to action. Do it again inside each of the
Magit buffers to view the keys that work for their context.

Magit has great defaults and it should work admirably without any further
tweaks or extra setup. That granted, the =git-commit= package (part of
Magit) is configured in accordance with the guidelines provided by this
article on [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]]. The gist is to compose commits
that are clean and easy to read. The =fill-column= is set elsewhere in
this document to 72 characters long.

Additionally, the =forge= library is a wonderful companion library to
=magit= which enables collaboration on popular git forges (GitHub and
Gitlab). =forge= uses the [[https://magit.vc/manual/ghub/index.html#Top][ghub API client]] to interact with forges. See the
=forge= / =ghub= client documentation for directions on setting up API
credentials. Typically, for my use case, I need to specify the usernames
of my GitHub / Gitlab accounts in my =.gitconfig=. Then I generate [[https://magit.vc/manual/forge/Token-Creation.html#Token-Creation][an API
token with the abilities listed in the =forge= documentation]]. Then the
token is stored in an encrypted =.authinfo.gpg= file in my user's home
directory. The entries in the =authinfo.gpg= file look something like these:

#+begin_example
machine api.github.com login indiebrain^forge password 012345abcdef...
machine gitlab.com/api/v4 login indiebrain^forge password 012345abcdef...
#+end_example

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'magit
  (setq magit-define-global-key-bindings nil)
  (define-key global-map (kbd "C-c g") #'magit-status)

  (require 'git-commit)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
    '("Signed-off-by"
      "Acked-by"
      "Modified-by"
      "Cc"
      "Suggested-by"
      "Reported-by"
      "Tested-by"
      "Reviewed-by"))
  (setq git-commit-style-convention-checks
    '(non-empty-second-line
      overlong-summary-line))

  (require 'magit-diff)
  (setq magit-diff-refine-hunk t)

  (require 'magit-repos)
  (setq magit-repository-directories
    '(("~/Developer/" . 1))))

(indiebrain-emacs-elpa-package 'forge)
#+end_src

*** Smerge and Ediff
:PROPERTIES:
:CUSTOM_ID: h:85B6D128-D176-43C2-A8C3-6BB5C7478794
:END:

*Read this section, because it matters more than the code below it.*

Sometimes we face a situation where we have conflicting versions of a
file and the version control backend cannot solve them on its own. This
can happen fairly often when collaborating with other people or, more
generally, when we keep our work spread across multiple feature branches
with diverging histories. Whenever such conflicts arise, Emacs will
automatically annotate the offending files with special markers that
show the conflicting differences. Visiting those files will then
activate =smerge-mode=. At which point we are in control.

Smerge revolves around the concept of dividing the conflicting part into
an "upper" (red) and a "lower" section (green), possibly with their
common ancestor or last point of convergence in the middle (yellow).

With this in mind we can operate on the marked differences by relying on
the functions that Smerge provides, all of which are accessed by default
through the common prefix of =C-c ^=. Start by typing the prefix followed
by =C-h= to see all possible key chords. These are the commands I have
used the most:

- =C-c ^ u= (=smerge-keep-upper=)
- =C-c ^ l= (=smerge-keep-lower=)
- =C-c ^ b= (=smerge-keep-base=)
- =C-c ^ a= (=smerge-keep-all=)
- =C-c ^ n= (=smerge-next=)
- =C-c ^ p= (=smerge-prev=)

Proceed to edit the file the way you want until no more conflicts exist.
You can also do things through manual editing, with standard commands
and motions, but that can be prone to errors (which lead to more
conflicts). At any moment in this process, you can switch to =ediff=,
which offers a more powerful way of working with differences. Type the
key chord =C-c ^ E= (=smerge-ediff=).

Ediff is a powerhouse that is likely to cover all your needs in this
area (including those you are not aware of). For our purposes, what
matters is to understand the basic concepts.

The way this tool works is that it starts by producing a layout of the
two conflicting versions with access to a "control panel" for operating
on them. By default, the panel is positioned on a new frame, but I find
that rather awkward---my config puts it inside an Emacs window instead.
While focusing the control panel, you can move between each diff range
with =n= and =p=. The focused section will be coloured using red, green,
and yellow, while all other diffs will be presented in gray.

On each diff, you have three options: to use the version of buffer A
(red), of buffer B (green), or a combination of the two. The keys for
each of those are =a=, =b=, and =+= respectively. Your choice will be
reflected in buffer C (the yellow one). Use these to resolve all
conflicts and then quit the session with =q=.

Concerning the combination of versions between A and B, Ediff has the
behaviour of also inserting as plain text the annotation markers that
Smerge relied on. As of this writing (2020-04-10), I am not aware of an
automatic or convenient way to omit those prior to confirming our edits.
To that end, I tweak the wording of the markers to some unique string
(see package below) and then run =flush-lines= to remove them before
saving the resulting buffer (so right after the =q=). For more on this,
check =indiebrain/ediff-flush-combination-pattern=.

For =git= users, to actually /reference the common ancestor/ (the point
before the branching paths started) we must run this command once in our
command-line prompt (writes to your global =.gitconfig= file):

#+begin_src
git config --global merge.conflictStyle diff3
#+end_src

This is optional, but I find that I like it. At any rate, the
configurations I have below are straightforward (learn more about this
powerful tool by hitting =?= inside of its control panel and by consulting
its comprehensive manual):

- Do not keep all the buffers after exiting the Ediff session.
- Keep buffers in an editable state. Otherwise it is impossible to
  perform the changes we are interested in.
- Show the common ancestor in another buffer. This helps provide
  further context of how things took their form.
- Show only the conflicting parts. This is not a review of all diffs.
- Prefer putting windows side-by-side, rather than one below the other.
- Do not enter the ediff session in a new frame. This also means that
  the control panel will be inside an Emacs window (at the bottom part)
  rather than in a tiny frame of its own.

There actually is nothing in terms of Smerge-related configurations.
The package is small and does one thing well.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'smerge-mode)

(indiebrain-emacs-builtin-package 'ediff
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
    '("<<<<<<< indiebrain-ediff-combine Variant A" A
      ">>>>>>> indiebrain-ediff-combine Variant B" B
      "####### indiebrain-ediff-combine Ancestor" Ancestor
      "======= indiebrain-ediff-combine End"))

  ;; TODO automate process in a robust way, or at least offer a good key
  ;; binding.
  (defun indiebrain/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs. While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*indiebrain-ediff.*" (point-min) (point-max) nil)))
#+end_src

** Command-line shells
:PROPERTIES:
:CUSTOM_ID: h:531317E1-FB0B-496D-8B1F-C08A3470FA26
:END:

**** Eshell and indiebrain-eshell.el
:PROPERTIES:
:CUSTOM_ID: h:23732B54-0ACA-44EB-BF6A-BDD82FA53FAE
:END:

Eshell is a strictly line-oriented command prompt written in Emacs Lisp.
This comes with its pros and cons: it can understand Elisp but does not
behave exactly like Unix shells, say, Bash. Eshell cannot display the
kind of pseudo graphics a terminal emulator can, such as those you find
in =mutt=, =htop=, =ncmpcpp=, =newsboat= and so on. As each user's needs are
different, you will have to determine whether Eshell can fit into your
workflow. Start by reading its fairly short, yet insightful, manual.

For me this tool is one of the most promising in the Emacs milieu
because while it is a competent shell it can seamlessly integrate with
the rest of Emacs' capabilities. This is best exemplified by its
extensibility, such as what I am doing with =indiebrain-eshell.el=. More on that
below.

The fact that Eshell cannot reproduce the artefacts of the ncurses
library does not pose a hindrance to my workflow, as I have replacements
for all such "graphical" programs within Emacs. =M-x proced= lets me
interact with system processes, while Elfeed fills the niche of
following RSS/Atom feed.


- Proced (process monitor, similar to `top').
- Elfeed (RSS/Atom feed reader).

Now an overview of =indiebrain-eshell.el=, with the full code reproduced right
after the package configurations:

- There are several =indiebrain-eshell-ffap-*= commands that operate on the file
  at point. Say you have called =ls= and wish to expand the contents of a
  file at the command prompt. With point over the file name of
  interest, use =indiebrain-eshell-ffap-insert=. Wish to visit the file
  instead, so that you may edit it?  Try =indiebrain-eshell-ffap-find-file=.
  The command =indiebrain-eshell-ffap-kill-save= copies the file's full file
  system path, while =indiebrain-eshell-ffap-dired-jump= opens a Dired buffer in
  that file's directory (see [[#h:2591A95A-FC9F-40DA-9E24-A327A453606D][Dired (directory editor, file manager)]]).

- =indiebrain-eshell-export= takes the prompt and output of the last command and
  places it in a bespoke buffer. The name of the buffer is controlled
  by the variable =indiebrain-eshell-output-buffer=. If that buffer does not
  exist, it is created. Otherwise subsequent invocations of this
  "export" command will append their contents to the existing ones.
  This is good for keeping a record of something you are working on.
  And because this is a standard buffer, you can edit it a will as well
  as call =write-file= (=C-x C-w=) to save it permanently to a file.

- =indiebrain-eshell-redirect-to-buffer= provides a completion prompt to help
  you redirect the output of a command to a given buffer. Simple and
  effective.

- =indiebrain-eshell-narrow-output-highlight-regexp= prompts for a regexp to
  highlight in the output of the last command. It then narrows the
  Eshell buffer to the contents of that output and emphasises the
  matches of the regexp. Very useful when you need to inspect some logs
  or other terse output. Remember that to widen the view you use the
  standard =widen= command, bound to =C-x n w= by default.

- =indiebrain-eshell-complete-history= lets you pick a command from your history
  using minibuffer completion. Forget about a non-interactive regexp
  search or, worse, consecutive calls to =M-p= and =M-n= to cycle through
  your recent inputs one at a time.

- =indiebrain-eshell-complete-recent-dir= provides a minibuffer prompt with
  completion that queries through all paths in your =cd= input history.
  This is much more convenient that standard actions like =cd -= or =cd -N=
  where =N= is the position of the item in the history of entries
  (retrieved with =cd ==).

- =indiebrain-eshell-find-subdirectory-recursive= uses completion to help you
  pick a subdirectory that extends the present working directory. It
  does so recursively, which makes it powerful, but can cause problems
  when called from the root of some massive directory tree. Exercise
  restraint.

- =indiebrain-eshell-root-dir= switches the present working directory to that of
  the current project's root directory, if one is found.

Also check these valuable resources:

+ [[https://cestlaz.github.io/post/using-emacs-66-eshell-elisp][Mike Zamansky's video demo]] that also shows how to program an Eshell
  switcher.
+ [[https://www.youtube.com/watch?v=RhYNu6i_uY4][Howard Abrahams' video]] that covers the features of Eshell.
+ [[https://ambrevar.xyz/emacs-eshell/][Pierre Neidhardt's detailed blog post]] on the pros and cons of Eshell.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'eshell
  (require 'esh-mode)
  (require 'esh-module)
  (setq eshell-modules-list             ; It works but may need review
    '(eshell-alias
      eshell-basic
      eshell-cmpl
      eshell-dirs
      eshell-glob
      eshell-hist
      eshell-ls
      eshell-pred
      eshell-prompt
      eshell-script
      eshell-term
      eshell-tramp
      eshell-unix))
  (setenv "PAGER" "cat") ; solves issues, such as with 'git log' and the default 'less'
  (require 'em-cmpl)
  (require 'em-dirs)
  (setq eshell-cd-on-directory t)

  (require 'em-tramp)
  (setq password-cache t)
  (setq password-cache-expiry 600)

  (require 'em-hist)
  (setq eshell-hist-ignoredups t)
  (setq eshell-save-history-on-exit t))

(indiebrain-emacs-builtin-package 'indiebrain-eshell
  (setq indiebrain-eshell-output-buffer "*Exported Eshell output*")
  (setq indiebrain-eshell-output-delimiter "* * *")
  (define-key global-map (kbd "<s-return>") #'eshell)
  (let ((map eshell-mode-map))
    (define-key map (kbd "M-k") #'eshell-kill-input)
    (define-key map (kbd "C-c C-f") #'indiebrain-eshell-ffap-find-file)
    (define-key map (kbd "C-c C-j") #'indiebrain-eshell-ffap-dired-jump)
    (define-key map (kbd "C-c C-w") #'indiebrain-eshell-ffap-kill-save)
    (define-key map (kbd "C-c C->") #'indiebrain-eshell-redirect-to-buffer)
    (define-key map (kbd "C-c C-e") #'indiebrain-eshell-export)
    (define-key map (kbd "C-c C-r") #'indiebrain-eshell-root-dir))
  (let ((map eshell-cmpl-mode-map))
    (define-key map (kbd "C-c TAB") #'indiebrain-eshell-ffap-insert) ; C-c C-i
    (define-key map (kbd "C-c M-h") #'indiebrain-eshell-narrow-output-highlight-regexp))
  (let ((map eshell-hist-mode-map))
    (define-key map (kbd "M-s") #'nil) ; I use this prefix for lots of more useful commands
    (define-key map (kbd "M-r") #'indiebrain-eshell-complete-history)
    (define-key map (kbd "C-c C-d") #'indiebrain-eshell-complete-recent-dir)
    (define-key map (kbd "C-c C-s") #'indiebrain-eshell-find-subdirectory-recursive)))
#+end_src

This is =indiebrain-eshell.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-eshell.el src emacs-lisp :tangle no

**** Shell (M-x shell)
:PROPERTIES:
:CUSTOM_ID: h:9EAB1902-DB36-45E4-B889-E487B5623291
:END:

This is a shell (Bash, in my case) that runs inside of Emacs. Unlike
terminal emulators, this one can use standard Emacs keys and behaves
much like an ordinary buffer. It also integrates nicely with the
built-in completion tools, which makes it particularly nice to work
with.

The one area where this Shell differs substantially from ordinary
buffers is with regard to the command prompt: you can re-run a command
on the scroll-back buffer by just hitting =RET= while point is on its line
(no need to go back to the end and cycle the command history with =M-p= or
=M-n=).

Another peculiarity relative to the standard commands in the terminal is
to search backward through your history with =M-r= (whereas in a terminal
emulator you use =C-r=).

Run =C-h m= inside of a shell buffer to learn about all the key bindings
and corresponding functions.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'shell
  (setq ansi-color-for-comint-mode t)
  (setq shell-command-prompt-show-cwd t) ; Emacs 27.1
  (define-key global-map (kbd "<s-S-return>") #'shell))
#+end_src

** Org-mode (personal information manager)
:PROPERTIES:
:CUSTOM_ID: h:4FECBD3C-9C88-4FFC-BFC3-3CD8A7B9C649
:END:

In its purest form, Org is a markup language that is similar to
Markdown: symbols are used to denote the meaning of a construct in its
context, such as what may represent a headline element or a phrase that
calls for emphasis.

What lends Org its super powers though is everything else built around
it: a rich corpus of Elisp functions that automate, link, combine,
enhance, structure, or otherwise enrich the process of using this rather
straightforward system of plain text notation.

Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and
workflows on how to organize one's life with plain text.

The present document is written in =org-mode= while its website version is
outputted by a tool (also part of Org) that exports Org notation to its
HTML equivalent.

Regarding the following code block, I strongly encourage you to make
liberal use of Emacs' documentation facilities to learn more about
functions, variables, symbols provided herein. And do not forget to read
Org's manual.

What follows in an exposition about each of the subsesctions of this
package configurations:

- Org links :: The =org-store-link= is one of the commands I use the most,
  as it allows me to, inter alia, connect the various sections of this
  document. Use it to store a direct link to the heading you are
  currently under. Or to produce a properly formatted link to supported
  buffers you are visiting (e.g. another file).

  There are several ways to insert such links. With =C-c C-l= (which calls
  =org-insert-link=) you will be prompted to select a stored link from the
  link. It will be inserted at point, using the right markup, but will
  first ask you for a description text. Otherwise you can invoke =C-c C-l=
  with an active region, to create a link to that location with the
  selected text becoming the description. Else just call
  =org-insert-last-stored-link= to skip the interactive process and insert
  the last link outright.

  In addition to these, =org-insert-link= can be used to create references
  on demand. Say you have a URL on the kill-ring: =C-c C-l=, then =C-y=
  followed by =RET= to confirm your input. Complete the process with a
  description and you are good to go.

- Org capture :: The =org-capture= tool is a powerful way to quickly
  produce some kind of structured information that gets stored in the
  appropriate place. The type of data and the way to store is determined
  by a system of templates which accepts a series of possible specifiers
  as well as the evaluated part of arbitrary elisp code.

  Each template is accessed via a key. These are listed in a temporary
  buffer when you call =org-capture=. Unique keys give direct access to
  their template, whereas templates that share a common initial key will
  produce a second selection list with the remaining options. In the
  latter case, the initial key entry has no call to an actual function,
  but is just written as a heading.

  The visibility of a template is explicitly controlled by the alist
  =org-capture-templates-contexts=. This allows us to tell Org the context
  in which we want certain options to appear in. Otherwise they remain
  concealed from our view. Equipped with this piece of functionality, we
  can freely write highly specialised templates that capture structured
  text when viewing some particular item, but are not needed for more
  general purposes.

  Specifiers that start with the caret sign (=^=) represent prompts for
  further user input. The pattern =^{TEXT}= is a prompt whose expression
  is =TEXT=. To offer possible options, use =^{Initial|ONE|TWO|THREE}=,
  where the first entry is the text of the prompt and all the rest are
  the available choices (depending on your completion framework, you may
  need to add an empty option as well, with =||=, should you ever want to
  insert nothing). In some templates I use the =^t= specifier, which is a
  built-in method to ask for a specific date.

  The text that goes into a template can be written as part of a string
  or inside a function that is then evaluated. I generally prefer to use
  simple strings, though I might revise this approach going forward. To
  insert a new line inside of a string, use =\n=.

  The =%?= specifier determines where the point shall end in once the
  template is parsed. While =%i= will insert the contents of the active
  region, if any.

  As things currently stand, my capture templates always write to
  headings inside of files. Note though that there are more
  possibilities, as described in the manual.

  A file can be specified by its absolute path or just a name. In the
  latter case, its location is understood relative to =org-directory=.
  When using the =file+headline= pattern, non-existent files are created
  automatically once you call the relevant template. Same for their
  respective headings.

  Finally, the =contrib/org-capture-no-delete-windows= and relevant =advice=
  address a problem I have when =org-capture= fails to conclude its
  actions when called from inside of a side window (for more on those,
  refer to the section on [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]). The code is
  taken directly from this [[https://stackoverflow.com/a/54251825][Stack Overflow thread]].

- Org agenda :: The =org-agenda= is not just a single interface. It
  rather is your conduit to a set of utilities for reading timestamped
  tasks. From there you can keep track of all the relevant entries you
  have inserted in the files declared as part of =org-agenda-files= list.

  Running =org-agenda= will present you with a list of possible options:
  the "dispatcher" as it called. Here is a primer (there are many more
  functions documented in the manual):

  - From the dispatcher, the =a= is where you keep track of all the items
    that have a date assigned to them, be it =SCHEDULED= or =DEADLINE=. To
    assign such a value to a heading use =C-c C-s= or =C-c C-d=
    respectively. Run those commands with a universal prefix (=C-u=) to
    remove the timestamp. Hit =/= to filter this view to match particular
    tags.

  - In the dispatcher's menu, the =t= will list all your tasks, regardless
    of whether they have a date assigned to them. You can then filter by
    keyword, regular expression, etc. Check the top of the buffer for
    information on how to do that.

  - And the =n= in the dispatcher will offer you a combined view of the
    above.

- Org export :: I do not have much to offer here, apart from the setup
  that handles consistent heading IDs and anchor tags (the latter
  concerns the HTML output). Everything in that segment, minus some
  minor tweaks from my part, is copied from this detailed tutorial on
  [[https://writequit.org/articles/emacs-org-mode-generate-ids.html][Org header IDs]]. Basically, the problem is that exported HTML does not
  have reliable anchor tags for the various sections of the document.
  This fixes the issue (read the article for more).

Finally, note that I sometimes deliver simple presentations using Org.
Refer to [[#h:DE9C418F-0C2D-4C3B-A4DF-AFE8BE0AB8BA][Custom extensions for "focus mode" (indiebrain-logos.el)]].

#+begin_src emacs-lisp
;; Pro tip: If you are reading the source code, use C-c '
;; (`org-edit-special') to put the code block in a dedicated buffer and
;; then activate `indiebrain-outline-minor-mode-safe' to conveniently browse
;; this massive code block.
(indiebrain-emacs-builtin-package 'org
  (setq org-directory (convert-standard-filename "~/.org"))
  (setq org-imenu-depth 7)
  ;;;; general settings
  (setq org-adapt-indentation nil)      ; No, non, nein, όχι!
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
  (setq org-hide-leading-stars nil)
  (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
        '(("s" . "src")
          ("r" . "src ruby")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-modules '(ol-info ol-eww))
  (setq org-use-sub-superscripts '{})
  (setq org-insert-heading-respect-content t)

  ;;;; refile, todo
  (setq org-refile-targets
        '((org-agenda-files . (:maxlevel . 2))
          (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "|" "DONE(D)" "CANCEL(C)")))
  (setq org-todo-keyword-faces nil)
  (setq org-priority-faces
        '((?A . '(org-scheduled-today org-priority))
          (?B . org-priority)
          (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line nil)

  (defun indiebrain/modus-themes-org-fontify-block-delimiter-lines ()
    "Match `org-fontify-whole-block-delimiter-line' to theme style.
  Run this function at the post theme load phase, such as with the
  hook `modus-themes-after-load-theme-hook'."
    (if (eq modus-themes-org-blocks 'gray-background)
        (setq org-fontify-whole-block-delimiter-line t)
      (setq org-fontify-whole-block-delimiter-line nil))
    (when (derived-mode-p 'org-mode)
      (font-lock-flush)))

  (add-hook 'modus-themes-after-load-theme-hook
            #'indiebrain/modus-themes-org-fontify-block-delimiter-lines)

  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

  ;;;; tags
  (setq org-tag-alist                   ; TODO review org tag list
        nil)

  ;;;; log
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline nil)
  (setq org-log-reschedule nil)
  (setq org-read-date-prefer-future 'time)

  ;;;; links
  (setq org-link-keep-stored-after-insertion t)

  ;;;; capture
  (setq org-capture-templates
        `(("t" "Basic task" entry
           (file+headline "tasks.org" "Backlog")
           ,(concat "* TODO %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %t\n"
                    ":END:\n\n"
                    "%i%l"))
          ("w" "Work")
          ("wb" "Backlog Item" entry
           (file+headline "tasks.org" "Backlog")
           ,(concat "* TODO %^{Title} \n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n:CAPTURED: %U\n:END:\n\n"
                    "https://nitro.powerhrg.com/runway/backlog_items/%^{Backlog Item Number}\n\n"
                    "%i%?"))))

  ;; Source: https://stackoverflow.com/a/54251825
  (defun contrib/org-capture-no-delete-windows (oldfun args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))

  ;; Same source as above
  (advice-add 'org-capture-place-template
              :around 'contrib/org-capture-no-delete-windows)

  ;;;; agenda
  ;;;;; Basic agenda setup
  (setq org-default-notes-file (thread-last org-directory (expand-file-name "notes.org")))
  (setq org-agenda-files `(,org-directory "~/.org"))
  (setq org-agenda-span 14)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

  ;;;;; General agenda view options
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "->")
  (setq org-agenda-todo-keyword-format "%-1s")
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?—)

  (defun indiebrain/org-agenda-format-date-aligned (date)
    "Format a DATE string for display in the daily/weekly agenda.
  This function makes sure that dates are aligned for easy reading.

  Slightly tweaked version of `org-agenda-format-date-aligned' that
  produces dates with a fixed length."
    (require 'cal-iso)
    (let* ((dayname (calendar-day-name date t))
           (day (cadr date))
           (day-of-week (calendar-day-of-week date))
           (month (car date))
           (monthname (calendar-month-name month t))
           (year (nth 2 date))
           (iso-week (org-days-to-iso-week
                      (calendar-absolute-from-gregorian date)))
           (weekyear (cond ((and (= month 1) (>= iso-week 52))
                            (1- year))
                           ((and (= month 12) (<= iso-week 1))
                            (1+ year))
                           (t year)))
           (weekstring (if (= day-of-week 1)
                           (format " (W%02d)" iso-week)
                         "")))
      (format "%s %2d %s %4d%s"
              dayname day monthname year weekstring)))

  (setq org-agenda-format-date #'indiebrain/org-agenda-format-date-aligned)

  ;;;;; Agenda marks
  (setq org-agenda-bulk-mark-char "#")
  (setq org-agenda-persistent-marks nil)

  ;;;;; Agenda diary entries
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary t)

  ;;;;; Agenda follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

  ;;;;; Agenda multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

  ;;;;; Agenda filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

  ;;;;; Agenda items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 5)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time t)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string
        (concat "Now " (make-string 36 ?—)))
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (0600 0700 0800 0900 1000 1100
                1200 1300 1400 1500 1600
                1700 1800 1900 2000 2100)
          " ....." "-----------------"))
  (setq org-agenda-default-appointment-duration nil)

  ;;;;; Agenda global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

  ;;;;; Agenda tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -120)

  ;;;;; Agenda entry
  ;; NOTE: I do not use this right now. Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    > ")

  ;;;;; Agenda logging and clocking
  ;; NOTE: I do not use these yet, though I plan to. Leaving everything
  ;; to its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-agenda-sort-notime-is-late t) ; Org 9.4
  (setq org-agenda-sort-noeffort-is-high t) ; Org 9.4

  ;;;;; Agenda column view
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

  ;;;; code blocks
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0)

  ;;;; export
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
  (require 'ox-texinfo)
  ;; FIXME: how to remove everything else?
  (setq org-export-backends '(html texinfo))

  (defun indiebrain/ox-html ()
    (interactive)
    (org-html-export-as-html nil nil nil t nil))

  (defun indiebrain/ox-texinfo ()
    (interactive)
    (org-texinfo-export-to-info))

  ;;;; IDs
  (setq org-id-link-to-org-use-id
        'create-if-interactive-and-no-custom-id)

  (declare-function org-id-add-location "org")

  ;; Copied from this article (with minor tweaks from my side):
  ;; <https://writequit.org/articles/emacs-org-mode-generate-ids.html>.
  (defun contrib/org-id-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker
  POM. If POM is nil, refer to the entry at point. If the entry
  does not have an CUSTOM_ID, the function returns nil. However,
  when CREATE is non nil, create a CUSTOM_ID if none is present
  already. PREFIX will be passed through to `org-id-new'. In any
  case, the CUSTOM_ID of the entry is returned."
    (org-with-point-at pom
      (let ((id (org-entry-get nil "CUSTOM_ID")))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (org-id-new (concat prefix "h")))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (format "%s" (buffer-file-name (buffer-base-buffer))))
          id)))))

  (defun contrib/org-id-headlines ()
    "Add CUSTOM_ID properties to all headlines in the current
  file which do not already have one."
    (interactive)
    (org-map-entries
     (lambda () (contrib/org-id-get (point) t))))

  (add-hook 'org-follow-link-hook #'indiebrain-pulse-recentre-top)
  (let ((map global-map))
    (define-key map (kbd "C-c a") #'org-agenda)
    (define-key map (kbd "C-c c") #'org-capture)
    (define-key map (kbd "C-c l") #'org-store-link))
  (let ((map org-mode-map))
    (define-key map (kbd "C-'") nil)
    (define-key map (kbd "C-,") nil)
    (define-key map (kbd "<C-return>") nil)
    (define-key map (kbd "<C-S-return>") nil)
    (define-key map (kbd "C-c S-l") #'org-toggle-link-display)
    (define-key map (kbd "C-c C-S-l") #'org-insert-last-stored-link)))
#+end_src

** Static site generator (org-page)
:PROPERTIES:
:CUSTOM_ID: h:1A471BF7-449C-44D1-B89B-3469D3F0FDFD
:END:

My personal website and blog are generated from a collection of Org
documents via the =org-page= package. The following configuration is very
specific to generating the content found at [[https://aaronkuehler.com][https://aaronkuehler.com]].

To generate and preview the site locally, I run
=op/do-publication-and-preview-site=. This exports the Org documents as
HTML, then serves them on the local host using =simple-httpd=.

Once the content is ready to be published to the web, I do so via
=op/do-publication=. The configuration in this section takes care of
wiring the local repository to the hosted site.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'org-page
  (setq op/repository-directory "~/Developer/indiebrain.github.io")
  (setq op/site-domain "https://aaronkuehler.com")
  (setq op/personal-github-link "https://github.com/indiebrain")
  (setq op/site-main-title "Aaron Kuehler")
  (setq op/site-sub-title "80% Scientist, 20% Artist. Theorist and Practitioner.")
  (setq op/theme-root-directory "~/Developer/indiebrain.github.io/themes")
  (setq op/theme 'indiebrain)
  (setq op/category-config-alist
    (cons '("resume"
        :show-meta nil
        :show-comment nil
        :uri-generator op/generate-uri
        :uri-template "/resume/"
        :sort-by :date
        :category-index nil)
          op/category-config-alist))
  (setq op/category-ignore-list
    (cons "resume" op/category-ignore-list))
  (setq op/category-ignore-list
    (cons "drafts" op/category-ignore-list)))
#+end_src

** Calendar and Diary (and indiebrain-diary.el)
:PROPERTIES:
:CUSTOM_ID: h:D0ECA629-C900-4FCF-A220-752B5ED5A784
:END:

Relevant information for what you are about to read in this section
(the list will be updated accordingly):

- [[https://protesilaos.com/codelog/2021-04-14-emacs-diary-calendar/][Video of Emacs Diary and Calendar for tracking appointments]] (2021-04-14).
- [[https://protesilaos.com/codelog/2021-04-15-emacs-diary-outline-minor-mode/][Make the Emacs Diary work as an Outline (outline-minor-mode)]] (2021-04-15).
- [[https://www.youtube.com/watch?v=n8o66i08fzs][Video on using Hyperbole with the Emacs Diary]] by the Emacs Elements
  channel (Raoul Comninos) (2021-04-16).

Emacs provides a suite of tools for planning events or recording dates
of interest in your life. These are part of the same workflow, but are
divided into several smaller libraries. The two main ones are
=diary-lib.el= and =calendar.el=. I extend them with =indiebrain-diary.el=, which is
reproduced at the end of this section, after the package configurations.

=diary-lib.el= defines everything that pertains to the =diary-file=
(defaults to =~/.emacs.d/diary=, which is NOT my preferred location of the
diary). The Diary has a two-fold purpose: (i) to store entries about
calendar events, and (ii) to display such events for the given day or
range thereof.

In the first case, the Diary functions as a regular buffer that you may
edit freely. This is where you can write one-off or recurring events
using various date and time formats expressed in natural language or as
Elisp forms (a sexp or "symbolic expression").

When it comes to single events for a given day, I prefer to input them
on a whole line using the ISO 8601 standard and a 24-hour clock, like
this: =2021-04-13 15:00 Description of event=.

For multiple events that are clustered on the same day, I write the date
on its own line and below it place a description of each event
optionally preceded by a timestamp. Entries with no timestamp come
first, followed by those that are time sensitive. This is just a matter
of personal style.

In this scenario of grouped events under a given date, each entry below
the date has to start with at least one empty space, otherwise the Diary
will try to interpret them as two distinct expressions (the exact number
of spaces is a matter of preference). So the format looks like this
(use =C-x TAB= (=indent-rigidly=) to incrementally adjust the indentation of
the active region, or =C-u C-x TAB= to increase by four spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

The following is also possible, but looks too busy for no good reason:

#+begin_example
2021-04-13 This event is not time sensitive
2021-04-13 06:30-09:00 Hiking
2021-04-13 10:00 Prepare sourdough bread
2021-04-13 11:00-13:00 Write stuff
#+end_example

Though not required, you can separate events by an empty line. Keeps
things easy to read. Remember that lines that contain at least one
space are thought to belong to the closest date entry above them. Which
means that for multiple events on a given day you can use something like
this, if you need to (here dots represent empty spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
....
    10:00 Prepare sourdough bread
....
    11:00-13:00 Write stuff
#+end_example

Furthermore, it is possible to use nested levels of indentation or, in
my case, call =indiebrain-simple-cite-region= and indent it accordingly (check
the source code: [[#h:0908107A-9CDA-4C20-B797-1FAA17F1880F][Common custom functions (indiebrain-simple.el)]]). For
example:

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
    +----[ Sample text ]
    | This is some random text
    | It relates to the above event
    +----
....
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

Remember that these are mere stylistic considerations. I generally
prefer to keep things simple, though I appreciate the flexibility of
adapting the view of my evolving needs.

I prefer to defer all formatting related decisions until after I have
typed in all the information. My =indiebrain-diary-align-timestamped-entries=
lets me align the negative space between an entry's timestamp and its
description. Consider the following block and suppose that the region
starts from the line below the date and ends at the end of the line with
the last entry (demarcated by the =|= characters).

#+begin_example
2021-04-13
|This event is not time sensitive
06:30-09:00 Hiking
10:00 Prepare sourdough bread
11:00-13:00 Write stuff|

...becomes...

2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00       Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

For anniversaries or cyclic events, I rely on Elisp. It is better to
read the Emacs manual on the technicalities as there are lots of
examples that should help you get started. Just bear in mind that the
exact order for the =YEAR=, =MONTH=, =DATE= arguments depends on the value
assigned to the variable =calendar-date-style=. As I already noted, I
follow the ISO style (evaluate this: =(format-time-string "%F")=).

The second use case of the Diary, namely, of showing the events it holds
is controlled by the variable =diary-display-function=. On my setup it
should present the information in a read-only buffer that is internally
referred to as the "fancy" style. To bring up that interface, you can
either use the Calendar as a starting point (more on that later) or call
a command directly, such as =indiebrain-diary-display-entries=. The
resulting buffer is fairly straightforward: there is a date header (or
many depending on the prefix numeric argument) and below that one or
more entries related to it. Those retain the indentation of the
underlying Diary file, as described above. Hit =RET= over an entry to
visit the editable version of the Diary.

Apart from displaying that buffer on demand, it is possible to get its
information emailed to you. The built-in command for that is
=diary-mail-days=, however it has the downside of sending a mail even when
there are no events for the day[s] specified. I do not see the utility
of such behaviour: what is the purpose of drawing attention to my email
client, only to waste my time with some "nothing to see here" message?
Whereas =indiebrain-diary-mail-entries= only sends a message when that is
the right thing to do, i.e. when there is something that requires our
attention (for N days or =diary-mail-days=). It also has the benefit of
not popping up the Diary display in another window as a side effect of
sending the email (check =indiebrain-diary--mail-fn= for the
technicalities). I set it up to automatically try to send me an email
briefing each morning when I launch Emacs.

Email briefings just offer an overview of events in the immediate
future. We still need a mechanism to alert us some minutes in advance of
a time sensitive appointment. This is where the =appt.el= library comes in
handy. It already knows how to scan the Diary in search for time
expressions and produce reminders for them: all it needs is to be
activated with =(appt-activate 1)=. Unlike email, this is a more
persistent method of producing notifications inside of Emacs in the form
of a pop-up window and a complementary modeline indicator with a
countdown to the event. The default notification time is specified in
the variable =appt-message-warning-time=, though individual Diary entries
can declare their own time (in minutes), by holding some extra text as
defined in =appt-warning-time-regexp=. Put that in a comment
(=diary-comment-start=) to disambiguate it from the entry's description.
For example, this Diary entry will work as expected with my
configurations: =2021-04-13 18:00 Some task ;; appt 5=. The =;; appt 5= part
will not be shown in the Diary display, but will still activate the
reminder. Nice and simple!

To recapitulate, the Diary is flexible enough to accommodate a variety of
preferences on how to organize one's life events. The key to get started
is to learn how to edit the actual file, which is fairly easy. It then
is trivial to either display that information on demand or be notified
about it.

Let us now cover the other major component of this suite of tools: the
Calendar. The main point of entry is =M-x calendar=. It displays a
horizontal three-month view centred on the current month. Moving in the
calendar is consistent with regular Emacs motions: =C-f= and =C-b= move one
day forward/backward, =C-n= and =C-p= go down and up one week, =C-a= and =C-e=
place the point at the beginning or end of the week, respectively. Then
we have the equivalent of paragraph and page motions: =M-{= and =M-}= which
travel forward/backward a full month, with =C-v= and =M-v= moving to the
next and previous three-month set. To merely scroll the horizontal
calendar strip, use =<= and =>= to do so in the given direction. As always,
do not forget to type =C-h m= (=describe-mode=) in any major-mode buffer you
are unfamiliar with to get help for it: you will learn about those
motions and some more of them (and always check the manual as well).

The Calendar offers an overview of your Diary entries, as noted above,
and, optionally, of all holidays that you have opted in to. For the
latter, check the variable =calendar-holidays=. I set it to only a small
set of records largely for experimental purposes, as I am not interested
in either religious or secular special days. Consider this, if you will,
an attempt at introducing the illusion of eventfulness in my calendar. I
really don't care about any of this.

To mark Diary entries in the Calendar, use =m= (=diary-mark-entries=). That
accepts a prefix argument (=C-u=) in case you wish to redraw those marks.
Here we should clarify that "marks" are Emacs faces by default, unless
you explicitly override them with characters. I prefer faces, which
leave a more pleasant, less noisy impression. Similarly, use =x=
(=calendar-mark-holidays=) to mark holidays. Both of those tasks can be
performed automatically upon accessing the Calendar, by setting the
variables =calendar-mark-diary-entries-flag=, =calendar-mark-holidays-flag=
to non-nil values (which is what I do).

Events that should not appear in the Calendar when Diary entries are
marked must be preceded with a special character, which is configurable
by means of =diary-nonmarking-symbol=. I personally have no use for this,
because if something is not worth being marked, then it is not pointless
to keep track of it in my day-to-day planner.

While in the Calendar, you can move the point over a marked day and type
=d= (=diary-view-entries=) to show the read-only variant of the Diary, as
outlined above. Or pass a number to it to encompass the Nth days (e.g.
typing =7 d= will show Diary entries for seven days starting from the
current one). If the mark pertains to a holiday, type =h= to get a message
in the echo area about it (=calendar-cursor-holidays=).

If you opt to use my settings, the best way to learn how to disambiguate
the two marks is to access the Calendar and hit =u= (=calendar-unmark=).
Follow it up with =m= to mark Diary entries and =x= to render holiday marks.

Other than viewing what happens on a given day or date range, you can
use the Calendar to record new entries in the Diary. I group those under
the =i= prefix key: so type, =i= and then =C-h= to get help about all possible
keys that complete that sequence and references to the commands they
call. Note that to insert a block event you need to hit =C-SPC= on the
starting date and then move point to the ending day at which you should
do =i b= (=diary-insert-block-entry=).

It is possible to use more faces than the ones which are provided by
default. To do so, you need to specify a face argument to the various
Elisp expressions that can be written to the Diary. For example, my
=indiebrain-diary.el= (reproduced further below) has a bespoke face for
"administrative tasks", which can be assigned to the given expression
like this (new line and indentation are optional, as mentioned above,
otherwise keep everything on one line):

#+begin_example
 %%(diary-date t t 13 'indiebrain-diary-calendar-administrative-mark)
     Some administrative monthly task
 %%(diary-anniversary 1900 4 13 'indiebrain-diary-calendar-anniversary-mark)
     Some anniversary is %d years
#+end_example

The manual covers a lot of other potentially useful tasks you may
accomplish with those tools. For example, it is possible to import an
iCalendar, convert from one calendar to another (e.g. Gregorian to
Chinese), get the phases of the moon, sunset and sunrise times in the
given geographic coordinates... Evaluate this expression to start
reading the relevant Info nodes: =(info "(emacs) Calendar/Diary")=.

For the integration with =outline-minor-mode= that =indiebrain-diary.el= provides,
refer to the relevant section (in short: you get header folding like in
Org for every line that starts with =;;;=, given my =diary-comment-start= is
=;;=): Outline mode, outline minor mode (indiebrain-outline.el).

Finally, note that I control the placement of those buffers in the
=display-buffer-alist= (read: Window rules and basic tweaks).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'calendar
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
    '(24-hours ":" minutes
           (when time-zone
             (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-date-display-form calendar-iso-date-display-form)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'solar)
  (setq calendar-latitude 39.952583         ; Not my actual coordinates
    calendar-longitude -75.165222)

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "-0400")
  (setq calendar-daylight-time-zone-name "-0500")

  (require 'diary-lib)
  (setq diary-file "~/.org/diary")
  (setq diary-mail-addr user-mail-address)
  (setq diary-date-forms diary-iso-date-forms)
  (setq diary-comment-start ";;")
  (setq diary-comment-end "")
  (setq diary-nonmarking-symbol "!")
  (setq diary-show-holidays-flag t)
  (setq diary-display-function #'diary-fancy-display) ; better than its alternative
  (setq diary-header-line-format nil)
  (setq diary-list-include-blanks nil)
  (setq diary-number-of-entries 2)
  (setq diary-mail-days 2)
  (setq diary-abbreviated-year-flag nil)

  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
  (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
  (add-hook 'diary-mode-hook #'goto-address-mode) ; buttonise plain text links

  ;; Those presuppose (setq diary-display-function #'diary-fancy-display)
  (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
  (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

  ;; Prevent Org from interfering with my key bindings.
  (remove-hook 'calendar-mode-hook #'org--setup-calendar-bindings)

  (let ((map calendar-mode-map))
    (define-key map (kbd "s") #'calendar-sunrise-sunset)
    (define-key map (kbd "l") #'lunar-phases)
    (define-key map (kbd "i") nil) ; Org sets this, much to my chagrin (see `remove-hook' above)
    (define-key map (kbd "i a") #'diary-insert-anniversary-entry)
    (define-key map (kbd "i b") #'diary-insert-block-entry)
    (define-key map (kbd "i c") #'diary-insert-cyclic-entry)
    (define-key map (kbd "i d") #'diary-insert-entry) ; for current "day"
    (define-key map (kbd "i i") #'diary-insert-entry) ; most common action, easier to type
    (define-key map (kbd "i m") #'diary-insert-monthly-entry)
    (define-key map (kbd "i w") #'diary-insert-weekly-entry)
    (define-key map (kbd "i y") #'diary-insert-yearly-entry)
    (define-key map (kbd "M-n") #'calendar-forward-month)
    (define-key map (kbd "M-p") #'calendar-backward-month)))

(indiebrain-emacs-builtin-package 'appt
  (setq appt-display-diary nil)
  (setq appt-disp-window-function #'appt-disp-window)
  (setq appt-display-mode-line t)
  (setq appt-display-interval 3)
  (setq appt-audible nil)
  (setq appt-warning-time-regexp "appt \\([0-9]+\\)")
  (setq appt-message-warning-time 15)

  (run-at-time 10 nil #'appt-activate 1))

(indiebrain-emacs-builtin-package 'indiebrain-diary
  ;; The idea is to get a reminder via email when I launch Emacs in the
  ;; morning and this file is evaluated. Obviously this is not a super
  ;; sophisticated approach, though I do not need one.
  (let ((time (string-to-number (format-time-string "%H"))))
    (when (and (> time 4) (< time 9))
      (run-at-time 30 nil #'indiebrain-diary-mail-entries)))

  (require 'holidays)
  (setq calendar-holidays (append holiday-solar-holidays indiebrain-diary-local-holidays))

  (with-eval-after-load 'indiebrain-outline
    (add-hook 'diary-mode-hook #'indiebrain-outline-minor-mode-safe))

  (let ((map diary-mode-map))
    (define-key map (kbd "<M-return>") #'indiebrain-diary-newline-indent)
    (define-key map (kbd "M-n") #'indiebrain-diary-heading-next)
    (define-key map (kbd "M-p") #'indiebrain-diary-heading-previous)
    (define-key map (kbd "C-c C-a") #'indiebrain-diary-align-timestamped-entries))
  (let ((map global-map))
    (define-key map (kbd "C-c d c") #'calendar)
    (define-key map (kbd "C-c d d") #'indiebrain-diary-display-entries)
    (define-key map (kbd "C-c d e") #'indiebrain-diary-edit-diary)
    (define-key map (kbd "C-c d i") #'indiebrain-diary-insert-entry)
    (define-key map (kbd "C-c d m") #'indiebrain-diary-mail-entries)))
#+end_src

These are the contents of the =indiebrain-diary.el= library (find the source
code in [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-diary.el src emacs-lisp :tangle no

** Elfeed feed reader (indiebrain-elfeed.el)
:PROPERTIES:
:CUSTOM_ID: h:37503F24-DDED-4141-84FA-A1F385C07F1F
:END:

This is a standalone feed reader by Christopher Wellons that comes with
good defaults and is very well designed overall. It treats the stream of
updates as a flat list that can be narrowed incrementally using an
efficient tagging system.

In terms of feed format specifications, i.e. Atom vs RSS, things should
just work without any kind of configuration from your side (a huge plus
compared to, say, Gnus' =nnrss= backend that only supports the latter).

Elfeed stores feed sources in a single list that associates a valid URL
to one or more tags. These are then written to a database. The Elisp
part users should care about looks like this:


#+begin_example
(setq elfeed-feeds
      '(("https://www.debian.org/News/news" technology linux distro)
    ("https://www.ruby-lang.org/en/feeds/news.rss" technology programming)
    ("https://www.fsf.org/static/fsforg/rss/news.xml" technology community)
    ("https://aaronkuehler.com/rss.xml" personal)))
#+end_example

I keep the actual list in a GPG-encrypted file (defined in the variable
=indiebrain-elfeed-feeds-file= which is part of my =indiebrain-elfeed.el=
library that is reproduced after the following package configurations).
Emacs can transparently decrypt and read gpg-protected files, making it
a great way to safely store sensitive data while still keeping
everything perfectly functional.

A good tagging system for your feeds will offer a strong foundation for
catching up with the news. I generally use 2-3 tags per feed, while I
make sure that conceptually similar items will share at least one tag.
My tags are not particularly sophisticated, though they are not random
either: for example, I have a particular "technology" entry for all
manner of programming and/or hardware news and then I have other more
specific ones, such as "programming", and "culture". So, in this case,
Ruby language news is tagged =technology=, =programming=, while
communications from the Free Software Foundation is =technology=,
=community=.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'elfeed
  (setq elfeed-use-curl t)
  (setq elfeed-curl-max-connections 10)
  (setq elfeed-db-directory (concat user-emacs-directory "elfeed/"))
  (setq elfeed-enclosure-default-dir "~/Downloads/")
  (setq elfeed-search-filter "@4-months-ago +unread")
  (setq elfeed-sort-order 'descending)
  (setq elfeed-search-clipboard-type 'CLIPBOARD)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-title-min-width 30)
  (setq elfeed-search-trailing-width 25)
  (setq elfeed-show-truncate-long-urls t)
  (setq elfeed-show-unique-buffers t)
  (setq elfeed-search-date-format '("%F %R" 16 :left))

  ;; Make sure to also check the section on shr and eww for how I handle
  ;; `shr-width' there.
  (add-hook 'elfeed-show-mode-hook
        (lambda () (setq-local shr-width (current-fill-column))))

  (define-key global-map (kbd "C-c e") #'elfeed)
  (let ((map elfeed-search-mode-map))
    (define-key map (kbd "w") #'elfeed-search-yank)
    (define-key map (kbd "g") #'elfeed-update)
    (define-key map (kbd "G") #'elfeed-search-update--force))
  (let ((map elfeed-show-mode-map))
    (define-key map (kbd "w") #'elfeed-show-yank))

(with-eval-after-load 'elfeed
  (indiebrain-emacs-builtin-package 'indiebrain-elfeed
    (setq indiebrain-elfeed-tag-faces t)
    (indiebrain-elfeed-fontify-tags)
    (add-hook 'elfeed-search-mode-hook #'indiebrain-elfeed-load-feeds)
    (let ((map elfeed-search-mode-map))
      (define-key map (kbd "s") #'indiebrain-elfeed-search-tag-filter)
      (define-key map (kbd "o") #'indiebrain-elfeed-search-open-other-window)
      (define-key map (kbd "q") #'indiebrain-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "+") #'indiebrain-elfeed-toggle-tag))
    (let ((map elfeed-show-mode-map))
      (define-key map (kbd "a") #'indiebrain-elfeed-show-archive-entry)
      (define-key map (kbd "e") #'indiebrain-elfeed-show-eww)
      (define-key map (kbd "q") #'indiebrain-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "+") #'indiebrain-elfeed-toggle-tag)))))
#+end_src

This is =indiebrain-elfeed.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-elfeed.el src emacs-lisp :tangle no

** Proced (process monitor, similar to =top=)
:PROPERTIES:
:CUSTOM_ID: h:329207F4-0EE8-456E-8564-C895160FFB0D
:END:

Emacs has a built in process monitor, similar to =top=, called =proced=.
This section configured =proced= to display only processes from the
current user, and auto-update the process list. Additionally, the live
list of processes can be filtered by a narrowing-search - initiated by
the =/= key.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'proced
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 1)
  (setq proced-descend t)
  (setq proced-filter 'user))
#+end_src

** Simple HTML Renderer (shr), Emacs Web Wowser (eww), and indiebrain-eww.el
:PROPERTIES:
:CUSTOM_ID: h:44B2990D-6DCF-4256-BF2F-7158052644D3
:END:

The following code block encompasses libraries that power Emacs' web
browsing experience.

- =browse-url= determines what Emacs should do when the user follows a
  link to the Internet. For my purposes, I configure it to open the web
  page inside of Emacs, while I let the Desktop Environment's default
  graphical browser be declared as a secondary option. Put simply, when
  I click on a URL, I go to an EWW buffer and from there I can opt to
  open that page in the GUI browser via =eww-browse-with-external-browser=
  which is bound to =&=. That is only ever needed for websites that do not
  work well in a text-centric interface.

- =shr= is the "Simple HTML Renderer", which basically means to interpret
  the underlying code of a web page and show it in the way it is
  intended for the end user. Unlike graphical web browsers, =shr=
  capabilities are limited, because it does not use style sheets (CSS)
  and more demanding resources (javascript, embedded multimedia, etc.).

- =eww= is what we use to browse the Web. It effectively is the front-end
  to =shr=, adding on top of it the layer of interactivity that is
  expected of a basic browser, such as to keep a history of visited
  pages, handle bookmarks, navigate through links, and the like. As
  always, remember to read the manual of EWW, such as by evaluating this
  form: =(info "(eww) Top")=. It is short and should give you an idea of
  what its features are.

- =indiebrain-eww= adds commands that align EWW with my expectations and
  make it do what I want to achieve in a primarily text-based web
  browsing experience.

My configurations for =browse-url= and =shr= are straightforward and are
meant to keep things simple. I want EWW to behave like the rest of
Emacs, which means that it should not try to introduce random colours
from web pages, nor use its own fonts. Both intefere with the
consistency I seek in my computing environment (and why I use Emacs to
begin with).

For =eww=, I repurpose some of its key bindings that I never plan to use,
such as the toggle for proportional fonts, while I move around a few
others. Just to make things easier for me.

As for =indiebrain-eww=, it includes functionality that make EWW good
enough for my day-to-day needs. In particular:

- It includes an unconditional internal mechanism that renames EWW
  buffers based on the rendered web page's title or, when that is not
  available, the URL. This ensures that I can maintain multiple buffers
  without getting lost in the noise of what would otherwise be an
  awkward naming scheme in the form of =*eww*=, =*eww<2>*= and so on. Now it
  looks like =*Emacs - ArchWiki # eww*=, with a possible number identifier
  added only for duplicate entries.

- The variable =indiebrain-eww-visited-history= records the URL of every
  rendered page. This is then used by =indiebrain-eww-browse-dwim= (more
  below). To keep things in check, =indiebrain-eww-visited-history= is
  implemented as a minibuffer history which is ultimately limited to the
  value of =history-length= (read: [[#h:5E6FFCFA-74BC-47A6-9799-CEBEDA82AFB9][Minibuffer history (savehist-mode)]]).
  Remember that each command can have its own history and this is common
  in a lot of my extras.

- The =indiebrain-eww-browse-dwim= is my main point of entry to EWW. When
  I call it from a random place inside of Emacs, it just offers a prompt
  that asks for a URL or search terms with which to query DuckDuckGo. In
  addition, it reads through a history of such inputs, so that =M-p=, =M-n=
  can quickly give me something I tried before. Plus it supports
  completion (check the mega-section [[#h:efcb1075-f3de-4a66-b7fd-6f3db1813d64][Completion framework and extras]]).
  When this command is called from inside an EWW buffer it retains the
  aforementioned functionality, but its prompt is pre-populated with the
  URL of the current page. This is particularly useful for editing the
  path directly, such as to go from =https://github.com/indiebrain/.files=
  to =https://github.com/indiebrain=. When called with a universal prefix
  argument (=C-u=), it opens a new EWW buffer instead of using the last
  one.

- =indiebrain-eww-search-engine= offers selection among the custom search
  commands I define, such as to query Wikipedia directly or search for a
  bug number in the Emacs issue tracker. Those search engine commands
  can be invoked on their own, while each of them has its own minibuffer
  history (so if you searched for "elephant" in Wikipedia, you will not
  get that for the Arch Wiki).

- =indiebrain-eww-bookmark-page= does what its name suggests though, unlike the
  built-in equivalent, it first asks for how to name the bookmarked
  entry before storing it in the relevant memory compartment.

- =indiebrain-eww-visit-bookmark= prompts with completion to visit an entry in
  EWW's bookmark list. A =C-u= prefix means to open it in a new EWW
  buffer.

- =indiebrain-eww-visit-url-on-page= traverses the entire web page to construct
  a list of all links and their anchor text. The list can be narrowed
  with completion. Selecting a item with visit its corresponding web
  page.

- =indiebrain-eww-jump-to-url-on-page= is similar to the above, with the
  major difference that it only stores buffer positions and jumps to
  them. This makes it ideal for generating an ad-hoc index of "points of
  interest" in the current buffer with the help of Embark's ability to
  collect a list of candidates into a bespoke buffer (make sure to check
  [[#h:E4A448DA-159D-4BDB-AE29-1118088EFE9D][Extended minibuffer actions and more (embark.el and
  indiebrain-embark.el)]]). Of course, it can be used on its own to jump
  around the web page. Upon jumping, the line will pulse momentarily to
  help keep a sense of context (also read: indiebrain-pulse.el
  (highlight cursor position)).

- =indiebrain-eww-find-feed= inspects the source code of the current web
  page and produces an =occur= buffer with links that represent RSS or
  Atom feeds. This command is quite useful for retrieving the feed of a
  website whose designers failed to provide a user-facing link for it
  (which is the norm nowadays). I read feeds on a daily basis: it is the
  best way to keep track of updates to web pages (read section Elfeed
  feed reader, indiebrain-elfeed.el and indiebrain-elfeed-bongo.el).

- =indiebrain-eww-readable= is a more opinionated take on the built-in
  option. It specifies a narrower =shr-width=, specifically at the 72
  character limit which is my =current-fill-column=. Furthermore, it
  reduces images to a maximum of 0.35 of the window's width/height. This
  is not always a good approach, though it works most of the time for
  the kind of content I am interested in: text-heavy articles.

- =indiebrain-eww-download-html= downloads the current web page as an =.html=
  file. It asks for a name to give to it, defaulting to the title of
  the page, and it also prepends the current date and time. To ensure
  that the file name is easily accessible with Unix tools, all
  punctuation marks and spaces are removed or replaced with hyphens. So
  if the page is titled ="GNU Emacs manual | My ‘cool’ "website"!?"= the
  saved file will be processed and stored as a filesystem path like
  =~/Downloads/eww/20210324_185035--gnu-emacs-manual-my-cool-website.html=.
  I find that this is superior to the generic =eww-download= which neither
  asks for a name, nor adds a date and file type extension. Where
  =eww-download= still excels is for downloading the link at point, when
  that is not an HTML file (e.g. a pdf or zip archive).

- =indiebrain-eww-open-in-other-window= is meant to open the link at point
  in a new buffer and in another window. It complements the default
  =M-RET= (=eww-open-in-new-buffer=) which re-uses the same window.

Some final tips:

- =g= reloads the web page by fetching it anew over the network, while its
  =C-u g= counterpart re-renders what has already been downloaded. The
  latter is useful when, for example, you have a new window
  configuration and wish to fit the EWW buffer's contents in the window.

- As already noted above, several commands that open an EWW buffer
  accept a =C-u= prefix to put their contents in a new buffer rather than
  re-use the existing one. With =M-RET= over a link in an EWW buffer, you
  can do the same.

- When point is over an image, the =shr-image-map= gets activated. This
  allows you to run commands such as =image-increase-size=, bound to =+=,
  and =image-decrease-size= on =-=. This means that you can always view an
  image at an appropriate size, regardless of whether its initial
  dimensions were affected by =shr-max-image-proportion= and the size of
  the window holding the EWW buffer.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'browse-url
  (setq browse-url-browser-function 'eww-browse-url)
  (setq browse-url-secondary-browser-function 'browse-url-default-browser))

(indiebrain-emacs-builtin-package 'shr
  (setq shr-use-colors nil)             ; t is bad for accessibility
  (setq shr-use-fonts nil)              ; t is not for me
  (setq shr-max-image-proportion 0.6)
  (setq shr-image-animate nil)          ; No GIFs, thank you!
  (setq shr-width nil)                  ; check `indiebrain-eww-readable'
  (setq shr-discard-aria-hidden t)
  (setq shr-cookie-policy nil))

(indiebrain-emacs-builtin-package 'eww
  (setq eww-restore-desktop t)
  (setq eww-desktop-remove-duplicates t)
  (setq eww-header-line-format nil)
  (setq eww-search-prefix "https://duckduckgo.com/html/?q=")
  (setq eww-download-directory (expand-file-name "~/Downloads/eww"))
  (setq eww-suggest-uris
    '(eww-links-at-point
      thing-at-point-url-at-point))
  (setq eww-bookmarks-directory (locate-user-emacs-file "eww-bookmarks/"))
  (setq eww-history-limit 150)
  (setq eww-use-external-browser-for-content-type
    "\\`\\(video/\\|audio\\)") ; On GNU/Linux check your mimeapps.list
  (setq eww-browse-url-new-window-is-tab nil)
  (setq eww-form-checkbox-selected-symbol "[X]")
  (setq eww-form-checkbox-symbol "[ ]")
  ;; NOTE `eww-retrieve-command' is for Emacs28. I tried the following
  ;; two values. The first would not render properly some plain text
  ;; pages, such as by messing up the spacing between paragraphs. The
  ;; second is more reliable but feels slower. So I just use the
  ;; default (nil), though I find wget to be a bit faster. In that case
  ;; one could live with the occasional errors by using `eww-download'
  ;; on the offending page, but I prefer consistency.
  ;;
  ;; '("wget" "--quiet" "--output-document=-")
  ;; '("chromium" "--headless" "--dump-dom")
  (setq eww-retrieve-command nil)

  (define-key eww-link-keymap (kbd "v") nil) ; stop overriding `eww-view-source'
  (define-key eww-mode-map (kbd "L") #'eww-list-bookmarks)
  (define-key dired-mode-map (kbd "E") #'eww-open-file) ; to render local HTML files
  (define-key eww-buffers-mode-map (kbd "d") #'eww-bookmark-kill)   ; it actually deletes
  (define-key eww-bookmark-mode-map (kbd "d") #'eww-bookmark-kill)) ; same

(indiebrain-emacs-builtin-package 'indiebrain-eww
  (define-prefix-command 'indiebrain-eww-map)
  (define-key global-map (kbd "C-c w") 'indiebrain-eww-map)
  (define-key global-map (kbd "s-w") 'indiebrain-eww-map)
  (let ((map indiebrain-eww-map))
    (define-key map (kbd "b") #'indiebrain-eww-visit-bookmark)
    (define-key map (kbd "e") #'indiebrain-eww-browse-dwim)
    (define-key map (kbd "f") #'indiebrain-eww-search-duckduckgo)
    (define-key map (kbd "d") #'indiebrain-eww-search-debbugs)
    (define-key map (kbd "w") #'indiebrain-eww-search-wikipedia)
    (define-key map (kbd "s") #'indiebrain-eww-search-engine))
  (let ((map eww-mode-map))
    (define-key map (kbd "B") #'indiebrain-eww-bookmark-page)
    (define-key map (kbd "D") #'indiebrain-eww-download-html)
    (define-key map (kbd "F") #'indiebrain-eww-find-feed)
    (define-key map (kbd "b") #'indiebrain-eww-visit-bookmark)
    (define-key map (kbd "e") #'indiebrain-eww-browse-dwim)
    (define-key map (kbd "o") #'indiebrain-eww-open-in-other-window)
    (define-key map (kbd "E") #'indiebrain-eww-visit-url-on-page)
    (define-key map (kbd "J") #'indiebrain-eww-jump-to-url-on-page)
    (define-key map (kbd "R") #'indiebrain-eww-readable)))
#+end_src

And here is =indiebrain-eww.el= in its entirety. It is available as a file in
[[https://github.com/indiebrain/.files/][my dotfiles' repo]]:

#+include: indiebrain-lisp/indiebrain-eww.el src emacs-lisp :tangle no

** Extensions for PDFs (pdf-tools)
:PROPERTIES:
:CUSTOM_ID: h:07311906-3D04-41DD-BC2F-CFC74F9E4C04
:END:

The =pdf-tools= package builds on top of the external libraries, =poppler=
and =imagemagick= (if Emacs is compiled with support for it) to deliver a
series of minor modes for reading and interacting with PDF files from
inside of Emacs. As it depends on those external files, it requires
extra steps to make it work properly. Those are documented at length in
its README and vary depending on your operating system.

All you need to start reading PDFs is to put the =pdf-loader-install=
function in your configurations, which loads the tools once you open an
appropriate file, such as through =dired= or with =find-file=. Once inside
the resulting buffer, do =C-h m= (=describe-mode=) to learn about the key
bindings and the commands they call. The basics:

| Key   | Effect            |
|-------+-------------------|
| +     | Enlarge (zoom in) |
| -     | Shrink (zoom out) |
| 0     | Reset zoom        |
| C-n   | Next line         |
| C-p   | Previous line     |
| SPC   | Scroll down       |
| S-SPC | Scroll up         |

To determine which minor modes out of the entire suite are activated,
you need to configure the variable =pdf-tools-enabled-modes=. I reduce it
only a subset of what is available by default because I do not need all
the extras. That granted, there are at least two minor modes that users
may find helpful: =pdf-annot-minor-mode= which provides annotation
capabilities and =pdf-sync-minor-mode= which syncs the PDF with its
corresponding TeX file when you are running some setup that compiles the
latter to the former.

The value proposition of =pdf-tools= is that it works with =isearch= and
=occur= so you can easily (i) search through the file and (ii) produce a
buffer of locations with matching queries. As is the norm with
=pdf-tools=, those facilities are implemented as minor modes:
=pdf-isearch-minor-mode=, =pdf-occur-global-minor-mode= (this also works
with =ibuffer= and =dired=).

Another helpful integration is with Emacs' =outline-mode= and =imenu= by
means of =pdf-outline-minor-mode=. Simply hit =o= while viewing a PDF to
produce an outline of the document and then, optionally, =M-x imenu= to
navigate it using minibuffer completion (though for the latter task you
may prefer something like =consult-outline=, which is part of the Consult
package: Enhanced minibuffer commands (consult.el and
indiebrain-consult.el)).

Finally, I have some tweaks to change the backdrop of the buffer so that
it is distinct from the page's background while using the light Modus
Operandi theme ([[#h:e8c1d68e-aebf-499c-b394-807fbd525624][Load the color-theme (modus-themes)]]). Plus, I make it
automatically adapt to the =modus-themes-toggle= command, so that the PDF
switches to a dark theme when it has to. Those are documented in the
manual of the themes. If you are using them, evaluate this form: =(info
"(modus-themes) Backdrop for pdf-tools (DIY)")=.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'pdf-tools
  (setq pdf-tools-enabled-modes         ; simplified from the defaults
    '(pdf-history-minor-mode
      pdf-isearch-minor-mode
      pdf-links-minor-mode
      pdf-outline-minor-mode
      pdf-misc-size-indication-minor-mode
      pdf-occur-global-minor-mode))
  (setq pdf-view-display-size 'fit-height)
  (setq pdf-view-continuous t)
  (setq pdf-view-use-dedicated-register nil)
  (setq pdf-view-max-image-width 1080)
  (setq pdf-outline-imenu-use-flat-menus t)

  (pdf-loader-install)

  ;; Those functions and hooks are adapted from the manual of the
  ;; modus-themes. The idea is to (i) add a backdrop that is distinct
  ;; from the background of the PDF's page and (ii) make pdf-tools adapt
  ;; to theme switching via, e.g., `modus-themes-toggle'.
  (defun indiebrain/pdf-tools-backdrop ()
    (face-remap-add-relative
     'default
     `(:background ,(modus-themes-color 'bg-alt))))

  (defun indiebrain/pdf-tools-midnight-mode-toggle ()
    (when (derived-mode-p 'pdf-view-mode)
      (if (eq (car custom-enabled-themes) 'modus-vivendi)
      (pdf-view-midnight-minor-mode 1)
    (pdf-view-midnight-minor-mode -1))
      (indiebrain/pdf-tools-backdrop)))

  (add-hook 'pdf-tools-enabled-hook #'indiebrain/pdf-tools-midnight-mode-toggle)
  (add-hook 'modus-themes-after-load-theme-hook #'indiebrain/pdf-tools-midnight-mode-toggle))
#+end_src

** Representational State Transfer Client (REST API Client)
:PROPERTIES:
:CUSTOM_ID: h:A0F56FF1-0AA1-4201-BD62-00FD4D98C9BE
:END:

The =restclient= package turns Emacs into a fully featured development
tool for interacting with RESTful APIs. Buffers become areas for
defining web requests - resoruce paths, query parameters, request
bodies, etc. Additionally, =resclient= buffers can take advantage of
Emacs, and =emacs-lisp= to pragmatically define requests. The table blow
is but a sample of the most frequent interactions with this mode:


| Key chord | Description                                                                           |
|-----------+---------------------------------------------------------------------------------------|
| =C-c C-c=   | Run the query at the point                                                            |
| =C-c C-p=   | Jump to the previous query                                                            |
| =C-c C-n=   | Jump to the next query                                                                |
| =C-c C-u=   | Yank the query at the point to the kill ring (and system clipboard) as a cURL command |

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'restclient
    (add-to-list 'auto-mode-alist '("\\.rest$" . restclient-mode)))
#+end_src

** Git backed note taking (gist-mode)

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'gist
  (define-key global-map (kbd "C-x g l") #'gist-list)
  (define-key global-map (kbd "C-x g c b") #'gist-region-or-buffer-private))
#+end_src
* General interface and interactions
:PROPERTIES:
:CUSTOM_ID: h:2fe25adb-7f53-4c86-9e6c-4a9a96781dac
:END:

This section contains configurations for all aspects of the Emacs user
interface, as well lots of small or self-contained tweaks that cover a
wide range of built-in libraries.

** Automatically save buffers
:PROPERTIES:
:CUSTOM_ID: h:0B6C84D3-9A82-42BA-8AD0-2A1134BA1533
:END:

This configuration makes Emacs automatically save buffers when:

- The buffer loses focus
- Emacs has been idle for 5 or more seconds

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'super-save
  (setq super-save-auto-save-when-idle t)
  (setq super-save-idle-duration 5)
  (super-save-mode t))
#+end_src

** Go to actionable beginning or end of buffer (beginend.el)
:PROPERTIES:
:CUSTOM_ID: h:48B7B87C-6F70-4AA4-8F63-C8518DCD0ED6
:END:

This package by Damien Cassou offers the means to move to the first or
last actionable point in a buffer rather than the absolute maximum or
minimum point. It does so by wrapping =M-<= and =M->= around a "do what I
mean" behaviour where the initial command will take you to the
actionable part, while another call will go to the absolute position.
Nice and simple!

Check [[https://github.com/DamienCassou/beginend][the package upstream]] for information on the supported modes and on
how to contribute your own extensions.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'beginend
  (beginend-global-mode 1))
#+end_src

** Go to last change (goto-last-change)
:PROPERTIES:
:CUSTOM_ID: h:4EAF7B30-258E-4CE0-A2B2-0E4F70337B53
:END:

I could not find any built-in method of /reliably/ moving back to the last
change. Using the mark ring is always an option, but does not fill the
exact same niche.

The =C-z= binding is disabled elsewhere in this document. It minimises the
Emacs GUI by default. A complete waste of an extremely valuable key
binding!

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'goto-last-change
  (define-key global-map (kbd "C-z") #'goto-last-change))
#+end_src

** Expand and contract regions (expand-region)
:PROPERTIES:
:CUSTOM_ID: h:41A87044-ED1A-4290-9838-987AF803F361
:END:

When selecting regions, it is sometimes quicker or more cognitively
convenient, to expand or contract a region based on contextual units.
For example, expanding from a character, to a word, to a sentence, to a
paragraph, and so on.

This is the role of the =expand-region= package. Additionally,
=expand-region= is syntactically aware and smart enough to work within
most of the programming major modes - allowing for simple selection of
atoms and constructs within the syntax of a program.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'expand-region
  (let ((map global-map))
    (define-key map (kbd "C-=") 'er/expand-region)
    (define-key map (kbd "C--") 'er/contract-region)))
#+end_src
** Mode line
:PROPERTIES:
:CUSTOM_ID: h:38419AC4-6729-484C-821B-1EC1FB734369
:END:

The mode line is an integral part of the Emacs interface. While there
are lots of third party packages that style it in a variety of ways, I
find the default to be "good enough".

In the code snippet right below I reshuffle some of the mode line
indicators. Nothing too fancy. The =mode-line-defining-kbd-macro= is
tweaked to use a more appropriate string for its indicator and to apply
colours that are designed specifically for the mode line (the default
uses the generic font-lock warning face).

Note that in [[#h:DE9C418F-0C2D-4C3B-A4DF-AFE8BE0AB8BA][Custom extensions for "focus mode" (indiebrain-logos.el)]] I
provide a snippet that optionally toggles the visibility of the modeline
while entering a bespoke "focus mode" for writing/reading.

#+begin_src emacs-lisp
(setq mode-line-percent-position '(-3 "%p"))
(setq mode-line-position-column-line-format '(" %l,%c")) ; Emacs 28
(setq mode-line-defining-kbd-macro
      (propertize " Macro" 'face 'mode-line-emphasis))

;; Thanks to Daniel Mendler for this!  It removes the square brackets
;; that denote recursive edits in the modeline. I do not need them
;; because I am using Daniel's `recursion-indicator':
;; <https://github.com/minad/recursion-indicator>.
(setq-default mode-line-modes
          (seq-filter (lambda (s)
                (not (and (stringp s)
                      (string-match-p
                       "^\\(%\\[\\|%\\]\\)$" s))))
              mode-line-modes))

(setq mode-line-compact nil)            ; Emacs 28
(setq-default mode-line-format
          '("%e"
        mode-line-front-space
        mode-line-mule-info
        mode-line-client
        mode-line-modified
        mode-line-remote
        mode-line-frame-identification
        mode-line-buffer-identification
        "  "
        mode-line-position
        mode-line-modes
        "  "
        (vc-mode vc-mode)
        "  "
        mode-line-misc-info
        mode-line-end-spaces))
#+end_src

In the following sub-sections I provide customisations for some tools
that place information on the mode line. Again, nothing flamboyant.

*** Moody (simple modeline configuration utility
:PROPERTIES:
:CUSTOM_ID: h:0A4B927D-FF9D-4516-9C3D-CA3BC0D03222
:END:

=moody.el= is a lightweight library that adds some flair to the mode line
without complicating things. It is developed by Jonas Bernoulli. I have
been using it on and off to make sure that it works well with my themes
(see [[#h:e8c1d68e-aebf-499c-b394-807fbd525624][Load the color-theme (modus-themes)]]).

My fairly minor tweaks in =indiebrain-moody.el= (reproduced further below)
align Moody with my [[#h:8C74519F-4C17-4E61-8D35-E5AA89F37C6C][Font configurations (indiebrain-fonts.el)]]. What I
basically want is to make the mode line gracefully adapt to changes in
font size.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'moody)

(indiebrain-emacs-builtin-package 'indiebrain-moody
  ;; Adjust this and then evaluate `indiebrain-moody-set-height'. Not all
  ;; fonts work equally well with the same value.
  (setq indiebrain-moody-font-height-multiplier 1.35)

  ;; Also check the Modus themes' `modus-themes-mode-line' which can set
  ;; the styles specifically for Moody.
  (indiebrain-moody-set-height 1))
#+end_src

Here are my tweaks (from [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-moody.el src emacs-lisp :tangle no

*** Hide modeline "lighters" (minions.el)
:PROPERTIES:
:CUSTOM_ID: h:F835E53E-AEC0-4EE4-88B9-85FB5C586996
:END:

This package by Jonas Bernoulli neatly wraps up all minor mode
"lighters" and hides them behind a single character. The "lighter" is
the text that identifies the minor mode on the mode line. Having a few
of them is usually okay, but a lot of them do not scale well.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'minions
  (setq minions-mode-line-lighter ";")
  ;; NOTE: This will be expanded whenever I find a mode that should not
  ;; be hidden
  (setq minions-direct (list 'defining-kbd-macro
                 'flymake-mode
                 'indiebrain-simple-monocle))
  (minions-mode 1))
#+end_src

*** Mode line recursion indicators
:PROPERTIES:
:CUSTOM_ID: h:414C96F9-CA8B-4F12-B9CC-453B59D9D28A
:END:

This utility by Daniel Mendler provides a couple of indicators for
denoting minibuffer recursion. They offer a reminder that we are in the
midst of a recursive editing session when we should, perhaps, not be in
one. I consider =recursion-indicator= complementary to what is already
built into Emacs in the form of =minibuffer-depth-indicate-mode= which
shows the level of recursion at the current minibuffer prompt (refer to
[[#h:813B4DC2-EB36-4825-90EE-299CA53A9AD1][Minibuffer configurations and extras (indiebrain-minibuffer.el)]]).

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'recursion-indicator
  (setq recursion-indicator-general "&")
  (setq recursion-indicator-minibuffer "@")
  (recursion-indicator-mode 1))
#+end_src

*** Battery status
:PROPERTIES:
:CUSTOM_ID: h:493F5F5E-6B6A-475F-86A5-E77AD4D0A70D
:END:

Emacs offers a built-in library for presenting information about the
status of the laptop's battery. Using it allows me to eliminate my
reliance on the system panel and thus keep Emacs in full screen view
without any interruptions.

The default update interval is set to a single minute (in seconds),
which is generally fine though I find that a slightly higher value works
just as well. As for the format, it is designed to show a
context-dependent, single character indicator about the current status,
as well as the battery's overall percentage.

Variable =battery-mode-line-limit= will hide the indicator if the value is
above the declared threshold. 95 basically means "full" for me. I use
that instead of a 100 because sometimes the battery only ever fills up
to a lower threshold, meaning that the indicator remains present at all
times.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'battery
  (setq battery-mode-line-format " [%b%p%%]")
  (setq battery-mode-line-limit 95)
  (setq battery-update-interval 180)
  (setq battery-load-low 20)
  (setq battery-load-critical 10)
  (add-hook 'after-init-hook #'display-battery-mode))
#+end_src

*** Display current time
:PROPERTIES:
:CUSTOM_ID: h:5C966CF2-FB57-4916-8562-AD381E64DD0A
:END:

I normally use Emacs in fullscreen view. No system panels, no window
decorations, no icons and blinking indicators. Nothing to distract me.
While I really like this environment, sometimes I need to take a look at
the time… Thankfully Emacs offers a convenient, built-in way of
displaying such information in the mode line.

The =display-time-format= can be configured to show the current date and
time in all the various formats we would expect, using a string of
specifiers (find the docs with =C-h v format-time-string=). Setting its
value to =nil= means that the information on display will be the combined
result of =display-time-24hr-format= and =display-time-day-and-date=. I
prefer to just write a string directly, keeping those two inactive.

The =display-time-mode= can output more than just the current time. It
also shows the load average and an email indicator. I do not need the
load average as it adds too much noise. As for the mail indicator, I
don't yet use Emacs for mail - I know, I've tried but I haven't yet
found a suitable setup for my particular needs.

Lastly, I use the =world-clock= command (for Emacs28+) when I need to get
an overview of the current time in various parts of the planet.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'time
  (setq display-time-format "%Y-%m-%d  %H:%M")
  ;;;; Covered by `display-time-format'
  ;; (setq display-time-24hr-format t)
  ;; (setq display-time-day-and-date t)
  (setq display-time-interval 60)
  (setq display-time-default-load-average nil)
  (setq display-time-mail-directory nil)
  (setq display-time-mail-function nil)
  (setq display-time-use-mail-icon nil)
  (setq display-time-mail-string nil)
  (setq display-time-mail-face nil)

  ;;; World clock
  ;;;
  ;;; Useful list of zones: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
  ;;;
  (setq zoneinfo-style-world-list

        '(("Australia/Brisbane" "Brisbane")
          ("Europe/London" "London")
          ("America/New_York" "New York")
          ("America/Chicago" "Chicago")
          ("America/Los_Angeles" "Los Angeles")))

  ;; All of the following variables are for Emacs 28
  (setq world-clock-list t)
  (setq world-clock-time-format "%R %z  %A %d %B")
  (setq world-clock-buffer-name "*world-clock*") ; Placement handled by `display-buffer-alist'
  (setq world-clock-timer-enable t)
  (setq world-clock-timer-second 60)

  (add-hook 'after-init-hook #'display-time-mode))
#+end_src

*** Keycast mode
:PROPERTIES:
:CUSTOM_ID: h:9C60CE85-52A2-43CC-A9A7-33B5FFE34F1C
:END:

Once enabled, this package uses the mode line to show the keys being
pressed and the command they call. It is quite useful for screen
casting.

The placement of the indicator is controlled by =keycast-window-predicate=
which I set to the current window. The =moody.el= library offers that
specific piece of functionality (though I also configure Moody for its
primary purpose of styling the mode line).

The tweaks to the =keycast-substitute-alist= prevent the display of
self-inserting characters and some other commands that are not
particularly useful while screen casting. Now the indicator will only
show commands, which looks cleaner. I got the idea and original piece
of Elisp from the [[https://github.com/aadcg/dotfiles][dotfiles of André Alexandre Gomes]] and then added a few
tweaks of my own.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'keycast
  ;; Those are for `keycast-mode'
  (setq keycast-window-predicate 'moody-window-active-p) ; assumes `moody.el'
  (setq keycast-separator-width 1)
  (setq keycast-remove-tail-elements nil)

  (dolist (input '(self-insert-command
           org-self-insert-command))
    (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))

  (dolist (event '(mouse-event-p
           mouse-movement-p
           mwheel-scroll))
    (add-to-list 'keycast-substitute-alist `(,event nil)))

  ;; Those are for the `keycast-log-mode'
  (setq keycast-log-format "%-20K%C\n")
  (setq keycast-log-frame-alist
    '((minibuffer . nil)))
  (setq keycast-log-newest-first t)

  ;; Specify `keycast-insert-after' buffer identification. This make it
  ;; possible to seamlessly toggle `indiebrain-moody-set-height' without
  ;; disrupting keycast.
  (with-eval-after-load 'indiebrain-moody
    (add-hook 'indiebrain-moody-set-height-hook #'indiebrain-moody-keycast-insert-after)))
#+end_src

** Window divider mode
:PROPERTIES:
:CUSTOM_ID: h:1C9A434D-D153-4E35-AB15-4B8F246B3A50
:END:

This is a built-in mode that draws vertical window borders in a slightly
different way than the default, which I find more consistent. Only using
it because of that, though it can also adjust the size of the borders as
well as their placement.

#+begin_src emacs-lisp
(setq window-divider-default-right-width 1)
(setq window-divider-default-bottom-width 1)
(setq window-divider-default-places 'right-only)
(add-hook 'after-init-hook #'window-divider-mode)
#+end_src

** Fringe mode
:PROPERTIES:
:CUSTOM_ID: h:C1565484-A5D5-4F12-9A2D-11D42262B822
:END:

The fringes are areas to the right and left side of an Emacs frame. They
can be used to show status-related or contextual feedback such as line
truncation indicators, continuation lines, code linting markers, etc.

The default fringe width (=nil=) is 8 pixels on either side, which I
approve of. It is possible to set the value of the =fringe-mode= to
something like ='(10 . 5)= which applies the varied width to the left and
right side respectively. Otherwise, we can use a single integer that
controls both sides.

The use of =setq-default= is necessary, otherwise these values become
buffer-local.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'fringe
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t))
#+end_src

** Color tools (ct.el)
:PROPERTIES:
:CUSTOM_ID: h:265B233C-1F8A-45DA-9058-4876C896AB8B
:END:

The =ct.el= library by Github user "neeasade" provides various utilities
for testing colour values across several spaces. The developer also has
an interesting article on the matter: [[https://notes.neeasade.net/color-spaces.html][Reasoning about Colors]]. I may need
some of those tools while developing my Modus themes.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'ct)
#+end_src

** Rainbow mode for colour previewing (rainbow-mode.el)
:PROPERTIES:
:CUSTOM_ID: h:4EC52626-1483-47B6-AC02-5362BE356776
:END:

The following package reads a colour value, such as hexadecimal RGB, and
sets the background for the value in that color (=rainbow-mode= is
activated manually).

#+begin_src emacs-lisp
;; (indiebrain-emacs-elpa-package 'rainbow-mode
;;   (setq rainbow-ansi-colors nil)
;;   (setq rainbow-x-colors nil))
#+end_src

:Note: This is currenly disabled due to consistent GPG failures when installing the package:

#+begin_example
Failed to verify signature rainbow-mode-1.0.5.el.sig:
No public key for 066DAFCB81E42C40 created at 2020-07-28T17:05:01-0400 using RSA
Command output:
gpg: keyblock resource '~/.emacs.d/elpa/gnupg/pubring.kbx': No such file or directory
gpg: Signature made Tue Jul 28 17:05:01 2020 EDT
gpg:                using RSA key C433554766D3DDC64221BFAA066DAFCB81E42C40
gpg: Can't check signature: No public key
#+end_example

** Line numbers and relevant indicators (indiebrain-sideline.el)
:PROPERTIES:
:CUSTOM_ID: h:E419F543-641F-4DD3-9D01-7834DF02794A
:END:

=indiebrain-sideline.el= (reproduced after the package configurations) is
a set of simplete-minded features:

1. It bundles up together three distinct visual elements as part of a
   common minor mode: =indiebrain-sideline-mode=. Its constituents are
   current line highlighting (=hl-line-mode=), diff indicators
   (=diff-hl-mode=), and line numbers (=display-line-numbers-mode=). Line
   numbers and line highlighting are built into Emacs.

2. A simple toggle for =whitespace-mode=, which I only ever use to double
   check some area's indentation or to confirm that no newline is
   missing at the end of the file.

Note that the =diff-hl= package offers some more features other than the
obvious colour-coded highlighting of changes, such as the ability to
move between diff hunks (with =C-x v [= and =C-x v ]=) or to revert the
current hunk (=C-x v n=). Those can come in handy (check my comprehensive
extensions in [[#h:A852E4F8-426C-4AA1-846E-41204B0D28C4][Version control framework (vc.el and indiebrain-vc.el)]]).

I'm not sure I like bundling these three features together as I find
that my day-to-day work benefits from some, but not all of these
features being active most of the time. For now, I globally enable
=diff-hl= and =hl-line= since I use them most everywhere. This requirement
seems to defeat the purpose of this package altogether, but I'm keeping
it for now as I /may/ change it to handle toggling of only the line
numbers.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-sideline
  (require 'display-line-numbers)
  ;; Set absolute line numbers. A value of "relative" is also useful.
  (setq display-line-numbers-type t)
  ;; Those two variables were introduced in Emacs 27.1
  (setq display-line-numbers-major-tick 0)
  (setq display-line-numbers-minor-tick 0)
  ;; Use absolute numbers in narrowed buffers
  (setq-default display-line-numbers-widen t)

  (indiebrain-emacs-elpa-package 'diff-hl
    (setq diff-hl-draw-borders nil)
    (setq diff-hl-side 'left)
    (add-hook 'after-init-hook #'global-diff-hl-mode))

  (require 'hl-line)
  (setq hl-line-sticky-flag nil)
  (global-hl-line-mode)

  (require 'whitespace)
  (add-hook 'before-save-hook #'whitespace-cleanup)

  (let ((map global-map))
    (define-key map (kbd "<f6>") #'indiebrain-sideline-negative-space-toggle)
    (define-key map (kbd "<f7>") #'indiebrain-sideline-mode)
    (define-key map (kbd "C-c z") #'delete-trailing-whitespace)))
#+end_src

This is =indiebrain-sideline.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-sideline.el src emacs-lisp :tangle no

** Highlight comment keywords (hl-todo)
:PROPERTIES:
:CUSTOM_ID: h:AA13D85A-3F06-40B8-9E56-88151E4EC652
:END:

This tool by Jonas Bernoulli will apply highlighting to keywords that
are normally used in code comments. Simple and effective!

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'hl-todo
  (add-hook 'prog-mode-hook #'global-hl-todo-mode))
#+end_src

** Outline mode, outline minor mode, and extras (indiebrain-outline.el)
:PROPERTIES:
:CUSTOM_ID: h:87B9CD61-B963-4EE8-A90E-3BA1725DF6D3
:END:

The =outline.el= library defines a major mode (=outline-mode=) that is
similar to =org-mode= in that it consists of headings which can be
expanded or contracted individually or as a group (actually Outline
predates Org). The major mode is meant to work with plain text files, or
be leveraged by other packages that need to have some structure and the
accompanying benefits of outline folding. In practice, however, I never
found a dedicated use for it that would justify it over the more
featureful Org.

Where =outline.el= truly shines, in my experience, is in the minor mode it
defines (=outline-minor-mode=), which provides the familiar structured,
heading-folding facilities in other major modes, like =emacs-lisp-mode= or
any arbitrary mode, like =diff-mode= and the =diary=.

Also read:

- [[#h:D0ECA629-C900-4FCF-A220-752B5ED5A784][Calendar and Diary (and indiebrain-diary.el)]].
- [[#h:166CA916-D535-4498-9EBE-4B3DC2A06FAF][Diff-mode (and indiebrain-diff.el extensions)]].

With some careful tweaks you can continue to work on your code while
also benefitting from a more effective means of organising and reviewing
what you have.

In practice, to make an outline for Elisp buffers, you need to start a
comment line /without leading spaces/ and make it at least three comment
delimiters long (=;;;=) followed by a space and then the text of the
heading, such as =;;; Code:=. That is considered a heading level 1. Every
extra delimiter will increase heading levels accordingly. The
buffer-local variable =outline-regexp= determines what constitutes a
heading for this purpose.

Now on to my custom library, =indiebrain-outline.el= which builds on those
concepts:

- Provide several new commands and minor extras for working with
  outlines.

- Define a =indiebrain-outline-minor-mode-safe= command that checks
  whether the current buffer's major mode is not a member of a
  blocklist. The idea is to not run =outline-minor-mode= with major modes
  that already provide its functionality: =org-mode=, =outline-mode=,
  =markdown-mode=.

You can navigate the outline using minibuffer completion, which is my
favourite way to browse a file. You can, in the same spirit, use Embark
to produce a buffer with the completion candidates, i.e. the headings,
or a subset you have narrowed to, and navigate therefrom. It really is
an efficient workflow: [[#h:E4A448DA-159D-4BDB-AE29-1118088EFE9D][Extended minibuffer actions and more (embark.el
and indiebrain-embark.el)]].

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'outline
  (setq-default outline-minor-mode-highlight 'override) ; emacs28
  (setq-default outline-minor-mode-cycle t)     ; emacs28
  (let ((map outline-minor-mode-map))
    (define-key map (kbd "C-<tab>") #'outline-cycle)
    (define-key map (kbd "<backtab>") #'outline-cycle-buffer) ; S-TAB
    (define-key map (kbd "C-c C-n") #'outline-next-visible-heading)
    (define-key map (kbd "C-c C-p") #'outline-previous-visible-heading)
    (define-key map (kbd "C-c C-f") #'outline-forward-same-level)
    (define-key map (kbd "C-c C-b") #'outline-backward-same-level)
    (define-key map (kbd "C-c C-a") #'outline-show-all)
    (define-key map (kbd "C-c C-o") #'outline-hide-other)
    (define-key map (kbd "C-c C-u") #'outline-up-heading)))

(indiebrain-emacs-builtin-package 'indiebrain-outline
  (let ((map outline-minor-mode-map))
    (define-key map (kbd "C-c C-v") #'indiebrain-outline-move-major-heading-down)
    (define-key map (kbd "M-<down>") #'indiebrain-outline-move-major-heading-down)
    (define-key map (kbd "C-c M-v") #'indiebrain-outline-move-major-heading-up)
    (define-key map (kbd "M-<up>") #'indiebrain-outline-move-major-heading-up)
    (define-key map (kbd "C-x n s") #'indiebrain-outline-narrow-to-subtree))
  (define-key global-map (kbd "<f10>") #'indiebrain-outline-minor-mode-safe))
#+end_src

These are the contents of the =indiebrain-outline.el= library (find the file in
[[https://github.com/indiebrain/.files/][my dotfiles' repo]] (as with all my Elisp code)):

#+include: indiebrain-lisp/indiebrain-outline.el src emacs-lisp :tangle no

** Cursor and mouse settings
:PROPERTIES:
:CUSTOM_ID: h:6D524E74-DD3B-4DB3-B647-FA448A8A7020
:END:

*** Cursor appearance and tweaks (indiebrain-cursor.el)
:PROPERTIES:
:CUSTOM_ID: h:76FA3E11-0944-4429-A552-F83F1C2F2A57
:END:

=indiebrain-cursor.el= defines a minor mode that lets me control the overall
looks and behaviour of the cursor depending on whether I am doing my
usual work on Emacs or am preparing a presentation.

Note that in [[#h:813B4DC2-EB36-4825-90EE-299CA53A9AD1][Minibuffer configurations and extras
(indiebrain-minibuffer.el)]] I also add a customisation option for the
minibuffer's cursor. This concerns two functions that can be used to
differentiate cursors in the minibuffer and completions' windows
respectively.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-cursor
  (indiebrain-cursor-presentation-mode -1))
#+end_src

This is =indiebrain-cursor.el= (part of [[https://github.com/indiebrain/.files][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-cursor.el src emacs-lisp :tangle no

*** Mouse wheel behavior
:PROPERTIES:
:CUSTOM_ID: h:DAB41A1E-A089-4854-997D-BBAB4B412DC1
:END:

The value of =mouse-wheel-scroll-amount= means the following:

+ By default scroll by one line.
+ Hold down Shift to do so by five lines.
+ Hold down Meta to scroll half a screen.
+ Hold down Control to adjust the size of the text. This was added in
  Emacs 27.

The other options in short:

+ Hide mouse pointer while typing.
+ Enable mouse scroll.
+ Faster wheel movement means faster scroll.
+ Scroll window under mouse pointer regardless of whether it is the
  current one or not.

Note that if we enable =mouse-drag-copy-region= we automatically place the
mouse selection to the kill ring. This is the same behaviour as terminal
emulators that place the selection to the clipboard (or the primary
selection). I choose not to use this here.

=tear-off-window= places the current window in a new frame. Normally I
call that command with =M-x=, though it does not hurt to rely on the mouse
from time to time.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'mouse
  ;; In Emacs 27+, use Control + mouse wheel to scale text.
  (setq mouse-wheel-scroll-amount
    '(1
      ((shift) . 5)
      ((meta) . 0.5)
      ((control) . text-scale)))
  (setq mouse-drag-copy-region nil)
  (setq make-pointer-invisible t)
  (setq mouse-wheel-progressive-speed t)
  (setq mouse-wheel-follow-mouse t)
  (add-hook 'after-init-hook #'mouse-wheel-mode)
  (define-key global-map (kbd "C-M-<mouse-3>") #'tear-off-window))
#+end_src

*** Scrolling behaviour
:PROPERTIES:
:CUSTOM_ID: h:A688F626-4A34-44E2-9DD1-82C8D38CCAD7
:END:

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction. With the following the point will stay at the top/bottom of
the screen while moving in that direction (use =C-l= to reposition it).

The =next-screen-context-lines= ensures that when moving by screenfulls
(with either =C-v= or =M-v=) we do not get any continuation lines from the
previous screen. I find this more intuitive.

#+begin_src emacs-lisp
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default scroll-margin 0)
(setq-default next-screen-context-lines 0)
#+end_src

*** Delete selection
:PROPERTIES:
:CUSTOM_ID: h:22E18EBD-6C8D-4416-AF37-0C8A212ED10A
:END:

this is a very helpful mode. it kills the marked region when inserting.
it also has checks to ensure that yanking over a selected region will
not insert itself when =mouse-drag-copy-region= is in effect (see the
section on the mouse wheel behaviour).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'delsel
  (add-hook 'after-init-hook #'delete-selection-mode))
#+end_src

*Pro tip*: On Emacs 27.1 or higher you can create a rectangular region by
holding down Ctrl and Meta while dragging the mouse with the left click
pressed. Otherwise rectangular regions are created using =C-x SPC= to
start a rectangle at the mark, then moving the mark. Additionally, one
can insert into a rectangle using =C-c r t= - useful for editing multiple
lines with the same text.

*** Tooltips (tooltip-mode)
:PROPERTIES:
:CUSTOM_ID: h:6EC67981-968E-410E-8B54-7966C9379133
:END:


These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:

- On my GNU Linux hosts, make sure that the GTK theme is /not used/ for
  those: I prefer the generic display which follows my current theme's
  styles.
- The delay is slightly reduced for the initial pop-up, while it has
  been increased for immediate pop-ups thereafter.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'tooltip
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq )
  (setq tooltip-frame-parameters
    '((name . "tooltip")
      (internal-border-width . 6)
      (border-width . 0)
      (no-special-glyphs . t)))
  (add-hook 'after-init-hook #'tooltip-mode))
#+end_src

** Conveniences and minor extras
:PROPERTIES:
:CUSTOM_ID: h:09FFAD23-391E-4244-A12D-A587958275AD
:END:

*** Auto revert mode
:PROPERTIES:
:CUSTOM_ID: h:3F2E4069-981D-446B-845F-93A061022354
:END:

This mode ensures that the buffer is updated whenever the file changes.
A change can happen externally or by some other tool inside of Emacs
(e.g. kill a Magit diff).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'autorevert
  (setq auto-revert-verbose t)
  (add-hook 'after-init-hook #'global-auto-revert-mode))
#+end_src

*** Preserve contents of system clipboard
:PROPERTIES:
:CUSTOM_ID: h:0150994C-6A0F-4A7A-AC53-9FDBFD991C34
:END:

Say you copied a link from your web browser, then switched to Emacs to
paste it somewhere. Before you do that, you notice something you want to
kill. Doing that will place the last kill to the clipboard, thus
overriding the thing you copied earlier. We can have a kill ring
solution to this with the following:

#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

Now the contents of the clipboard are stored in the kill ring and can
be retrieved from there (e.g. with =M-y=).
*** Pulse highlight changes (goggles.el)
:PROPERTIES:
:CUSTOM_ID: h:3CF94F65-3775-4BA6-BCBF-7EC48AAB5EC3
:END:

This is another package by Daniel Mendler which pulses the area where
some change took effect. It is a subtle, yet effective, method to
visually capture the affected region of text and, thus, be confident
that no mistakes were made in the process (or notice those as they
occur).

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'goggles
  (setq-default goggles-pulse t)
  (dolist (mode '(prog-mode-hook text-mode-hook))
    (add-hook mode #'goggles-mode)))
#+end_src

*** Newline characters for file ending
:PROPERTIES:
:CUSTOM_ID: h:9AAEC463-DC39-4600-B78D-FB1CA3EAB4B2
:END:

For some major modes, such as =diff-mode=, a final newline is of paramount
importance. Without it you cannot, for instance, apply a patch cleanly.
As such, the =mode-require-final-newline= will add a newline character
when visiting or saving a buffer of relevance.

#+begin_src emacs-lisp
(setq mode-require-final-newline 'visit-save)
#+end_src

*** Altered zap and easier repeats
:PROPERTIES:
:CUSTOM_ID: h:AEFA9332-A242-4278-B679-3621D80B1D85
:END:
I seldom use the functionality related to this section, but when I do I
prefer it to work the way I expect. =zap-up-to-char= will delete
everything from point up to the character you provide it with. Think of
how you may want to delete a file name but keep its file type extension.

The =repeat= command is bound by default to =C-x z=, with =s-z= serving as my
alias for it (read [[#h:51B9B73E-3527-422C-9672-AEAF22D9FA15][What is the meaning of the `s-KEY' bindings?]]). I
make it so that subsequent repetitions require only hitting another =z=.
Depending on what you do, a =repeat= can save you from multiple key
presses, such as when switching windows with =other-window= (=C-x o= by
default). For more demanding tasks you are better off with keyboard
macros.

*Pro tip:* to make a keyboard macro out of your most recent commands, use
=C-x C-k l= which calls =kmacro-edit-lossage=. The list is editable, so
remove any line that is not required and then save what is left. The
result is stored as the latest keyboard macro (and you also have the
power to cycle through kmacros, store them in specific keys, etc.).

Moving on to the mark, practically every Emacs motion that operates on a
portion of text will set the mark automatically. You can also do it
manually with =C-SPC= (hit it twice if you do not wish to activate the
region). It is then possible to cycle through the marks in reverse
order by passing a prefix argument =C-u C-SPC=. With the evaluation of
=set-mark-command-repeat-pop= as =t= we can continue cycling by repeated
presses of =C-SPC=. Again though, this is not the type of functionality I
rely on: for more deliberate actions of this sort, consider Emacs'
notion of "registers".

#+begin_src emacs-lisp
(setq repeat-on-final-keystroke t)
(setq set-mark-command-repeat-pop t)
(define-key global-map (kbd "M-z") #'zap-up-to-char)
(define-key global-map (kbd "s-z") #'repeat)
#+end_src

*** Package lists
:PROPERTIES:
:CUSTOM_ID: h:532CC737-13EF-430B-86F3-6BEA2876E5C3
:END:

With this I just want to enable line highlighting when browsing the list
of packages. I generally use =hl-line-mode= on all interfaces where the
current line is more important than the exact column of the point.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'package
  ;; All variables are for Emacs 28+
  (setq package-name-column-width 40)
  (setq package-version-column-width 14)
  (setq package-status-column-width 12)
  (setq package-archive-column-width 8)
  (add-hook 'package-menu-mode-hook #'hl-line-mode))
#+end_src

* Language settings for prose and code
:PROPERTIES:
:CUSTOM_ID: h:478C4948-62A1-4F4D-899D-28FB1121455C
:END:

This section is all about configurations and/or packages that deal with
natural or programming language enhancements.

I develop software in a large number of languages and platforms. Emacs
is my staple tool for working in this manner. As such this section
contains quite a long list of language-specific sections which support
my day-to-day operations.

** Paragraphs and fill-mode (indiebrain-fill.el)
:PROPERTIES:
:CUSTOM_ID: h:FD38C107-0C54-4685-ADD2-7692C360EC9A
:END:

The =indiebrain-fill.el= library (reproduced below) is a tiny wrapper
around some Emacs settings and modes that are scrattered around several
files, which control (i) how paragraphs or comments in programming modes
should be wrapped to a given column count, and (ii) what constitutes a
sentence. I put them all together here to make things easier to track.

- With regard to sentence endings and paragraphs, this configuration
  intends to be most compatible with collaborative documents. Since most
  folks are not writing in monospaced font faces, they tend to use only
  a single space after a =.= character to end their sentences. Setting
  =sentence-end-double-space= to nil is intended to accommodate that
  preference.

- =indiebrain-fill-fill-mode= sets my desired default column width for all
  buffers, while it applies another value for programming modes (in case
  there is a need to control the two cases separately). Those values are
  stored in the variables =indiebrain-fill-default-column= and
  =indiebrain-fill-prog-mode-column= respectively. My minor mode also
  enables =auto-fill-mode= in =text-mode= and =prog-mode= buffers through the
  appropriate hooks. Disabling =indiebrain-fill-fill-mode= will remove all
  those customisations.

Note that [[#h:0908107A-9CDA-4C20-B797-1FAA17F1880F][Common custom functions (indiebrain-simple.el)]] contains some
commands related to auto-fill. Besides, you can always do it manually
for the current paragraph or the active region with =M-x fill-paragraph=,
bound by default to =M-q=.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'indiebrain-fill
  (setq indiebrain-fill-default-column 72)
  (setq indiebrain-fill-prog-mode-column 72)  ; Set this to another value if you want
  ;; Those variables come from various sources, though they feel part of the
  ;; same conceptual framework.
  (setq sentence-end-double-space nil)
  (setq sentence-end-without-period nil)
  (setq colon-double-space nil)
  (setq use-hard-newlines nil)
  (setq adaptive-fill-mode t)
  (indiebrain-fill-fill-mode 1)
  (add-hook 'after-init-hook #'column-number-mode))
#+end_src

These are the contents of =indiebrain-fill.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles'
repo]]):

#+include: indiebrain-lisp/indiebrain-fill.el src emacs-lisp :tangle no

** Comments (newcomment.el and indiebrain-comment.el)
:PROPERTIES:
:CUSTOM_ID: h:C9E1E50B-A782-4163-B5C4-27BEA8A599A2
:END:

The built-in =newcomment.el= library offers several useful commands for
working with comments in source code. While my =indiebrain-comment.el=
(reproduced after the package configurations) adds some simple extras.

The intent of my configurations here is straightforward: re-configure
key bindings to make the most common action easier to access and then
arrange the rest in a meaningful way, while also setting up the
appropriate variables.

The most common action is the command =indiebrain-comment-comment-dwim=
which is bound to =C-;=. Note that =C-;= is normally occupied by some
=flyspell= command (disabled in [[#h:DB14B9F0-C8CA-4841-A295-62C7A673620D][Spellchecking (flyspell and
indiebrain-spell.el)]]). Compare that keybinding to the one I have for the
much more specialised =indiebrain-comment-timestamp-keyword=: =C-x C-;=.
What those commands do is documented in their docstrings, so please
check the code below.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'newcomment
  (setq comment-empty-lines t)
  (setq comment-fill-column nil)
  (setq comment-multi-line t)
  (setq comment-style 'multi-line)
  (let ((map global-map))
    (define-key map (kbd "C-:") #'comment-kill)         ; C-S-;
    (define-key map (kbd "M-;") #'comment-indent)))

(indiebrain-emacs-builtin-package 'indiebrain-comment
  (setq indiebrain-comment-comment-keywords
    '("TODO" "NOTE" "XXX" "REVIEW" "FIXME"))
  (let ((map global-map))
    (define-key map (kbd "C-;") #'indiebrain-comment-comment-dwim)
    (define-key map (kbd "C-x C-;") #'indiebrain-comment-timestamp-keyword)))
#+end_src

And here is =indiebrain-comment.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-comment.el src emacs-lisp :tangle no

** Configure 'electric' behavior
:PROPERTIES:
:CUSTOM_ID: h:6A355747-FED5-44FB-955A-A4D32FBC39A0
:END:

Emacs labels as "electric" any behavior that involves contextual
auto-insertion of characters. This is a summary of my settings:

- Indent automatically.
- If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs. Only do so if there is no alphabetic
  character after the cursor.
- The cryptic numbers in the pairs set, correspond to curly single and
  double quotes and these =«»=. The contents of this set are always
  inserted in pairs, regardless of major mode.
  + To get those numbers, evaluate =(string-to-char CHAR)= where CHAR is
    the one you are interested in. For example, get the literal tab's
    character with =(string-to-char "\t")=.
- While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one. So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
- Do not skip over whitespace when operating on pairs. Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over. I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
- The whitespace characters are space (=\s=), tab (=\t=), and newline (=\n=).
- The rest concern the conditions for transforming quotes into their
  curly equivalents. I keep this disabled, because curly quotes are
  distinct characters. It is difficult to search for them. Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'electric
  (setq electric-pair-inhibit-predicate'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
    '((8216 . 8217)
      (8220 . 8221)
      (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t) (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-indent-mode 1)
  (electric-pair-mode -1)
  (electric-quote-mode -1)

  (dolist (mode '( prog-mode-hook))
    (add-hook mode #'electric-indent-mode)
    (add-hook mode #'electric-pair-mode)))
#+end_src

** Parentheses (show-parens-mode)
:PROPERTIES:
:CUSTOM_ID: h:FC008164-5230-4660-BC3C-CF76327B3431
:END:

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.


Summary of what these do:

- Activate the mode upon startup.
- Show the matching delimiter/parenthesis if on screen, else show
  nothing. It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=. The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
- =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity. This means the beginning or end of
  the line, with space in between. I used that for a long while and it
  server me well. Now that I have a better understanding of Elisp, I
  disable it.
- Do not highlight a match when the point is on the inside of the
  parenthesis.


#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'paren
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (add-hook 'after-init-hook #'show-paren-mode))
#+end_src

** Tabs, indentation, and the TAB key
:PROPERTIES:
:CUSTOM_ID: h:3E30D7B6-0044-4F4D-B9D4-62A599CEA964
:END:

Emacs tends to perform alignments by mixing tabs with spaces, which /can
lead to misalignments/ depending on certain variables such as the size of
the tab. As such, when inserting a tab this configuration instead uses
whitespace characters to indicate indentation. If there ever is a need
to use different settings in other modes, we can customize them via
hooks.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src

** Spellchecking (flyspell and indiebrain-spell.el)
:PROPERTIES:
:CUSTOM_ID: h:DB14B9F0-C8CA-4841-A295-62C7A673620D
:END:

The =flyspell= package enables in-buffer spell checking and correction. It
relies on the external GNU =aspell= program to perform the spell checking
and provide correction support. The below configuration sets up the
default dictionary to use "American English" and enables automatic spell
checking when editing prose.

Also bear in mind that the key binding =C-;= that Flyspell uses by default
is disabled because I re-purpose it for a faster version of =C-x C-;=
(much more useful for my work - see the [[#h:C9E1E50B-A782-4163-B5C4-27BEA8A599A2][Comments (newcomment.el and
indiebrain-comment.el)]] section).

Flyspell offers two modes I find useful in my work. First, =flyspell-mode=
is intended to provide on-the-fly spellchecking in prose heavy buffers.
I enable =flyspell-mode= in buffers where the major mode derives from
=text-mode=. However, my aptitude for typos extends to non-prose buffers
as well. For those "code-centric" buffers, =flyspell-prog-mode= limits
spellchecking of comment regions of a buffer. This does NOT help me in
the case where I mistype a variable or function name in code. For that I
tend to rely on in-buffer linter feedback (see [[#h:25282A11-6994-4849-9DF4-E99937F8072D][Flycheck]]).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'flyspell
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-program-name "aspell")
  (setq ispell-dictionary "en_US")
  (define-key flyspell-mode-map (kbd "C-;") nil)

  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode))

(indiebrain-emacs-builtin-package 'indiebrain-spell
  (let ((map global-map))
    (define-key map (kbd "M-$") #'indiebrain-spell-spell-dwim)
    (define-key map (kbd "C-M-$") #'indiebrain-spell-change-dictionary)))
#+end_src

This is =indiebrain-spell.el= (part of [[https://github.com/indiebrain/.files/][my dotfiles' repo]]):

#+include: indiebrain-lisp/indiebrain-spell.el src emacs-lisp :tangle no

** Code and text linters
:PROPERTIES:
:CUSTOM_ID: h:42BE413C-9A59-4ED2-A614-D3F3E500CF05
:END:

*** Flycheck
:PROPERTIES:
:CUSTOM_ID: h:25282A11-6994-4849-9DF4-E99937F8072D
:END:

The Flycheck package is similar to the built-in =flymake= package, however
it comes with many more language-specific backends and is extensible for
use with external linting tools.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'flycheck
  (global-flycheck-mode))
#+end_src

*** Proselint configuration
:PROPERTIES:
:CUSTOM_ID: h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b
:END:

This is my configuration for the external =proselint= executable (check
[[https://github.com/amperser/proselint][that project's README]]). The following should be made available at
=~/.config/proselint/config=.

#+include: ../../proselint/.config/proselint/config src conf :tangle no

** Recognize subwords
:PROPERTIES:
:CUSTOM_ID: h:547D9EA7-51C5-4796-8752-39DEED4E966A
:END:

The =subword-mode= documentation (=C-h f subword-mode=)is informative and
extensive. This alters the way Emacs understands word boundaries. So,
/camelCaseWords/ are exposed as their constituents rather than one long
word, meaning that motions will behave accordingly.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'subword
  (add-hook 'prog-mode-hook #'subword-mode))
#+end_src

** Emacs live documentation (eldoc)
:PROPERTIES:
:CUSTOM_ID: h:FB1827C2-73D7-4977-9C46-58FE5F89B7F8
:END:

When editing elisp, this mode will display useful information about the
construct at point in the echo area. For functions it will display the
list of arguments they accept. While it will show the the first sentence
of a variable's documentation string.

It offers a lightweight complementary facility to that of the standard
help commands: =C-h f FUNCTION=, =C-h v VARIABLE=.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'eldoc
  (global-eldoc-mode 1))
#+end_src

** Tools for manual pages (manpages)
:PROPERTIES:
:CUSTOM_ID: h:DE9E1716-5638-4737-91EE-3E0B90C66CCD
:END:

Typically Unix-like operating systems provide facilities for reading the
documentation of libraries, system calls, etc. One such program is =man= -
short for Manual; the documentation of a particular item is referred to
as its Manual Page, or manpage. =man= is sometimes referred to as an
on-line" documentation system. Like many terms from the earlier days of
computing, do not be confused by the, now, overloaded meaning of the
term "on-line". The term "on-line" in this sense refers back to a time
when documentation for libraries and systems typically came in volumes
of printed materials; Manual Pages are stored on the host file system
and do NOT require a network connection. They serve as at-the-ready tool
for discovering, and recalling the manner in which a program are meant
to be used.

Manuals are typical organized into "sections" - represented by a
number - which indicate the role of the software being documented. For
Research Unix, BSD, MacOS, and Linux the sections are organized as
follows:

| Section | Description                                                       |
|---------+-------------------------------------------------------------------|
|       1 | General commands                                                  |
|       2 | System calls                                                      |
|       3 | Library functions, convering in particular the C standard library |
|       4 | Special files (usually devices, those found in /dev) and drivers  |
|       5 | File formats and conventions                                      |
|       6 | Games and screensavers                                            |
|       7 | Miscellanea                                                       |
|       8 | System administration commands and daemons                        |

A manpage's "section" is usually shown after its name in parentheses.
For example, the manpage for the =ls= utility is listed in section 1 -
General commands - and is titled =LS(1)=

All manpages follow a common layout which is optimized for simple ASCII
text display. Sections present may include:

- NAME :: The name of the command or function, followed by a one-line
  description of what it does.
- SYNOPSIS :: In the case of a command, a formal description of how to
  run it and what command line options it takes. For program functions,
  a list of the parameters the function takes and which header file
  contains its declaration.
- DESCRIPTION :: A textual description of the functioning of the command
  or function.
- EXAMPLES :: Some examples of common usage.
- SEE ALSO :: A list of related commands or functions.

Some items may be present in multiple sections of the manpages. For
example on MacOS:

#+begin_example
$ man uname
UNAME(1)                         User Commands                        UNAME(1)

NAME
       uname - print system information
...
SEE ALSO
       arch(1), uname(2)
#+end_example

In this case, the manpage from section 1 - general commands was
displayed, but notice that an entry also exists in another section and
is referenced in the =SEE ALSO= section. Typically one could request
documentation for specific sections by passing the section to the =man=
command:

#+begin_example
man 2 uname

# or

man uname.2
#+end_example

However, Emacs also has a built in mode for quickly navigating manpages.
This has the added benefit of enhanced typography, navigation, etc
provided by Emacs.

What you can do inside such a buffer (with minor tweaks by me):

- =i= will go to the information node you want using completion (same
  principle as with the Info pages of C-h i and the like)
- =g= will generate the buffer anew. Do it to reformat the text manually,
  though this should also happen automatically when adjusting a window's
  size
- =n= and =p= move between section headings
- =RET=,while over a referenced manpage, will produce a new buffer with
  its contents
- =s= navigates directly to the =SEE ALSO= section
- =m= will search for a manpage using the configured completion system

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'man
  (let ((map Man-mode-map))
    (define-key map (kbd "i") 'Man-goto-section)
    (define-key map (kbd "g") 'Man-update-manpage)))
#+end_src

** Support for major modes
:PROPERTIES:
:CUSTOM_ID: h:5CC2D2AE-E4AB-42E4-B5B7-66F545845D71
:END:

These provide syntax highlighting and additional features for
environments that are not already supported by Emacs.

*** Plain text (text-mode with indiebrain-text.el)
:PROPERTIES:
:CUSTOM_ID: h:0B3B37D1-D410-4931-93A4-C50820F10BB8
:END:

=indiebrain-text.el= (copied verbatim further below) is meant to provide a
set of extensions for the built-in =text-mode.el=. Currently there is
only one command:

+ =indiebrain-text-insert-heading= lets you add a heading delimiter to the line
  at point. The length of the delimiter is equal to that of the line.
  By default, the delimiter consists of hyphens, but with a =C-u= prefix
  argument those are substituted for equals signs.

Refer to the source code in [[#h:0908107A-9CDA-4C20-B797-1FAA17F1880F][Common custom functions (indiebrain-simple.el)]].

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'text-mode)

(indiebrain-emacs-builtin-package 'indiebrain-text
  (add-to-list 'auto-mode-alist '("\\(README\\|CHANGELOG\\|COPYING\\|LICENSE\\)$" . text-mode))
  (define-key text-mode-map (kbd "<M-return>") #'indiebrain-text-insert-heading)
  (define-key org-mode-map (kbd "M-;") nil))
#+end_src

Those are the contents of the =indiebrain-text.el= library (find the file in [[https://github.com/indiebrain/.files][my
dotfiles' repo)]]:

#+include: indiebrain-lisp/indiebrain-text.el src emacs-lisp :tangle no

*** Markdown (markdown-mode)
:PROPERTIES:
:CUSTOM_ID: h:6E468232-CDC8-4486-B2C6-8C6E67E13946
:END:

As much as Org is superior as a markup tool, Markdown is unavoidable
when collaborating with other human beings on the internet. That is to
say, I edit lots of Markdown files and this slightly eases the burden of
doing so.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'markdown-mode
  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (setq markdown-fontify-code-blocks-natively t))
;; Allows for fenced block focus with C-c ' (same as Org blocks).
(indiebrain-emacs-elpa-package 'edit-indirect)
#+end_src

*** YAML (yaml-mode)
:PROPERTIES:
:CUSTOM_ID: h:F28A3862-D935-4808-9C0B-39C1843BA60E
:END:

This adds support for YAML files.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'yaml-mode
  (add-hook 'yaml-mode-hook (lambda ()
                  (turn-off-auto-fill)))

  (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.ya?ml.erb$" . yaml-mode)))
#+end_src

*** CSS (css-mode)
:PROPERTIES:
:CUSTOM_ID: h:B75901EB-55D7-4492-B6C6-2B314A98DF56
:END:

This is the built-in mode for working with CSS and SCSS. I just want it
to not apply previews to color references. If I ever need that, there is
=rainbow-mode= (see [[#h:4EC52626-1483-47B6-AC02-5362BE356776][Rainbow mode for colour previewing
(rainbow-mode.el)]]).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'css-mode
  (add-to-list 'auto-mode-alist '("\\.css$" . css-mode))
  (add-to-list 'auto-mode-alist '("\\.scss$" . scss-mode))
  (setq css-fontify-colors nil)
  (setq css-indent-offset 2))
#+end_src

*** Shell scripts (sh-mode)
:PROPERTIES:
:CUSTOM_ID: h:57BFE7D7-E3A9-4D62-BFD1-535DF333CAC7
:END:

There are many shells; some considered more fashionable. However, the
=bash= shell is ubiquitous, mature, and simple enough to be productive in
most contexts.

A [[https://devhints.io/bash][quick reference]] should be enough for most to get started with Bash
scripting, but for a more in depth look at Bash see the [[https://www.gnu.org/software/bash/manual/][GNU reference
manuals]]. This section enhances Emacs to be able to effectively
develop, test, and maintain =bash= scripts.

[[https://github.com/sstephenson/bats][- BATS]] is a [[http://testanything.org/][TAP]]-compliant testing framework for Bourne Again Shell
  scripts. It provides a simple way to verify that the UNIX programs you
  write behave as expected. BATS is most useful when testing software
  written in Bash, but you can use it to test any UNIX program. [[https://github.com/dougm/bats-mode][bats-mode]]
  provides editing support and functions for running BATS tests within
  Emacs.

  Common key chords for running BATS tests

  | Key chord | Description                            |
  |-----------+----------------------------------------|
  | =C-c C-a=   | Run all tests in the current directory |
  | =C-c C-,=   | Run all tests in the current file      |
  | =C-c M-,=   | Run the current test at the point      |

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'bats-mode)
#+end_src

*** Caddy server (caddyfile-mode)
:PROPERTIES:
:CUSTOM_ID: h:7F4FEA13-C395-48D0-8F8F-D3B27F2F8486
:END:

#+begin_quote
Caddy is a powerful, extensible platform to serve your sites,
services, and apps...
#+end_quote

The Caddy project provides [[https://caddyserver.com/docs/quick-starts][in-depth documentation of its programmable
API and Caddyfile format]]. This section adds syntax highlighting for
editing the configuration files used to influence the behavior of
instances of the Caddy web server.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'caddyfile-mode)
#+end_src

*** Docker (dockerfile-mode and docker-tramp)
:PROPERTIES:
:CUSTOM_ID: h:2461A489-4BE5-4C9D-B00A-C1B37EF6F1CE
:END:

#+begin_quote
Docker is a set of platform as a service (PaaS) products that use
OS-level virtualization to deliver software in packages called
containers. Containers are isolated from one another and bundle their
own software, libraries and configuration files; they can communicate
with each other through well-defined channels. All containers are run
by a single operating system kernel and therefore use fewer resources
than virtual machines.
#+end_quote

Instructions on how to build a container images with Docker's build
tools are described in the =Dockerfile= format. While this is by no means
the only way to build container images, it is a widely used method of
doing so. The [[https://docs.docker.com/engine/reference/builder/][=Dockerfile= format's reference documentation]] describes
the format's syntax in detail.

When editing a =Dockerfile=, the following configuration enable Emacs to
perform syntax highlighting. Additionally, it provides a wrapper around
the =docker= client command-line interface. This makes it possible to
perform =docker= commands from directly inside Emacs. Such as:

Use =docker-tramp= to allow editing of files inside running containers.
When building docker images there can be a high cost to productivity if
one is to rebuild the container when testing out minor changes like
tweaking a minor config setting. This allows us to open a tramp session
in a running container see results more quickly than rebuilding the
container every time. Caveat, unless those changes are preserved in a
volume mount they disappear when the container exits so use docker-tramp
with caution. To use docker-tramp to gain access to a container:

#+begin_example
C-x C-f /docker:<user>@<container-id>:<path-to-file> RET
#+end_example

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'dockerfile-mode)
(indiebrain-emacs-elpa-package 'docker-tramp)
#+end_src

*** golang (go-mode)
:PROPERTIES:
:CUSTOM_ID: h:A83D883C-030E-4E53-9012-4AEA1FE4FD61
:END:

#+begin_quote
Go is an open source programming language that makes it easy to build
simple, reliable, and efficient software.
#+end_quote

While =Go= has gained in popularity in recent years, my contact with it is
mostly limited to internals and extensions to the Kubernetes
orchestration tool. As such, this configuration is not very
sophisticated, and mostly appropriate - I'd imagine to the casual user
of =Go=.

The following adds syntax highlighting and basic tooling to interact
with =golang= projects. The only notable bit of configuration is that this
adds a =before-save-hook= to run the =gofmt= utility on a buffer before its
contents are flushed to disk.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'go-mode
  (add-hook 'before-save-hook #'gofmt-before-save))
#+end_src

*** GraphQL (graphql-mode)

#+begin_quote
GraphQL is a query language for APIs and a runtime for fulfilling those
queries with your existing data. GraphQL provides a complete and
understandable description of the data in your API, gives clients the
power to ask for exactly what they need and nothing more, makes it
easier to evolve APIs over time, and enables powerful developer tools.
#+end_quote

GraphQL schema have a specific structure and syntax all their own.
=graphql-mode= provides syntax highlighting and tools to manipulate
GraphQL schema. I'm just getting started with GraphQL so there's not
much here yet.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'graphql-mode)
#+end_src

*** Groovy (groovy-mode)
:PROPERTIES:
:CUSTOM_ID: h:B9841CB5-D82A-4B35-A43F-5A58F5E207FB
:END:

I'm not terribly interested in the Groovy language. Yet, some tools I
encounter in my work seem to like using Groovy for scripting. This bit
add a minimal amount of consistency to buffers in which I'm editing
these types of buffers ([[#h:BDA11B18-F3F5-47B5-9F93-F29B303481EF][Jenkins pipeline (jenkinsfile-mode)]] syntax for
example).

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'groovy-mode
  (setq groovy-indent-offset 2))
#+end_src

*** JavaScript (js2-mode)
:PROPERTIES:
:CUSTOM_ID: h:E3E82ED2-7A81-4B20-A3E9-2DE51D068344
:END:

#+begin_quote
JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled
programming language with first-class functions. While it is most
well-known as the scripting language for Web pages, many non-browser
environments also use it, such as Node.js, Apache CouchDB and Adobe
Acrobat. JavaScript is a prototype-based, multi-paradigm,
single-threaded, dynamic language, supporting object-oriented,
imperative, and declarative (e.g. functional programming) styles.
#+end_quote

The Mozilla Developer Network (MDN) web documentation is a delightfully
accessible reference for many web related technologies. The [[https://developer.mozilla.org/en-US/docs/Web/javascript][MDN section
on JavaScript]] includes tutorials and reference documentation - pro
gratis.

There are many modes for working with JavaScript inside of Emacs. Most
represent iterations of supporting older versions of ECMAScript - the
language specification which JavaScript runtimes implement.

While Emacs does have a built-in =js-mode=, the sometimes maligned
=js2-mode= offers some more advanced capabilities. =js2-mode= checks syntax
on-the-fly using a built in parser written in elisp - it actually
validates the buffer's code as it's typed.

Some notable configurations:

- Intends are made using two whitespace characters.
- Many of the built-in functions of ECMA will be highlighted as syntax.
- Errors parsing the JavaScript document will be highlighted.
- The parser will print warnings about JavaScript strict-mode
  violations. These are common pitfalls in the language specification
  which can lead to unintended, or difficult to debug behavior at
  run-time.
- in-buffer linting for JavaScript via the =eslint= library. NOTE: this
  particular configuration is specific to an employer's setup. It
  expects the =eslint= program to be present in
  =./node_modules/.bin/eslint=.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'js2-mode
  (setq js2-basic-offset 2)
  (setq js2-highlight-level 3)
  (setq js2-mode-show-parse-errors t)
  (setq js2-mode-show-strict-warnings t)

  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
  (add-to-list 'auto-mode-alist '("\\.json$" . js2-mode))

  (setq-default flycheck-disabled-checkers (append flycheck-disabled-checkers '(javascript-jshint)))
  (flycheck-add-mode 'javascript-eslint 'js-mode)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (setq flycheck-javascript-eslint-executable "node_modules/.bin/eslint"))
#+end_src

*** React JSX (rjsx-mode)
:PROPERTIES:
:ID:       60EE33AB-57B7-4C5F-970A-99CB9084B488
:END:

#+begin_quote
This funny tag syntax is neither a string nor HTML.
#+end_quote

JSX is the primary language used to produce React components. It uses a
primarily JavaScript-ish syntax but introduces an HTML-looking DSL for
describing Component trees. This makes it so that neither web-mode nor
js2-mode do a particularly good job of accommodating this hybrid
content.

The =rjsx-mode= package extends js2-mode parser to support the official
spec of JSX. Since =rjsx-mode= inherits most of its configuration from
=js2-mode=, this section is fairly sparse for now. See the [[#h:E3E82ED2-7A81-4B20-A3E9-2DE51D068344][JavaScript
(js2-mode)]] section for more details. However, the one interesting bit
here is I automatically activate =rjsx-mode= when opening up
TypeScript "enhanced" JSX files.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'rjsx-mode
  (add-to-list 'auto-mode-alist '("\\.tsx$" . rjsx-mode)))
#+end_src

*** Jenkins pipeline (jenkinsfile-mode)
:PROPERTIES:
:CUSTOM_ID: h:BDA11B18-F3F5-47B5-9F93-F29B303481EF
:END:

I've fallen into a Release Engineering role more than once in my career.
Some organizations for whom I work use the Jenkins Continuous
Integration tool to "build" their software. This adds support for
editing "build" descriptions using the pipeline syntax.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'jenkinsfile-mode)
#+end_src

*** Ruby
:PROPERTIES:
:CUSTOM_ID: h:2EED681E-14D5-471B-912F-32BB5A1FCC6B
:END:

This section provides configuration for interacting with the Ruby
programming language. Emacs has a built-in =ruby-mode= which works
exceptionally well out of the box. This bit associates some additional
file types with the =ruby-mode= - like Rakefiles, gemspecs, Gemfiles, and
more.

Some more details on the configuration settings here:

- =ruby-insert-encoding-magic-comment= is disabled to prevent the
  automatic insertion of an encoding metadata comment into each =ruby-mode=
  buffer.
- =ruby-deep-indent-paren= is disabled to ensure that indentation follows
  consistent rules - 2 spaces - rather than indenting to whatever column
  the opening delimiter is oriented.
- =ruby-indent-tabs-mode= is disabled to prevent the insertion of tabs as
  indentation characters.

Additionally, the functionality of =ruby-mode= buffers is extended such
that they, or portions of them, can be sent to an external ruby process
for evaluation. The results of the evaluation can then be placed in a
comment in the buffer. This is achieved via the =rcodetools= gem and the
integrating code contained in this section.

Use the =C-c C-c= key chord to send the content of a =ruby-mode= buffer for
evaluation.

Since everything in Ruby is an expression, the value of anything can
inspected by adding a line comment on the item to be inspected. For
example:

#+begin_example ruby
wumpus = "found me!"
wumpus                          # => "found me!"
#+end_example

In-buffer linting for Ruby via the =rubocop= library is provided by
flycheck. NOTE: this particular configuration is specific to an
employer's setup. It expects the =rubocop= program to be runnable via a
binstub in =./bin/rubocop=.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'ruby-mode
  (setq ruby-insert-encoding-magic-comment nil
    ruby-deep-indent-paren nil
    ruby-indent-tabs-mode nil
    flycheck-ruby-rubocop-executable "bin/rubocop")

  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile[.lock]?$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Guardfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode)))
#+end_src

**** In-buffer evaluation (rcodetools.el)
:PROPERTIES:
:CUSTOM_ID: h:7112F695-7020-4A93-B9D5-2D47B00E8D72
:END:

#+begin_src emacs-lisp
(indiebrain-emacs-manual-package 'rcodetools
  (let ((map ruby-mode-map))
    (define-key map (kbd "C-c C-c") 'xmp)))
#+end_src

**** Automatic insertion of =end= keywords
:PROPERTIES:
:CUSTOM_ID: h:36923D8B-E0A2-4A35-82A9-7243CD962EEA
:END:

This configuration provides similar functionality to =electric-pair-mode=
(See: [[#h:6A355747-FED5-44FB-955A-A4D32FBC39A0][Configure 'electric' behavior]]) but for automatic insertion of =end=
keywords.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'ruby-end)
#+end_src

**** Ruby specifications (rspec)
:PROPERTIES:
:CUSTOM_ID: h:DAABA96A-D58D-4C87-BA26-3EB99B025687
:END:

This section integrates Emacs with the =rspec= Behavior Driven Development
framework. This is useful in targeting sections of a specification or
suite of specifications. Some interactions of note:

| Key chord | Description                                             |
|-----------+---------------------------------------------------------|
| =C-c , s=   | Verify the example or method defined at the point       |
| =C-c , v=   | Verify the spec file associated with the current buffer |
| =C-c , a=   | Run the entire specification suite                      |
| =C-c , r=   | Re-run the last verification process                    |
|           |                                                         |

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'inf-ruby)
(indiebrain-emacs-elpa-package 'rspec-mode
  (setq compilation-scroll-output 'first-error)
  (add-hook 'after-init-hook #'inf-ruby-switch-setup))
#+end_src

*** Rust

Rust is not a language in which I'm primarily interested, but I do come
across it from time to time. This adds the ability to work effectively
with the Rust language and =cargo= dependency management / build system.

One may use the universal argument to alter the Cargo command. the key
chord =C-u C-c C-c C-r RET= will place the cargo command in the mini
buffer. From there the command can be altered then executed. For example
to specify that the program should be run via in release mode one would
=C-u C-c C-c r RET --release RET=. Some examples of commonly used cargo
key chords:

| C-c C-c RET | Run =cargo fmt= on the current project   |
| C-c C-c C-r | Run =cargo run= on the current project   |
| C-c C-c C-b | Run =cargo build= on the current project |
| C-c C-c C-a | Add a =crate= to the current project     |

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'rust-mode)

(indiebrain-emacs-elpa-package 'flycheck-rust)
(indiebrain-emacs-elpa-package 'cargo
  (add-hook 'rust-mode-hook #'cargo-minor-mode))
#+end_src

*** Web / HTML (web-mode)
:PROPERTIES:
:CUSTOM_ID: h:0EA60830-0F9B-4DB9-9271-0A1F2F451E29
:END:

For the most part, the web-mode defaults are just fine. In addition to
doing a superb job editing HTML, =web-mode= is capable of handling HTML
templating langues - such as ERB HTML. This configuration enhances
=web-mode= to automatically open =.html.erb= templates and use a more
reasonable indentation depth for nesting nodes in the document tree.

#+begin_src emacs-lisp
(indiebrain-emacs-elpa-package 'web-mode
  (setq web-mode-markup-indent-offset 2)

  (add-to-list 'auto-mode-alist '("\\.html.erb$" . web-mode)))
#+end_src

* History and state
:PROPERTIES:
:CUSTOM_ID: h:66B0BE0D-DBB4-4816-A074-D0BA03F2416E
:END:

This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer.

** Emacs server and desktop
:PROPERTIES:
:CUSTOM_ID: h:fed47a29-eb36-4154-b2ec-4491fc3a9443
:END:

The following uses the first /running/ process of Emacs as the one others
may connect to. This means that calling =emacsclient= (with or without
=--create-frame=), will share the same buffer list and data as the
original running process, aka "the server". The server persists for as
long as there is an Emacs frame attached to it.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'server
  (add-hook 'after-init-hook #'server-start))
#+end_src

With some exceptions aside, I only ever use Emacs in a single frame.
What I find more useful is the ability to save the state I was in: the
name the of buffers, the cursor's position in each of them, the recent
file list, the minibuffer history, my stored registers.

The state of the available buffers and the values of each register are
called the "desktop" (for the other items see the following sections on
[[#h:2AF3BD7F-9E52-42D7-8E81-D6017E027C4E][Record various types of history]]).

Preserving the "desktop" prevents data loss due to unexpected errors
(which are infrequent, but do happen on occasion) or when I need
to close Emacs and re-launch it later (my hardware is limited, so I do
not keep it running while I am away).


Overview of the rollowing =desktop= settings:

- Enable the mode that saves the "desktop", instructing it to load a
  small number of buffers at launch (=desktop-restore-eager=).  The
  remainder of the buffer list will be loaded lazily.
- Now we must tell it where to store the files it generates and how
  often it should save. Concerning the latter, the default is to store
  the state every time it changes. I find that a bit too much, so I set
  a timeout of five minutes of idleness.
- Note the =desktop-load-locked-desktop=. By default, Emacs locks the
  desktop file while it runs. The lock is removed upon exiting. This is
  a safety mechanism. There are two cases where the lock can create
  issues:
  + Emacs has crashed, meaning that it exited abruptly and was not able
    to unlock the desktop. Upon re-launch Emacs will prompt you whether
    to load the locked file. You normally want to answer affirmatively.
  + Emacs runs in daemon mode, where it does not ask questions upon
    loading. In this case the lock is ignored.
  + Because I am only affected by the former, I choose to disable the
    prompt and just load the thing directly. Otherwise, I would set it
    to =nil=.
- Do not restore frame configurations. If I need to store one of those,
  I use registers, specifically =C-x r f=.
- Ask what to do in case the session has a newer file that the one it
  initially started out with (e.g. when a new frame runs in parallel to
  the older one).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'desktop
  (setq desktop-auto-save-timeout 300)
  (setq desktop-path `(,user-emacs-directory))
  (setq desktop-base-file-name "desktop")
  (setq desktop-files-not-to-save nil)
  (setq desktop-globals-to-clear nil)
  (setq desktop-load-locked-desktop t)
  (setq desktop-missing-file-warning nil)
  (setq desktop-restore-eager 0)
  (setq desktop-restore-frames nil)
  (setq desktop-save 'ask-if-new)
  (dolist (symbol '(kill-ring log-edit-comment-ring))
    (add-to-list 'desktop-globals-to-save symbol))

  (desktop-save-mode 1))
#+end_src

** Record various types of history
:PROPERTIES:
:CUSTOM_ID: h:2AF3BD7F-9E52-42D7-8E81-D6017E027C4E
:END:

*** Minibuffer history (savehist-mode)
:PROPERTIES:
:CUSTOM_ID: h:5E6FFCFA-74BC-47A6-9799-CEBEDA82AFB9
:END:

Keeps a record of actions involving the minibuffer.  This is of
paramount importance to a fast and efficient workflow involving any
completion framework that leverages the built-in mechanisms.

Emacs will remember your input and choices and will surface the desired
results towards the top as the most likely candidates. Make sure to also
read the Minibuffer configurations and extras
(indiebrain-minibuffer.el).

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'savehist
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-hook 'after-init-hook #'savehist-mode))
#+end_src

*** Record cursor position
:PROPERTIES:
:CUSTOM_ID: h:19651D0F-6F2F-4FB6-BFE9-63832DDF90AC
:END:

Just remember where the point is in any given file. This can often be a
subtle reminder of what you were doing the last time you visited that
file, allowing you to pick up from there.

#+begin_src emacs-lisp
(indiebrain-emacs-builtin-package 'saveplace
  (setq save-place-file (locate-user-emacs-file "saveplace"))
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
#+end_src

*** Backups
:PROPERTIES:
:CUSTOM_ID: h:333576D9-A2A7-4B4C-ABEB-F5A65ECD0464
:END:

And here are some settings pertaining to backups. I rarely need those,
but I prefer to be safe in the knowledge that if something goes awry
there is something to fall back to.

#+begin_src emacs-lisp
(setq backup-directory-alist
      `(("." . ,(concat user-emacs-directory "backup/"))))
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq kept-new-versions 6)
(setq kept-old-versions 2)
(setq create-lockfiles nil)
(setq tramp-backup-directory-alist backup-directory-alist)
#+end_src

* Frequently Asked Questions about this document
:PROPERTIES:
:CUSTOM_ID: h:05C4A225-0A08-43EC-BA7D-EC8B9C299ED2
:END:

There are some persistent questions that pop up in my email exchange, so
I thought I would cover them all in this section.

** How do you learn Emacs?
:PROPERTIES:
:CUSTOM_ID: h:425FEDB1-05B5-4D89-81CC-222C5ADA1986
:END:

There is no one-size-fits-all approach to learning. What one finds
satisfactory, another may consider insufficient. In my opinion, the best
way to learn Emacs is to start small, be patient, and brace yourself for
a lot of reading and experimentation.

The best skill you can master, the one that will always help you in your
Emacs journey, is the built-in help system. Learn to ask Emacs about
things you do not know about. This section documents the essentials of
Emacs' /introspectable nature/.

Know that =C-h= is the universal key for help commands (broadly
understood). It works both as a prefix and as a suffix. Some common help
commands:

- =C-h f= (=describe-function=) allows you to search for documentation about
  *functions*.
- =C-h v= (=describe-variable=) is the same for *variables*.
- =C-h o= (=describe-symbol=) is a wrapper of the above two, so you are
  searching for functions *or* variables. The proper name for any of these
  items is called a "symbol" (think of =name-of-thing= as symbolising a
  definition in the source code).
- =C-h k= (=describe-key=) will prompt you for a *key* binding. Once you type
  it in you will get help about what command corresponds to that key (if
  any). Note that this depends on the major mode you are in. For example
  =C-c C-c= does something different in Org and Eshell buffers. Try =C-h k
  C-c C-c= to find about the different functions these will invoke in
  their respective major mode.
- =C-h l= (=view-lossage=)produces a log with your most recent key presses
  and the commands they call. Emacs calls this the "lossage". Ever
  mistyped something and got to the wrong place? Use this as an
  opportunity to learn and, perhaps, a way to identify key sequences you
  would like to modify. (*pro tip*: you can edit/convert your lossage into
  a keyboard macro with =C-x C-k l=---also watch Prot's [[https://protesilaos.com/codelog/2020-03-14-emacs-kmacro-edit/][Edit keyboard
  macros]] (2020-03-14)).

In the above scenaria we see how =C-h= is used as a prefix: you are
starting a key sequence with it. Now here are some cases of using it as
a suffix:

- For /every incomplete key sequence/ if you follow it up with =C-h= you
  will get a help buffer about all possible key combinations that
  complete that sequence. For example, if you type =C-c C-h= inside of an
  Org buffer you will get all possible commands for Org mode and for all
  other minor modes you have active.
- The =C-h= suffix can be appended to longer key sequences. Indeed the
  length is irrelevant. Suppose you want to learn more about some of the
  advanced features of registers. =C-x r= is the common prefix for those
  commands, so you just do =C-x r C-h= and you get a buffer with more
  information.
- And, as you may imagine, you can even append the =C-h= /suffix/ to the =C-h=
  /prefix/. This is a fancy way of saying that =C-h C-h= will show you help
  about help commands themselves. But because this is a special case, it
  comes with some extras. Try it!

*All help buffers include links* to other parts of Emacs, from where you
can learn ever more information. For example, the help for =C-c C-h=
includes links to the commands that correspond to each key chord. Follow
the link to get documentation about that symbol.

More generally, you will find that a symbol is linked to its source.
Look carefully at the top of the buffer that displays the symbol's
documentation and you will find a link to the source code (library) from
where the function/variable (symbol) comes from.

Also know that the source code can be accessed at any time by means of
=M-x find-library= followed by the name you are looking for. Those are
called "features", by the way, and each library declares them using the
=provide= form at the end of the file (so when you use =require= you pass a
quoted feature symbol).

Help commands that ask you for a symbol as input can also be aware of
the context of the point (the cursor). If you are over the name of a
function and you type =C-h f=, that function will be the default match.
Hitting RET (Enter) will take you to its documentation. /This is a great
way to study source code/, because it will guide you to other libraries
or other parts of the same library from where you can understand how
things are pieced together. And it also works with the =find-library=
command.

While browsing Elisp source code, there are two commands that can be of
great help to navigate definitions. =xref-find-definitions=, bound to =M-.=
will take you to the definition of the symbol at point. While its
counterpart, the =xref-pop-marker-stack= (=M-,=), will bring you back to
where you where before. Similarly, the built-in Isearch tool can search
for the symbol at point with =M-s .= (the =isearch-forward-symbol-at-point=
command), which can then be followed up with =M-s o= to produce an "Occur"
buffer with all the results---use that as an index to move around (also
check: Isearch, occur, and extras (indiebrain-search.el)).

Finally, you should practice =C-h m= (=describe-mode=) as much as possible.
This is the help command for getting information about the major mode
you are in and for all the minor modes you have active and which are
pertinent to the current buffer. It will show you some valuable
documentation as well as the main key bindings and their commands. Try
it whenever you use something you have not mastered yet. For example, do
it in a =dired= buffer to see the main operations you can perform inside
of it (see [[#h:2591A95A-FC9F-40DA-9E24-A327A453606D][Dired (directory editor, file manager)]]).

** Why maintain all those 'indiebrain-*.el' files?
:PROPERTIES:
:CUSTOM_ID: h:6F51E985-C099-4439-B501-F4C4747B41A7
:END:

Those contain my custom Elisp code. Several of them provide extensions
to existing tools, while others introduce some new functionality. They
are written in accordance with the common emacs-lisp coding practices
and are regular Emacs packages - even though they only target my
use-case.

The main benefits of packaging my code are thus:

- Lexical scope :: The code is written in a way that does not introduce
  implicit dependencies on the environment. Everything within the file
  has to be known so that the compiler can properly interpret it.

- Byte compilation :: Because of the above, the code compiles cleanly.
  This allows me to execute my code a bit faster than it would otherwise
  be possible. The more I write, the greater the otherwise marginal
  performance gains.

- Transparency :: Users who copy my code are made aware of its
  dependencies, which saves me time answering emails why X from my
  dotemacs does not work on another's setup.

- Modularity :: Since my files render their dependencies and bindings
  explicit, it is easier to catch errors and debug them.

While my =indiebrain-*.el= are valid Emacs packages, they are NOT indented
to be distributed as such. Their "package" nature is a useful
organizational tool, nothing more. They should /never/ be made available
in an Emacs Lisp Package Archive (ELPA). I cannot promise that I will
keep them around forever (distributing a package implies a commitment to
its users).

** What is the purpose of "indiebrain/" and "contrib/"?
:PROPERTIES:
:CUSTOM_ID: h:353AF1E6-B4C0-4468-B957-DF0D2A7FE41C
:END:

The =indiebrain/= prefix in some unpackaged symbols works as a namespace that
captures all my custom, yet-to-be-reviewed code.  These can be functions
or variables.  The utility of this prefix is two-fold:

- It informs others that this symbol is not part of core Emacs or some
  other package. Otherwise it can be difficult to understand why
  something you copied did not work. Say, for example, I have a
  function that accepts an argument: =(indiebrain/function
  indiebrain/variable)=. If none of these had the namespace you could be
  misled into thinking that your Emacs setup already includes those
  symbols (and then you would get an error message).

- It makes it easier for me (and others) to quickly discover what
  additions I have made, for whatever reason that may. For instance, =M-x
  indiebrain/= will give me matches for all my interactive functions
  (depending on the completion framework, one can access those with just
  =M-x i/=). This also means that I can do =M-x occur indiebrain/= to
  produce an Occur buffer with all my symbols (pass a numeric argument
  to display N lines of context =C-u 5 M-s o=). From there I can, say,
  browse them all easily or even edit them using the full array of
  Emacs' functionality (occur's results buffer is made editable with =e=;
  you should be able to find that by using the information documented in
  [[#h:425FEDB1-05B5-4D89-81CC-222C5ADA1986][How do you learn Emacs?]]).

The same principles apply to the =contrib/= namespace. Whenever I copy
something from another user, I use that namespace to tell others that
this is not part of Emacs or any other package (it's good practice to
link to the source).

Adding =contrib/= also has another longer-term benefit. It informs my
future self that some bespoke configuration was needed to solve a
particular problem and, maybe, this has since been solved by a good
package, a newer version of Emacs, or I may eventually be able to
furnish my own alternative.

Again, =occur= or similar tools will filter those out when necessary.
Imagine having to do that without any namespaces… You would need to
check each symbol one by one to determine its origin.

The convention of separating namespaces with a forward slash is not
particularly important, though the linter for Elisp packaging will
complain about it, if you ever go down that path. It could be something
like =indiebrain-= or =my-= or whatever. What matters is to keep things
consistent and fairly easy to identify.

** Why do you use so many `setq' forms?
:PROPERTIES:
:CUSTOM_ID: h:5454DD71-6032-42C9-AFD3-73A9AC305620
:END:

To be clear, these are equivalent:

#+begin_example emacs-lisp
;; Style A
(setq var-1 'symbol)
(setq var-2 '(a b c))
(setq var-3 '((a . b) (c . d)))

;; Style B
(setq var-1 'symbol
      var-2 '(a b c)
      var-3 '((a . b) (c . d)))
#+end_example

You will notice that most of my configurations follow Style A. I do so
for a couple of reasons:

- It makes each variable easier to copy elsewhere, say, when sharing it
  online or to an =emacs -Q= scratch buffer.

- It is trivial to run =C-x C-e= (=eval-last-sexp=) on each balanced
  expression individually (note that =C-M-x= (=eval-defun=) can be used in
  Elisp buffers to evaluate the expression at point).

There are some cases where I use a single =setq= to configure several
closely related variables (Style B), but those are the exception to the
norm.

Style B gives me more problems with copy-pasting, while it does not
solve any real issues (besides, I finalise style A using a keyboard
macro, so there is no real difference in typing).

I find that Style A consists of balanced expressions that are easier to
keep consistent. This is especially true when you have a mixture of
values: boolean types, property lists, association lists…

** Why do you explicitly set variables the same as default?
:PROPERTIES:
:CUSTOM_ID: h:7BB16D54-7BAE-4B63-A8AC-93E4D046643B
:END:

You may have realised that many of my configurations will use a =setq=
that declares a value that is the same as its original in the source
code. I do this for two reasons:

1. To raise awareness of its existence. If someone does not like how the
   defaults work, they know where to look.

2. I guard against future versions that could be changing the defaults.

Obviously point 2 is not particularly strong for built-in libraries that
are already very stable, though I find that, on the balance, nothing bad
comes out of it.

At any rate, one must always read the NEWS (=C-h n= for =view-emacs-news=)
whenever one upgrades to a new version of Emacs. Though there is no
equivalent mechanism for individual packages… So here we are.

By the way, the fastest way to find a package's customisation options is
to visit its source code and produce an Occur buffer for its =defcustom=
configurations (which extends the ideas in [[#h:425FEDB1-05B5-4D89-81CC-222C5ADA1986][How do you learn Emacs?]]).

** Did you know XYZ package is better than the defaults?
:PROPERTIES:
:CUSTOM_ID: h:667E281D-7FDF-4157-A3C8-93E46EE8E982
:END:

As a rule of thumb, I choose external packages only after I give a fair
chance to the defaults. The idea is to take things slowly and learn
along the way, while consulting the official manual and relevant
documentation (I strongly encourage you to study the information
provided in [[#h:425FEDB1-05B5-4D89-81CC-222C5ADA1986][How do you learn Emacs?]]).

Without exposure to the built-in tools it is impossible to make an
informed decision about what is actually missing and what could be
improved further. Additionally, it is difficult to appreciate the
underlying rationale that led to a given element of design without
actually trying to put yourself in that mindset or workflow.

Put differently, keep an open mind about the alternatives before
deciding to reproduce the thing you had before, else you are assuming
your prior knowledge to be true in advance of any possible evidence to
the contrary (a sign of dogmatism).

The process of learning the internals of Emacs means that I write my own
Elisp functions when I feel that a standard tool could be tweaked on the
margin of its core utility in order to do what I want (read my answer to
the question [[#h:6F51E985-C099-4439-B501-F4C4747B41A7][Why maintain all those 'indiebrain-*.el' files?]] as well as
the one on [[#h:353AF1E6-B4C0-4468-B957-DF0D2A7FE41C][What is the purpose of "indiebrain/" and "contrib/"?]]).
External packages that I do use are either a clear upgrade over the
defaults or otherwise extend the functionality of what is already
available.

You will not find any superficialities herein: no rainbow-coloured mode
lines, no icons, no tool bars with bells and spinning wheels, nothing. I
respect the fact that they exist, but find that they do not contribute
to my productivity.

Since you read this (and the rest of my dotemacs, I presume), also
consider two highly valuable blog posts by Karthik Chikmagalur:

- [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]] (2020-11-17).
- [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with Emacs]] (2020-12-11).

** What is the meaning of the `s-KEY' bindings?
:PROPERTIES:
:CUSTOM_ID: h:51B9B73E-3527-422C-9672-AEAF22D9FA15
:END:

Some sections of this document assign functions to key combinations that
involve the "Super" key (also known as the "Windows key" on some
commercial keyboards). This is represented as a lower case =s=.

Those key bindings typically are alternative ways of invoking /common
commands/ that are by default bound to longer key chords. The original
keys will continue to function as intended (for example, =C-x o= is also
=s-o=). Otherwise they are bound to my own custom commands.

Note that your choice of desktop environment (or window manager) might
render some of those useless. The DE/WM will simply intercept the key
chord before it is ever sent to Emacs. For example, GNOME has a *hidden*
key mapping to =s-p=, which does something with monitors (last time I
checked on GNOME 3.30). Such bindings are scattered throughout the
config database that is normally accessed with =gsettings= on the command
line or the graphical =dconf-editor= (not pretty either way). For me this
is not a problem, because I disable all of the DE's key bindings

To find all my keybindings of this sort in the source code version of
this document from inside of Emacs, do =M-s o= (or =M-x occur=) followed by
the pattern ="[a-zA-Z<]?-?s-.+?"= (please contact me if you know how to
improve this).

** How to reproduce your dotemacs?
:PROPERTIES:
:CUSTOM_ID: h:D052B004-DC9D-4EB4-9CCB-C7D1B7B21FAE
:END:

Remember that I am not using Emacs 27 or some other stable release. I
currently am on {{{emacs-development-version}}}./

First you must understand that this is my personal setup: I have never
tried to develop a framework that works out-of-the-box for other users.
It runs contrary to how I approach Emacs as a long-term investment that
involves learning everything from the basics to the more advanced
issues: which means starting from scratch while being patient,
persistent, and humble.

Furthermore, it is important to understand that the very nature of this
setup makes it highly opinionated and, thus, several of its components
may be predicated on implicit assumptions about preferences.

As you may know from René Magritte's famous /Ceci n'est pas une pipe/
painting, what you think you are looking at is not equivalent to its
actuality. You may be led to believe that my dotemacs is in fact an
"Emacs distro", or "starter kit", or whatnot, and that you can just
clone it and re-use it right away. In truth /ceci n'est pas une
distribution Emacs/. It is my personal setup.

With those granted, I understand that people may want to benefit from
what I already make public and, in turn, I want to help them to that
end. It is not my intent to create impediments to one's progress as an
Emacs user, nor to obfuscate my otherwise readily available corpus of
labor. I wish to make things easy and accessible, without prejudice to
the aforementioned points about what /this/ is.

To reproduce my setup, you first need to clone my dotfiles' repository.
This includes more stuff than just my Emacs files, though it is what I
use. Let's say you plan to clone the repo at =~/Downloads/indiebrain-dotfiles=. You
invoke this command from your shell:

#+begin_example sh
git clone https://github.com/indiebrain/.files.git.git ~/Downloads/indiebrain-dotfiles
#+end_example

If you do not want to copy the entire history of the project, you can
pass the =--depth= flag, like this:

#+begin_example sh
git clone --depth 1 https://github.com/indiebrain/.files.git ~/Downloads/indiebrain-dotfiles
#+end_example

That one fetches just the latest commit and is considerably faster.
Though the full history is useful if you plan to retrieve some datum
from it.

My dotfiles are managed with the help of the GNU Stow program. What that
does is create and handle symlinks from a source directory to a
destination. The file structure of my dotfiles is designed to reflect
the expected end result at the =$HOME= directory.

Stow operates on what it calls a "package": a set of files whose file
structure will be reproduced at the target filesystem path. Take a look
at the tree representation of my "emacs package", per Stow's parlance
(this output may not be exactly the same you will get depending on when
you review it, but that is beside the point).

#+begin_example sh
emacs
└── .emacs.d/
    ├── contrib-lisp/
    │   ├── .gitkeep
    │   └── rcodetools.el
    ├── indiebrain-lisp/
    │   ├── .gitkeep
    │   ├── indiebrain-comment.el
    │   ├── indiebrain-common.el
    │   ├── indiebrain-consult.el
    │   ├── indiebrain-cursor.el
    │   ├── indiebrain-diary.el
    │   ├── indiebrain-diff.el
    │   ├── indiebrain-dired.el
    │   ├── indiebrain-elfeed.el
    │   ├── indiebrain-embark.el
    │   ├── indiebrain-eshell.el
    │   ├── indiebrain-eww.el
    │   ├── indiebrain-fill.el
    │   ├── indiebrain-fonts.el
    │   ├── indiebrain-ibuffer.el
    │   ├── indiebrain-logos.el
    │   ├── indiebrain-minibuffer.el
    │   ├── indiebrain-moody.el
    │   ├── indiebrain-orderless.el
    │   ├── indiebrain-outline.el
    │   ├── indiebrain-project.el
    │   ├── indiebrain-pulse.el
    │   ├── indiebrain-recentf.el
    │   ├── indiebrain-search.el
    │   ├── indiebrain-sideline.el
    │   ├── indiebrain-simple.el
    │   ├── indiebrain-spell.el
    │   ├── indiebrain-tab.el
    │   ├── indiebrain-text.el
    │   └── indiebrain-vc.el
    ├── .gitignore
    ├── LICENSE.txt
    ├── README.org
    ├── early-init.el
    ├── indiebrain-emacs.org
    └── init.el
3 directories, 38 files
#+end_src

When we invoke a =stow= command on this =emacs= package we are instructing
the program to create symlinks to a directory called =.emacs.d= and to
place all relevant files/directories inside of it. What we want is to
mirror this tree in our =$HOME= directory (I use a mix of GNU/Linux, and
MacOS hosts by the way):


#+begin_example sh
~/Downloads/indiebrain-dotfiles $ stow -t "$HOME" emacs
#+end_example

As you will learn from Stow's manpage, the =-t= flag points at the target
destination. So we want to mirror the =.emacs.d= of my dotfiles to that
found in =~/.emacs.d=. If the latter exists, only the relevant files will
be symlinked. Otherwise it will be created outright as a symlink itself.

If files that conflict with mine, like =init.el=, already exist at the
target path, then Stow will throw an error and abort its operation. This
is good: we do not want to overwrite existing data. So make sure to
create backups of everything and move them to another location.

Whenever I add or remove a file, my "emacs package" needs to be updated
accordingly: the symlinks have to be generated anew. Adding the =-R= flag
does the trick:

#+begin_example sh
~/Downloads/indiebrain-dotfiles $ stow -t "$HOME" -R emacs
#+end_example

Similarly, if you ever want to delete those symlinks in a clean way,
pass the =-D= flag instead of =-R=:

#+begin_example sh
~/Downloads/indiebrain-dotfiles $ stow -t "$HOME" -D emacs
#+end_example

The same is true for all other "packages" in my dotfiles' repo. However,
I prefer to the (un)installation of the whole =.files= project via the
=install= and =uninstall= helper scripts; as opposted to managing the
placement of individual GNU Stow packages.

At this point you are ready to start using my Emacs setup. But not
everything will work just yet. As was already discussed in the section
about Main macros and other contents of my init.el (for Emacs 28), I
have a policy of not auto-installing packages by default. If you want to
do that when you first launch my Emacs, you must create a new file
called =basic-init.el= and place it in the same place where my =init.el= and
=indiebrain-emacs.org= are found (the =basic-init.el= is read before initiating my
main configuration file). In that file you must add the following:

#+begin_example emacs-lisp
(setq indiebrain-emacs-autoinstall-elpa t)
#+end_example

This means that you explicitly opt in to automatically installing all my
defined packages that are found in GNU ELPA or MELPA.

If you do not create the =basic-init.el= with those contents, then the
default behaviour is to run my setup and produce a series of warnings
about missing packages that you need to install on your own. The
resulting log's messages will explain how to do that in one go, though
you can always opt for another approach if you want. This default method
offers you the opportunity to think carefully about what packages you
really need and proceed to remove the ones you do not want to keep
around.

Whatever you do with the installation of items from Emacs Lisp Package
Archives, you will always have to manually configure the few packages I
maintain through their source code. Again, the warning messages will
tell you what they expect from you. Basically, you will need to look up
their names in the =indiebrain-emacs.org= file to find their repo's URL.
Then you will have to clone that to the =contrib-elisp= path inside of
your =.emacs.d=. Or comment out their code block (or delete it) if you do
not want them.

You are finally done and ready to start using what I develop. And you
have realised by now that /this definitely is my personal Emacs setup and
I only target my use-case/ which means, among others, that I will never
add bells and whistles that I do not use just to satisfy demand for them
(e.g. icons).

I think that just about covers it. If you have any questions, either
open an issue in [[https://github.com/indiebrain/.files/][my dotfiles' repo]]. Remember that I wish to be helpful,
though I have no plan to turn this into yet another Emacs distro.

** What is your distro and/or window manager?
:PROPERTIES:
:CUSTOM_ID: h:21C6323F-F376-450D-881F-6134998D3236
:END:

I have been on GNU/Linux since the fall of 2003. For the most time I
have used Debian (for personal use / general dorking around) and MacOS
(for work - hey, it's how I keep food on the table).

My criterion for picking a distro is that it is community-driven and has
a strong following that ensures its longer-term continuity and overall
stability.

When using GNU/Linux, I build Emacs [[https://git.savannah.gnu.org/cgit/emacs.git/][from source]], directly from trunk
(i.e. the =master= branch). When using MacOS, I use the Homebrew "Package
Manger" to install the =emacs-nightly= Cask.

** What hardware do you use?
:PROPERTIES:
:CUSTOM_ID: h:F5188451-81D1-4EE8-B5D7-7327869A2EE5
:END:

Until recently, my primary computing device was a Lenovo Thinkpad X220.
I purchased this "used" a number of years ago for roughly $150 USD. When
the OEM (Original Equipment Manufacturer) wireless NIC failed the X220's
proved the perfect motiviation to learn about building a more
user-respecting custom BIOS - [[https://aaronkuehler.com/blog/2015/09/20/installing-coreboot---lenovo-thinkpad-x220/][more about this particular project on my
blog]]. Unfortunately, after may years of dutiful service, in (2021-05)
the SATA interface on the main board stopped working properly, RIP old
friend. I've switched to the Librem 13 v2 I purchased in 2017 - as a
means of supporting that then looked like a promising young Social
Purpose hardware company called Purism. In early days, Purism's mission
statement aligned with my politics and goals of promoting User Freedom.
For work, I use a 13" Macbook Pro to maintain some proximity to my
coworkers and the problems they encounter while we work on software
projects together. Please do NOT confuse this as a continued endorsement
of any company nor their products. These just happen to be the hardware
available to me in this moment.

I primarily work using the laptop as a "desktop" - extrnal monitor,
keyboard, mouse, etc. The monitor runs at 1080p resolution. I use a US
Qwerty [[http://codekeyboards.com/][CODE keybaord]] with CHERRY MX BLUE switches - I like tactile and
auditroy feedback as I type.

* Other people's Emacs work
:PROPERTIES:
:CUSTOM_ID: h:A34B244D-FCA6-43CA-A8D6-6F662D8D50F4
:END:

Emacs is both a piece of software and a diverse community of people that
are brought together by their shared interest in this unique program.
Emacs' development unfolds through a distributed network of volunteer
efforts coordinated by members of the GNU project. While the community
at-large contributes lots of valuable ideas to a pool of accumulated
knowledge, such as configurations with custom Elisp code, video or
written tutorials on particular workflows, and packages that cover a
broad range of needs.

Outside the narrow confines of computer, Emacs is it people.

Here is a non-exhaustive list of users that I have found to be helpful,
each in their own unique way:

- Protesilaos Savrou :: [[https://protesilaos.com/dotemacs/][Prot's dotemacs]] configuration is the principle
  source for the structure and principles of this confituration. [[https://www.youtube.com/c/ProtesilaosStavrou/videos][Prot's
  YouTube channel]] is a steady stream of practical knowledge and new
  sources of inspiration.

- Omar Antolín Camarena :: Omar's work is mentioned several times in
  this document (author of Orderless, Embark, and co-author of
  Marginalia). Make sure to check Omar's packages and also monitor [[https://github.com/oantolin/emacs-config][the
  personal Emacs configuration]] which doubles as a laboratory of
  experimentation for new packages or other useful ideas.

- Daniel Mendler :: Daniel's name is referenced in a number of this
  document's sections (author of Consult, Goggles, Recursion
  indicator, co-author of Marginalia together with Omar---you get the
  idea). As far as I can tell, Daniel does not share an Emacs
  configuration, though one can still learn a lot by studying the code
  of the numerous repositories on [[https://github.com/minad][@minad's Github]].

- Manuel Uberti :: = Manuel offers a lot to the Emacs milieu through
  code contributions but also by reporting issues and communicating with
  package maintainers. The domain name [[https://www.manueluberti.eu/][www.manueluberti.eu]] hosts a blog
  with Manuel's musings on Emacs. For example, you will find articles
  that I have already referenced in this document, such as [[https://www.manueluberti.eu/emacs/2020/11/14/extending-project/][Extending
  project.el]].

- Nicolas De Jaeghere :: Nicolas maintains [[https://github.com/Koekelas/dotfiles][a personal dotfiles repo]]
  where you can find an =emacs.org= file with lots of advanced code
  snippets.

- Rainer König :: Rainer has [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][a series of video tutorials]] on how to
  organize your life using various Org features, such as check lists and
  the agenda. Each video covers a single utility or closely related
  concepts, while the whole playlist offers a progression from basic to
  more advanced workflows. Highly recommended!

- Mike Zamansky :: Mike is a computer science professor who has created
  [[https://www.youtube.com/channel/UCxkMDXQ5qzYOgXPRnOBrp1w][videos on Emacs]] for several years. There is a wealth of information to
  gather from those presentations as well as the corresponding
  [[https://github.com/zamansky/dot-emacs][dot-emacs code repository]].

- Emacs Elements :: This is [[https://www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ][a channel on Youtube]] where Raoul Comninos
  shows how to get things done using Emacs. There are tutorials on how
  to use the =diary=, =calendar=, and =org-agenda=, while you will also find
  more advanced topics such as how to install, use, and make sense of
  the powerful Icicles completion framework, as well as other useful
  packages.

- System Crafters :: David Wilson's work on Emacs covers a broad range
  of themes, encapsulated in the [[https://github.com/daviwil/emacs-from-scratch][Emacs from scratch]] configuration. The
  [[https://youtube.com/c/SystemCrafters][Youtube channel]] contains lots of videos on how to set up and use all
  sorts of packages in Emacs, such as Org and the Mu4e email client.

- Karthik Chikmagalur :: Karthik's [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]]
  (2020-11-17) and [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with Emacs]] (2020-12-11) are
  essential reading for anyone wanting to gain an overview of some of
  Emacs' capabilities out-of-the-box and learn about its 'hidden gems'.
  Karthik's website includes philosophical insights as well, such as
  those found in [[https://karthinks.com/blog/thoughts-on-strength-training/][Thoughts on Strength Training]] (2019-03-02).

- James Norman Vladimir Cash :: James produces videos on Emacs, such as
  this one [[https://occasionallycogent.com/custom_emacs_modeline_video_edition/index.html][on customising the modeline]] and writes about similar topics,
  like reading email in Emacs. Though I also appreciate commentary of a
  political sort: [[https://occasionallycogent.com/against_mindless_minimalism/index.html][Against Mindless Software Minimalism]] (2019-03-24).

- Karl Voit :: Karl is an expert in Personal Information Management
  (PIM) covering that and relevant topics over at [[https://karl-voit.at/][karl-voit.at]]. There
  are lots of interesting articles on offer, such as how to organize
  data with [[https://karl-voit.at/2020/01/25/avoid-complex-folder-hierarchies/][Don't Do Complex Folder Hierarchies]] and to keep a web
  presence with [[https://karl-voit.at/2020/10/23/avoid-web-forums/][Don't Contribute Anything Relevant in Web Forums]]. Karl
  also participated in the 2021 edition of the /Grazer Linuxtage/
  conference with [[https://karl-voit.at/2021/04/10/GLT21-emacs-org-features/][a talk on Org features and extras]].

- Sacha Chua :: Sacha's work is instrumental to the Emacs community's
  self awareness. The [[https://sachachua.com/blog/category/geek/emacs/][weekly "Emacs news" blog entries]] offers an
  overview of what is happening in our space---consider it essential
  reading. While Sacha was among the organizers of the last two yearly
  Emacsconf events and has shared a lot of valuable insights throughout
  the years, such as hand-drawn guides to using Emacs, chats with
  prominent members of the Emacs community, and more.

Please note that this is a non-exhaustive list. Lots of people
contribute to the betterment of Emacs, such as Jonas Bernoulli
(developer of Magit, among many others), Oleh Krehel (developer of Ivy,
Counsel, Swiper, and more), Thierry Volpiatto (maintainer of Helm),
Bastien Guerry (Org maintainer), Eli Zaretskii (Emacs maintainer), Lars
Ingebrigtsen (author of Gnus, co-maintainer of Emacs), Dmitry Gutov
(maintainer of several built-in subsystems like project.el, as well as
external packages like Company, diff-hl...), and many others.

Every bit counts: a bug report, a blog post detailing one's workflow,
participation in a mailing list thread, etc. Do not hesitate to add your
part and become a member of this wonderful community.

Thank you to everyone!
