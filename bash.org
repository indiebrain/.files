#+TITLE: BASH Configuration

* bashrc

:PROPERTIES:
:header-args: :tangle ~/.bashrc
:END:

** CLI Colors

   For commands that support colors, enable the use of colors to
   better visually understand the output of commands.

   #+BEGIN_SRC sh
     export CLICOLOR=1
   #+END_SRC


** $PATH

*** /usr/local/bin

   Binaries stored in the =/usr/local/bin= directory take precedence
   over their counterparts stored elsewhere on the =PATH=

   #+BEGIN_SRC sh
     export PATH=/usr/local/bin:/usr/local/sbin:$PATH
   #+END_SRC


*** .bin

   I keep personal scripts in =~/.bin=. Ensure that scripts found in
   =~/.bin= are available on the =PATH= so they can be executed
   without providing full paths:

   For example, instead of typing =~/.bin/script-name= simply type
   =script-name=.

   #+BEGIN_SRC sh
     export PATH=$PATH:$HOME/.bin
   #+END_SRC



** Aliases

*** *nix aliases

  Make =ls= output more information about files and directories in a
  human readable format.

  #+BEGIN_SRC sh
    alias ls='ls -lha'
  #+END_SRC



*** Git aliases

   =gs= is shorthand for the status of a git repository.

   #+BEGIN_SRC sh
     alias gs="git status"
   #+END_SRC

   =gl= shows the railroad tracks of the current head ref

   #+BEGIN_SRC sh
     alias gl='git log --graph --oneline --decorate --max-count 10'
   #+END_SRC



** Prompt

  Configure the shell prompt. This happens to check if we're in a git
  managed directory and adds some status info to the command line.

  #+BEGIN_SRC sh
    # Get a graphical representation of the clean/dirty state of a git repository
    function parse_git_dirty {
      [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit, working tree clean" ]] && echo -e '\033[31m ✪ \033[0m'|| echo -e '\033[32m ✪ \033[0m'
    }

    # Get the name of the current git brank
    function parse_git_branch {
      git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/[\1$(parse_git_dirty)]/"
    }

    # Set the prompt pattern
    export PS1='
    \[\033[0;32m\]\@\[\033[0m\] \[\033[1;33m\]\w\[\033[0m\] $(parse_git_branch)
    => '
  #+END_SRC


** Editors

   Use emacs as the default editor for the shell

   #+BEGIN_SRC sh
     export EDITOR=emacs
   #+END_SRC


** History

*** Store Unique Commands

    Store only unique commands in bash history. Also provide a way to
    manually exclude commands from being recorded in the history. To do
    this, prefix the command with whitespace.

     #+BEGIN_SRC sh
       export HISTCONTROL=ignoreboth:erasedups
     #+END_SRC


*** Number of History Entries

    Set the number of commands which can be stored in the history.

    #+BEGIN_SRC sh
      export HISTSIZE=1000
      export HISTFILESIZE=1000
    #+END_SRC

** exenv

*** elixir installation path

  Use the [[https://github.com/mururu/exenv][exenv]] project to manage local [[http://elixir-lang.org/][Elixir]] installations.

  Store installations in =/usr/local/var/exenv= instead of the user
  home directory so they're available to all users of the system.

  #+BEGIN_SRC sh
    export "EXENV_ROOT=/usr/local/var/exenv"
  #+END_SRC


*** exenv initialization

  If the =exenv= command is available initialize the exenv
  system. This provides access to shims and autocompletion.

  #+BEGIN_SRC sh
    if which exenv > /dev/null; then eval "$(exenv init -)"; fi
  #+END_SRC



** rbenv

*** ruby installation path

  Use the [[https://github.com/rbenv/rbenv][rbenv]] project to manage local [[https://www.ruby-lang.org][Ruby]] installations.

  Store installations in =/usr/local/var/rbenv= instead of the user
  home directory so they are available to all users of the system.

  #+BEGIN_SRC sh
    RBENV_ROOT=/usr/local/var/rbenv
  #+END_SRC


*** rbenv initialization

  If the =rbenv= command is available initialize the rbenv
  system. This provides access to shims and autocompletion.

  #+BEGIN_SRC sh
    if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi
  #+END_SRC


* bash_profile

  :PROPERTIES:
  :header-args: :tangle ~/.bash_profile
  :END:

  Use the same configuration for =.bash_profile= as the =.bashrc=

  #+BEGIN_SRC sh
    if [ -f ~/.bashrc ];
        then source ~/.bashrc
    fi
  #+END_SRC
