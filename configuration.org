#+TITLE: Dotfiles Configuration

Shell and CLI Tooling configuration

* bashrc
  :PROPERTIES:
  :header-args: :tangle ~/.bashrc
  :END:

** CLI Colors

   For commands that support colors, enable the use of colors to
   better visually understand the output of commands.

   #+begin_src sh
     export CLICOLOR=1
   #+end_src

** $PATH

*** /usr/local/bin

   Binaries stored in the =/usr/local/bin= directory take precedence
   over their counterparts stored elsewhere on the =PATH=

   #+begin_src sh
     export PATH=/usr/local/bin:/usr/local/sbin:$PATH
   #+end_src

*** ~/bin

   I keep personal scripts in =~/bin=. Ensure that scripts found in
   =~/bin= are available on the =PATH= so they can be executed
   without providing full paths:

   For example, instead of typing =~/bin/script-name= simply type
   =script-name=.

   #+begin_src sh
     export PATH=$PATH:$HOME/bin
   #+end_src

** Aliases

*** *nix aliases

**** ls

  Make =ls= output more information about files and directories in a
  human readable format.

  #+begin_src sh :tangle (when (eq system-type 'gnu/linux) "~/.bashrc")
    alias ls='ls --color'
  #+end_src

**** grep

  Make =grep= highlight matches.

  #+begin_src sh :tangle (when (eq system-type 'gnu/linux) "~/.bashrc")
    alias grep='grep --color'
  #+end_src

**** pbcopy

  Add a shorthand to copy data to the system clipboard on the cli

  #+begin_src sh :tangle (when (eq system-type 'gnu/linux) "~/.bashrc")
    alias pbcopy='xclip -selection clipboard'
  #+end_src

*** Git aliases

   =gs= is shorthand for the status of a git repository.

   #+begin_src sh
     alias gs="git status"
   #+end_src

   =gl= shows the railroad tracks of the current head ref

   #+begin_src sh
     alias gl='git log --graph --oneline --decorate --max-count 10'
   #+end_src

** Prompt

  Configure the shell prompt. This happens to check if we're in a git
  managed directory and adds some status info to the command line.

  #+begin_src sh
    # Get a graphical representation of the clean/dirty state of a git repository
    # colors
    case "$TERM" in
        xterm*|rxvt*|screen*|eterm-color)
            ESC="\033"
            RED="\[$ESC[01;31m\]"
            LIGHT_RED="\[$ESC[1;31m\]"
            GREEN="\[$ESC[01;32m\]"
            LIGHT_GREEN="\[$ESC[1;32m\]"
            GREY="\[$ESC[0;37m\]"
            CYAN="\[$ESC[01;36m\]"
            YELLOW="\[$ESC[0;33m\]"
            LIGHT_VIOLET="\[$ESC[1;35m\]"
            RESET="\[$ESC[0m\]"
        ;;
        ,*)
            ESC=""
            RED=""
            LIGHT_RED=""
            GREEN=""
            LIGHT_GREEN=""
            GREY=""
            CYAN=""
            YELLOW=""
            LIGHT_VIOLET=""
            RESET=""
        ;;
    esac

    # prints path to git directory
    __git_dirname() {
        local dirname
        if [ -d .git ]; then
            dirname=".git"
        else
            dirname="$(git rev-parse --git-dir 2>/dev/null)"
        fi
        echo "$dirname"
    }

    # gets the branching state of the repository
    # optional arg: path to git directory
    __git_branching_state() {
        local gitdir="$1" || "$(__git_dirname)"
        local state

        if [ -f "$gitdir/rebase-merge/interactive" ]; then
            state="rebase-i"
        elif [ -d "$gitdir/rebase-merge" ]; then
            state="rebase-m"
        else
            if [ -d "$gitdir/rebase-apply" ]; then
                if [ -f "$gitdir/rebase-apply/rebasing" ]; then
                    state="rebase"
                elif [ -f "$gitdir/rebase-apply/applying" ]; then
                    state="am"
                else
                    state="am/r"
                fi
            elif [ -f "$gitdir/MERGE_HEAD" ]; then
                state="merge" # merging
            elif [ -f "$gitdir/BISECT_LOG" ]; then
                state="bisect" # bisecting
            fi
        fi
        echo "$state"
    }

    # prints the working directory state of the repository using symbols
    # these could be expensive.. would make sense to have configs to turn off
    # * - modified / + - staged / ^ - stashed / % - untracked
    __git_working_dir_symbols() {
        local symbols

        # in working dir
        if [ true = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
            git diff --no-ext-diff --quiet --exit-code || symbols="*"
            if git rev-parse --quiet --verify HEAD >/dev/null; then
                git diff-index --cached --quiet HEAD -- || symbols="${symbols}+"
            fi
        fi

        # stashed
        git rev-parse --verify refs/stash >/dev/null 2>&1 && symbols="${symbols}^"

        # untracked files
        if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            symbols="${symbols}%"
        fi
        echo "$symbols"
    }

    # prints current / parent branch name
    # optional arg: 'parent' -- returns a limited guess of the parent
    # optional arg: path to git directory
    __git_branch_name() {
        # current branch name
        local branch
        local gitdir="$2" || "$(__git_dirname)"
        branch="$(git symbolic-ref HEAD 2>/dev/null)" || {
            branch="$(git describe --contains --all HEAD 2>/dev/null)" ||
                branch="$(cut -c1-7 "$gitdir/HEAD" 2>/dev/null)..." ||
                    branch="unknown"

            branch="${branch##remotes/}"
            branch="($branch)"
        }
        branch="${branch##refs/heads/}"

        # parent branch name
        if [ parent = "$1" ]; then
            if [ master = "$branch" ]; then
                local refs="$(git for-each-ref --format="%(refname:short)")"
                case "$refs" in
                    ,*git-svn*) # git-svn repo
                        branch='git-svn' ;;
                    ,*origin*) # remote clone
                        branch='origin' ;;
                    ,*)
                        branch='HEAD' ;; # same repo
                esac
            else
                # TODO.. would be nice to improve this to determine the actual
                # merge base (git merge-base) and compare against that instead of
                # always assuming master. In this way a 'topic/feature' branch
                # would show the diff counts for its parent 'next/develop' branch
                # rather than those plus those on the 'next/develop' branch.
                # I don't think we want to loop over the refs comparing ... that's
                # fuzzy.
                branch='master' # on a branch
            fi
        fi
        echo "$branch"
    }

    # prints if inside git directory or bare git repository
    __git_in_gitdir() {
        if [ true = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
            if [ true = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
                echo 'bare'
            else
                echo 'gitdir'
            fi
        fi
    }

    # prints number of commits that are available on ref B but not ref A
    # arg1: reference A
    # arg2: reference B
    __git_commit_diff_count() {
        echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
    }

    # build combined (+/-) counts for related commits
    __git_count_str() {
        local str
        local parent="$(__git_branch_name parent)"
        local ahead_count="$(__git_commit_diff_count $parent HEAD)"
        local behind_count="$(__git_commit_diff_count HEAD $parent)"

        if [ 0 -lt "$ahead_count" ]; then
            str="${GREEN}+${ahead_count}${RESET}"
        fi

        if [ 0 -lt "$behind_count" ]; then
            [ -n "$str" ] && str="$str/"
            str="${str}${LIGHT_RED}-${behind_count}${RESET}"
        fi

        [ -n "$str" ] && str="($str)"
        echo "$str"
    }

    # install git integration into PS1
    __git_prompt() {
        local last_exit="$?" # keep here.. so we get the last command

        # setup PS1
        local host="${LIGHT_GREEN}\h:${RESET}"
        local dir="${YELLOW}\W${RESET}"
        PS1="[$host $dir]"

        # when in git repository
        local gitdir="$(__git_dirname)"
        if [ -n "$gitdir" ]; then
            local branch
            local extras

            local in_gitdir="$(__git_in_gitdir)"
            case "$in_gitdir" in
                gitdir|bare)
                    branch="~$(echo $in_gitdir | tr "[:lower:]" "[:upper:]")~"
                    extras=""
                ;;
                ,*)
                    local branch="$(__git_branch_name current ${gitdir})"
                    local br_state="$(__git_branching_state $gitdir)"

                    # rebasing..use merge head for branch name
                    case "$br_state" in
                        rebase-*)
                            # get the ref head during rebase
                            branch="$(cat "$gitdir/rebase-merge/head-name")"
                            branch="${branch##refs/heads/}"
                            branch="${branch##remotes/}"
                        ;;
                    esac

                    # extras (count strings, working dir symbols)
                    local countstr="$(__git_count_str)"
                    local wd_syms="${LIGHT_VIOLET}$(__git_working_dir_symbols)${RESET}"
                    extras="${countstr} ${wd_syms}"
                ;;
            esac
            branch="${GREY}${branch}${RESET}"

            # update PS1
            PS1="${PS1} ${branch}${extras}"
        fi

        # setup marker that acts off of last exit code
        local marker
        if [ 0 -eq "$last_exit" ]; then
            marker="$GREEN"
        else
            marker="$RED"
        fi
        marker="${marker}\$${RESET}"
        PS1="\n${PS1} â†’\n${marker} "
    }
    PROMPT_COMMAND=__git_prompt
  #+end_src

** Editors

   Use emacs as the default editor for the shell

   #+begin_src sh
     export EDITOR=emacs
   #+end_src

** History

   A ton of the following is ripped directly from the [[https://www.digitalocean.com/community/tutorials/how-to-use-bash-history-commands-and-expansions-on-a-linux-vps][How To Use Bash
   History Commands and Expansions on a Linux VPS]] guide.

*** Immediately store commands

    To do this correctly, we need to do a bit of a hack. We need to
    append to the history file immediately with =history -a=

    #+begin_src sh
      export PROMPT_COMMAND="history -a; $PROMPT_COMMAND"
    #+end_src

*** Append to the history logs

    By default, bash writes its history at the end of each session,
    overwriting the existing file with an updated version. This means
    that if you are logged in with multiple bash sessions, only the
    last one to exit will have its history saved.

    #+begin_src sh
      shopt -s histappend
    #+end_src

*** Store Unique Commands

    Store only unique commands in bash history. Also provide a way to
    manually exclude commands from being recorded in the history. To do
    this, prefix the command with whitespace.

     #+begin_src sh
       export HISTCONTROL=ignoreboth:erasedups
     #+end_src

*** Number of History Entries

    Set the number of commands which can be stored in the history.

    #+begin_src sh
      export HISTSIZE=5000
      export HISTFILESIZE=10000
    #+end_src

** Bash Completion

   On macOS hosts bash-completion will be installed via Homebrew and
   we'll load completions according to its conventions - see =brew info bash-completion=.

   #+begin_src sh :tangle (when (eq system-type 'darwin) "~/.bashrc")
       [[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] && . "/usr/local/etc/profile.d/bash_completion.sh"
   #+end_src

   However, on GNU/Linux hosts - IE Debian hosts, we'll use [[https://github.com/scop/bash-completion#installation][the official means of loading bash-completion completions]].

   #+begin_src sh :tangle (when (eq system-type 'gnu/linux) "~/.bashrc")
     # Use bash-completion, if available
     [[ $PS1 && -f /usr/share/bash-completion/bash_completion ]] && \
         source /usr/share/bash-completion/bash_completion
   #+end_src

** ASDF Version Manager

   I've used disparate version managers for ruby, elixir, node, etc
   for years. [[https://github.com/asdf-vm/asdf][ASDF]] promises to unify the interface across all of these
   version managers - so I'm going to give it a shot.

   #+begin_src sh
     source $HOME/.asdf/asdf.sh
     source $HOME/.asdf/completions/asdf.bash
   #+end_src

** ruby

*** Spring
   Too many times have I been bitten by the [[https://github.com/rails/spring][spring]] gem. Kill it with fire.

   #+begin_src sh
     DISABLE_SPRING=1
   #+end_src

*** Bundler
   Sometimes bundler installs and pins gems to palatform specific
   versions - IE gems which would only be valid on macOS hosts. To
   prevent this, the bundler documentation suggests setting the
   =BUNDLE_FORCE_RUBY_PLATFORM= variable to ignore the host's platform
   when installing gems and compile native extensions on gem install
   instead.

   #+begin_src sh
     BUNDLE_FORCE_RUBY_PLATFORM=1
   #+end_src
** exercism

   Load the exercism bash completions if they exits

   #+begin_src sh
     if [ -f ~/.config/exercism/exercism_completion.bash ]; then
         source ~/.config/exercism/exercism_completion.bash
     fi
   #+end_src

** go

   #+begin_src sh
     export GOPATH=$HOME/Developer/go
     export PATH=$PATH:$GOPATH/bin
   #+end_src
** Departure

   We use departure at work with MySQL. It makes stuff break all the
   time. Here I globally disable it.

   #+begin_src sh
     export DISABLE_DEPARTURE=1
   #+end_src

** Power

   Source in the power user credentials/secrets
   #+begin_src sh
     if [ -f ~/credentials/.power ]
     then source ~/credentials/.power
     fi
   #+end_src

* bash_profile
  :PROPERTIES:
  :header-args: :tangle ~/.bash_profile
  :END:

  Use the same configuration for =.bash_profile= as the =.bashrc=

  #+begin_src sh
    if [ -f ~/.bashrc ];
    then source ~/.bashrc
    fi
  #+end_src

* ASDF Version manager

** .asdfrc
  :PROPERTIES:
  :header-args: :tangle ~/.asdfrc
  :END:

   Each language's version manager communities seem to have come to
   different conclusions on how to represent "required versions". This
   setting tells asdf to allow the language specific plugin to attempt
   to use the language's version manager community's default file for
   specifying a version.

   #+begin_src conf
     legacy_version_file = yes
   #+end_src

* gnome-terminal
  :PROPERTIES:
  :header-args: :tangle ~/.gruvbox-profile.dconf
  :END:

  This is my gnome-terminal configuration. This configuration will be
  tangled to ~/.gruvbox-profile.dconf. At some point I'll automate the
  installation, but for now to import the profile:

  1. Open gnome-terminal
  2. Create a new profile
  3. Take node of the UUID of the Profile
  4. Import the profile settings into the new profile
     =cat ~/.gruvbox-profile.dconf | dconf load /org/gnome/terminal/legacy/profiles:/:<profile-uuid-here>/=

  #+begin_src text
    [/]
    foreground-color='rgb(235,219,178)'
    visible-name='Gruvbox'
    palette=['rgb(40,40,40)', 'rgb(204,36,29)', 'rgb(152,151,26)', 'rgb(184,187,38)', 'rgb(69,133,136)', 'rgb(177,98,134)', 'rgb(104,157,106)', 'rgb(168,153,132)', 'rgb(146,131,116)', 'rgb(251,73,52)', 'rgb(184,187,38)', 'rgb(250,189,47)', 'rgb(131,165,152)', 'rgb(211,134,155)', 'rgb(142,192,124)', 'rgb(235,219,178)']
    scroll-on-output=true
    use-system-font=true
    use-theme-colors=false
    scrollback-unlimited=false
    background-color='rgb(40,40,40)'
    audible-bell=false
  #+end_src

* git

  Git Configuration

** .gitconfig
   :PROPERTIES:
   :header-args: :tangle ~/.gitconfig
   :END:

*** Author

  Configure information used by git to determine how to write the
  author information for commits

  #+begin_src conf
    [user]
      name = Aaron Kuehler
      email = aaron.kuehler@gmail.com
      signingkey = 9E3E4C59E2694215
  #+end_src

*** Github Credentials

    Include credentials for CLI authentication with the github gist
    API

    #+begin_src conf
      [include]
        path = ~/credentials/.github
    #+end_src


*** Core configuration

  In addition to any files included in a project's =.gitignore= file,
  also include those listed in the =~/.gitconfig.=

  Use Emacs as the commit editor

  #+begin_src conf
    [core]
      excludesfile = ~/.gitignore
      editor = emacs -nw --eval '(global-git-commit-mode t)'
  #+end_src


*** Colors

  Enable coloring of git output

  #+begin_src conf
    [color]
      ui = true
  #+end_src


*** Aliases

  Set aliases for frequently used git incantations.

  #+begin_src conf
    [alias]
      co  = checkout
      cb  = checkout -b
      db  = branch -d
      rclone = clone --recursive
  #+end_src


*** Commit

  GPG Sign commits

  #+begin_src conf
    [commit]
      gpgsign = true
  #+end_src

*** Clean

  Disable the safeguard flag when running =git clean=

  #+begin_src conf
    [clean]
      requireForce = false
  #+end_src


*** Push

  Only push the current branch, rather than all
  branches, when =git push= is invoked.

  #+begin_src conf
    [push]
      default = simple
  #+end_src


*** Filter

  #+begin_src conf
    [filter "lfs"]
      clean = git-lfs clean %f
      smudge = git-lfs smudge %f
      required = true
  #+end_src

** .gitignore
   :PROPERTIES:
   :header-args: :tangle ~/.gitignore
   :END:

*** Mac OS Finder cache

  Never ever store Mac OS Finder metadata in a git repository.

  #+begin_src text
    .DS_Store
  #+end_src


*** Emacs temp files

  Never store Emacs autosave and backup files in a git repository.

  #+begin_src text
    ,*~
    .#*
    ,*#
  #+end_src

** tab completion

  Enable tab completion for the git.

  #+begin_src sh
    GIT_TAB_COMPLETION_FILE=/usr/local/etc/bash_completion.d/git-completion.bash
    if [ -f $GIT_TAB_COMPLETION_FILE ];
       then source $GIT_TAB_COMPLETION_FILE
    fi
  #+end_src

* gem

  Ruby gems configuration

** Documentation

  When a gem is installed forego the generation of its documentation.

  #+begin_src text :tangle ~/.gemrc
    gem: --no-document
  #+end_src

* Rspec
  :PROPERTIES:
  :header-args: :tangle ~/.rspec
  :END:

  rspec CLI configuration

** Color

  Enable colorized output

  #+begin_src text
    --color
  #+end_src

** Output format

  Output from spec runs should look like a progress bar

  #+begin_src text
    --format progress
  #+end_src

** Ordering

  Always run specs in a random order to ensure that examples are
  independent of one another.

  #+begin_src text
    --order random
  #+end_src

* Scripts
  :PROPERTIES:
  :header-args: :mkdirp yes
  :END:

  Version controlled scripts used to automate various repetitive tasks

** Flush DNS cache

   Invalidates the local DNS cache:

*** Usage

   #+begin_src sh
     $ flush_dns
   #+end_src

*** Source

    #+begin_src sh :tangle ~/bin/flush_dns :shebang "#!/bin/bash"
      # Purpose:
      #   Flush the local DNS cache
      # Usage:
      #   $ flush_dns_cache

      if [[ `uname` == "Darwin" ]]; then
          sudo killall -HUP mDNSResponder
      fi
    #+end_src

** Refresh local git tags

   Ensures that a local git repository's tags are in sync with the
   remote origin

*** Usage

   #+begin_src sh
     $ refresh_tags
   #+end_src

*** Source

   #+begin_src sh :tangle ~/bin/refresh_tags :shebang "#!/bin/bash"
     # Purpose:
     #   Delete all local tags and refresh from origin
     # Usage:
     #   $ refresh_tags

     git tag -l | xargs git tag -d && git fetch
   #+end_src

** Emacs Lisp Testing

   Runs an elisp test

*** Usage

    #+begin_src sh
      $ ert-run <path-to-test>.el
    #+end_src

*** Source

   #+begin_src sh :tangle ~/bin/ert-run :shebang "#!/bin/bash"
     # Purpose:
     #   Runs an elisp test
     # Usage:
     #  $ ert-run <path-to-test>.el

     emacs -batch -l ert -l $1 -f ert-run-tests-batch-and-exit
   #+end_src
* ssh
  :PROPERTIES:
  :header-args: :mkdirp yes
  :END:

  Automatically load the private key into the ssh-agent and store
  passwords in the keychain on OS X hosts.

  #+begin_src text :tangle (when (eq system-type 'darwin) "~/.ssh/config")
    Host *
     AddKeysToAgent yes
     UseKeychain yes
  #+end_src

* setup

   Generates the =.files/setup.sh= script used to bootstrap new system
   with the tools and configuration I use across hosts.

** Common Packages

   Define and install basic packages required to build and install software

   #+begin_src sh :tangle "~/.files/setup.sh"
     PACKAGES="aspell automake autoconf bash emacs git libtool unzip curl bash-completion"
   #+end_src

** macOS Packages

   macOS has a surprising lack of "package management
   system". Homebrew is the closest thing, but has a few functional
   deficiencies. Nonetheless, in most cases it's better than nothing
   so we ensure that it exists on macOS hosts here.

   #+begin_src sh :tangle (when (eq system-type 'darwin) "~/.files/setup.sh")
     if ! [ -x "$(command -v brew)" ]; then
       ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
     fi
     brew update
     brew tap homebrew/cask-versions
   #+end_src

*** Additional macOS Packages

   On macOS, ensure that these programs are present. Generally they're
   required to build or support the tools I use to produce software.

   #+begin_src sh :tangle (when (eq system-type 'darwin) "~/.files/setup.sh")
     PACKAGES="$PACKAGES ncurses openssl readline the_silver_searcher"
   #+end_src

*** macOS Binary Packages

    On macOS clients, also ensure that the following binary
    applications are available for use.

   #+begin_src sh :tangle "~/.files/setup.sh"
     BINARY_PACKAGES="emacs docker firefox-developer-edition iterm2 keepassxc keybase mactex nextcloud signal skitch slack spectacle"
   #+end_src

*** macOS update =GNU bash=

   Apple seems to hate the idea of [[https://www.fsf.org/][Free Software]] and has refused to
   update the =bash= shell in macOS for quite some time - [[https://support.apple.com/en-ca/HT208050?fbclid=IwAR0Z1-TK9h3oInv_byv9fDa9EbxxxZoqSaI4Osfq5_fxDi7jXvKjS3YAKvk][in fact
   they've gone so far as switching the user's default shell to zsh,
   and added an annoying depreciation warning when using bash in their
   latest OS update]]... LOLWAT? Here we'll use Homebrew to install a
   recent version of =GNU bash= and make sure it's our user's default
   shell.

   #+begin_src sh :tangle (when (eq system-type 'darwin) "~/.files/setup.sh")
     if [ -z $(grep /usr/local/bin/bash /etc/shells) ]
     then
         sudo bash -c "echo /usr/local/bin/bash >> /etc/shells"
     fi

     chsh -s /usr/local/bin/bash
   #+end_src

** GNU/Linux Packages

   On GNU/Linux hosts, ensure that the following packages are present.

   #+begin_src sh
     PACKAGES="$PACKAGES aspell git silversearcher-ag"
   #+end_src

** Install Packages

   And now we're ready to ensure that each of the packages are
   installed. On macOS hosts, we use Homebrew to install packages.

   #+begin_src sh :tangle (when (eq system-type 'darwin) "~/.files/setup.sh")
     for package in $PACKAGES; do
         if [ "$( brew list -1 | grep $package )" == "" ]; then
           echo "installing $package"
           brew install $package
         else
             echo "$package installed"
         fi
     done

     for package in $BINARY_PACKAGES; do
         if [ "$( brew cask list -1 | grep $package )" == "" ]; then
           echo "installing $package"
           brew cask install $package
         else
             echo "$package installed"
         fi
     done
   #+end_src

   And on GNU/Linux hosts - for which I always use Debian GNU/Linux -
   we'll use the Aptitude Package Manager.

   #+begin_src sh :tangle (when (eq system-type 'gnu/linux) "~/.files/setup.sh")
     for package in $PACKAGES; do
         if [ "$(sudo apt-cache policy $package | grep 'Installed: (none)')" ]
         then
             sudo apt install -y $package
         else
             echo "$package is already installed";
         fi
     done
   #+end_src

** Install asdf

   I use [[https://asdf-vm.com/#/][asdf - the extensible version manager]] to manage the tooling
   and runtimes in which I typically write software.

   #+begin_src sh :tangle "~/.files/setup.sh"
     ASDF_DIR=$HOME/.asdf
     if [ -e $ASDF_DIR ]; then
       echo "Updating $ASDF_DIR"
       asdf update
     else
       echo "Installing ASDF"
       git clone https://github.com/asdf-vm/asdf.git $ASDF_DIR
       cd $ASDF_DIR
       git checkout "$(git describe --abbrev=0 --tags)"
     fi
   #+end_src

   Now that asdf-vm is in place, install the language specific plugins I typically use.

   #+begin_src sh :tangle "~/.files/setup.sh"
     ASDF_PLUGINS='ruby nodejs'
     for plugin in $ASDF_PLUGINS; do
       if [ -e $ASDF_DIR/plugins/$plugin ]; then
         echo "asdf $plugin plugin already installed"
         asdf plugin-update $plugin
       else
         echo "installing asdf $plugin plugin"
         asdf plugin-add $plugin
       fi
     done
   #+end_src

** Install Docker

   Ensures that docker is installed. On Mac OS X hosts, we use
   [[https://brew.sh/][Homebrew]] to install Docker:

   #+begin_src sh :tangle (when (eq system-type 'darwin) "~/.files/setup.sh")
     if [ $(which docker) ]; then
       echo "docker is already installed"
     else
       brew cask install docker
     fi
   #+end_src

   While on GNU/Linux hosts, we assume we're using my favorite distro -
   Debian - and use the [[https://wiki.debian.org/Aptitude][Aptitude Package Manager]] to install Docker.

   #+begin_src sh :tangle (when (eq system-type 'gnu/linux) "~/.files/setup.sh")
     if [ $(which docker) ]
     then
         echo "docker is already installed"
     else
         echo "installing docker"
         sudo apt-get remove docker docker-engine docker.io containerd runc
         sudo apt-get update
         sudo apt-get install \
              apt-transport-https \
              ca-certificates \
              curl \
              gnupg2 \
              software-properties-common

         curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
         sudo add-apt-repository \
              "deb [arch=amd64] https://download.docker.com/linux/debian \
                 $(lsb_release -cs) \
                 stable"
         sudo apt-get update
         sudo apt install -y docker-ce docker-ce-cli containerd.io
         sudo groupadd docker
         sudo usermod -aG docker $USER
         newgrp docker
     fi
   #+end_src

** Install docker-compose

  Ensures that docker-compose is installed and ready to use. On Mac OS
  X this comes bundled in the Homebrew cask version of Docker, so
  there's nothing for us to do. However on GNU/Linux hosts we need to
  do some additional steps to get everything up and running.

  #+begin_src sh :tangle (when (eq system-type 'gnu/linux) "~/.files/setup.sh")
    sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    sudo chmod +x /usr/local/bin/docker-compose
    sudo curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose
  #+end_src

* Librem hardware fixes

** Keyboard

   The purism keyboard screws up the pipe key, it outputs a right
   angle bracket. This bit corrects the output of that key
   specifically. Add this to
   =/etc/udev/hwdb.d/90-purism-pipe-symbol-fix.hwdb=.
   #+begin_src conf
     evdev:atkbd:dmi:bvn*:bvr*:bd*:svnPurism:pnLibrem13v2*
      KEYBOARD_KEY_56=backslash
   #+end_src

   Afterward run:

   #+begin_src sh
     sudo systemd-hwdb update
     sudo udevadm trigger
   #+end_src

   For reference: https://forums.puri.sm/t/keyboard-layout-unable-to-recognize-pipe/2022/10
