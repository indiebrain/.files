#+TITLE: Dotfiles Configuration

Shell and CLI Tooling configuration

* GNU Stow Packages

The following sections generate the contents of a collection of GNU Stow
packages. GNU Stow then places the packages onto the host file system
using symlinks. The goal is to keep the configuration isolated from the
rest of the file system and provide a simple mechanism for
(de)activating particular parts of the configuration.

** The Bourne Again Shell (Bash)

Some shells are considered more modern, or fashionable, but the =bash=
shell is ubiquitous, mature, simple enough, and powerful.

A [[https://devhints.io/bash][quick reference]] should be enough for most to get started with Bash
scripting, but for a more in depth look at Bash see the [[https://www.gnu.org/software/bash/manual/][GNU reference
manuals]].

This section contains [[https://www.gnu.org/software/bash/manual/bash.html#Bash-Startup-Files][startup file configuration]] for Bash. The
configuration loaded by Bash depends on the type of shell requested.

*** Interactive Shells

An interactive shell is one in which a user is expected to provide input
commands sequentially - a terminal session, for example.

#+begin_quote
An interactive shell is one started without non-option arguments, unless
-s is specified, without specifying the -c option, and whose input and
error output are both connected to terminals (as determined by
isatty(3)), or one started with the -i option.

An interactive shell generally reads from and writes to a user’s terminal.

The -s invocation option may be used to set the positional parameters
when an interactive shell is started.
#+end_quote

#+begin_quote
When Bash is invoked as an interactive login shell, or as a
non-interactive shell with the --login option, it first reads and
executes commands from the file /etc/profile, if that file exists. After
reading that file, it looks for ~/.bash_profile, ~/.bash_login, and
~/.profile, in that order, and reads and executes commands from the
first one that exists and is readable. The --noprofile option may be
used when the shell is started to inhibit this behavior.

When an interactive login shell exits, or a non-interactive login shell
executes the exit builtin command, Bash reads and executes commands from
the file ~/.bash_logout, if it exists.
#+end_quote

*** Non-interactive Shells

A non-interactive shell might be launched by another program - a shell
script with a =#!/usr/bin/env bash= SHEBANG line, for example.

*** Configuration for non-login shells
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./bash/.bashrc
:END:

When a Bash shell is started as a non-login shell, it reads and executes
the =.bashrc= located in the user's =$HOME= directory.

#+begin_quote
When an interactive shell that is not a login shell is started, Bash
reads and executes commands from ~/.bashrc, if that file exists. This
may be inhibited by using the --norc option. The --rcfile file option
will force Bash to read and execute commands from file instead of
~/.bashrc.
#+end_quote

Typically one might find configuration which affects the function of
Bash here - modifications to the file system paths on which Bash looks
for programs, libraries, etc.

**** $PATH

This section configures the lookup =$PATH=. This is =:= separated list of
paths on the file system in which Bash will lookup commands and
libraries. This configuration changes the default lookup path of a
system in the following ways:

- items stored in the =$HOME/bin= are appended to the path. This gives the
  user a place to put scripts and libraries they with to use in their
  home directory and they'll be available for lookup in the path. This
  path is appended to avoid shadowing system binaries and libraries.
- items stored in =/usr/local/bin= and =/usr/local/sbin= are given
  precedence over those stored elsewhere on the file system. For
  example, if a program =wumpus= were present in both =/bin= and
  =/usr/local/bin=, the latter version would be invoked when =wumpus= is
  invoked.

#+begin_src sh
export PATH="/usr/local/bin:/usr/local/sbin:$PATH"
export PATH="$HOME/bin:$PATH"
#+end_src

**** Initialize the asdf runtime version manager

asdf is a CLI tool that can manage multiple language runtime version on a
per-project bases. It's like =gvm=, =nvm=, =rbenv=, =pyenv=, et al. all rolled
into one simple user interface. It is extendable via plugins and can
managed a wide variety of runtimes and tools.

This section runs the asdf system initialization, and adds bash
completions into the shell.

#+begin_src sh
[ -f $HOME/.asdf/asdf.sh ] && source $HOME/.asdf/asdf.sh
[ -f $HOME/.asdf/completions/asdf.bash ] && source $HOME/.asdf/completions/asdf.bash
#+end_src

**** Globally disable the spring application prelaoder

The =spring= ruby gem is an application preloader. It aims to increase
developer productivity by reducing the amount of time spent waiting for
a Rails application to boot. However, in my experience its shortcomings
with regard to handling code reloading leads to tricky-to-debug
situations where the version of the application running in memory might
not necessarily represent the application described by the code-on-disk.

This setting attempts to avoid tricky head-scratching sessions by
disabling =spring= globally.

#+begin_src sh
DISABLE_SPRING=1
#+end_src

**** Departure

The =departure= ruby gem wraps the Percona Toolkit Online Schema Change
(pt-osc). Since MySQL does not apply Data Description Language
statements - IE schema migrations - within the scope of a transaction,
it's entirely possible that adding or removing a column irrevocably
corrupts a database. The departure gem tends to get in the way when
working locally, so this configuration disables it, skipping protections
from broken schema migrations locally.

#+begin_src sh
export DISABLE_DEPARTURE=1
#+end_src

**** Overcommit

The overcommit ruby gem installs and runs git pre-commit hooks which
check thing like:

1. are the application dependnecies up to date?
2. are there any database migrations which aren't present in the schema
   definition?

These hooks are run on every commit. This sounds like a wonderfully
useful tool, however in practice this make the process of creating a git
commit take at least 10 seconds while ruby loads and executes the hooks.
This is untenable and discourages frequent commits. What's more the
overcommit gem does not play well with non-cli git tools - such as the
Magit emacs package. This configuration globally disables the overcommit
gem.

#+begin_src sh
export OVERCOMMIT_DISABLE=1
#+end_src

**** Change the home directory of golang code

I prefer to keep my source code isolated in the =$HOME/Developer=
directory. By default golang will install source code in =$HOME/go=. This
configuration instructs =go= that its new home is =$HOME/Developer=.

#+begin_src sh
export GOPATH=$HOME/Developer/go
export PATH=$PATH:$GOPATH/bin
#+end_src
**** Ensure Power HRG application dependencies take precedence on the =$PATH=

This section configures specific versions libraries to be found on the
path before others. This is primarily present in this configuration to
assist with the development setup of my current employer.

#+begin_src sh
export PATH="/usr/local/opt/openssl@1.1/bin:$PATH"
export PATH="/usr/local/opt/mysql-client@5.7/bin:$PATH"
export PATH="/usr/local/opt/postgresql@11/bin:$PATH"
#+end_src

**** Disable Homebrew telemetry tracking

Homebrew client captures metrics about its host and usage. No, sir; do not want.

#+begin_src sh
export HOMEBREW_NO_ANALYTICS=1
#+end_src

*** Configuration for login shells
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./bash/.bash_profile
:END:

Login shells loads the =.bash_profile= when created; typically via a
terminal, or Secure Shell (SSH) connection.

#+begin_quote
When Bash is invoked as an interactive login shell, or as a
non-interactive shell with the --login option, it first reads and
executes commands from the file /etc/profile, if that file exists. After
reading that file, it looks for ~/.bash_profile, ~/.bash_login, and
~/.profile, in that order, and reads and executes commands from the
first one that exists and is readable. The --noprofile option may be
used when the shell is started to inhibit this behavior.

When an interactive login shell exits, or a non-interactive login shell
executes the exit builtin command, Bash reads and executes commands from
the file ~/.bash_logout, if it exists.
#+end_quote

First, we load any configuration for the Bash's predecesor; the Bourne
Shell. Then we load the non-login shell configuration for Bash. Finally
we run any login-specific tasks before we finally start to load the Bash
login configuration. If any of the above configuration files are not
present or not readable they're skipped. This is an attempt to offer
the most backward compatibility while not sacrificing portability.

#+begin_src sh
[ -r ~/.profile ] && . ~/.profile || true              # If a Bourne shell configuration exists, load it
if [ -n "$PS1" ]                                         # Is this REALLY an interactive shell?
then
    [ -r ~/.bashrc ] && . ~/.bashrc || true            # tty/prompt/function setup for interactive shells
    [ -r ~/.bash_login ] && . ~/.bash_login || true    # any at-login tasks for login shell only
fi
#+end_src

**** Command output colors

***** macOS

Some UNIX-like operating systems support a global configuration option
which instructs commands to use ANSI Color control sequences in their
output. Setting the =CLICOLOR= environment variable enables this on such
systems. macOS is one such UNIX-like operating system which supports
this global colorizing configuration.

#+begin_src sh :tangle (when (eq system-type 'darwin) "./bash/.bash_profile")
export CLICOLOR=1
#+end_src

***** Debian GNU/Linux

Some systems which do NOT honor this global switch for output coloring
DO tend to provide command level flags to colorize their output. These
next bits provide aliases of standard commands to their colorized
counterparts.

This configuration has the following effects:

- =ls= will make different inode types visually distinct from one another.
  Directories, files, symlinks, etc will visually distinguish themselves
  from one another.
- =grep= will highlight matches in its output.

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./bash/.bash_profile")
alias ls='ls --color'
alias grep='grep --color'
#+end_src

**** Aliases

Bash supports creating a custom alias to a command string. When used as
the first word of a simple command an alias expands to its command
string. There are rules concerning the definition and use of aliases,
[[https://www.gnu.org/software/bash/manual/bash.html#Aliases][please see the Bash reference manual's topic on Aliases for more
details]]. The aliases defined herein provide shorthand notation to
frequently run or often forgotten, but useful, commands.

#+begin_src sh
alias gs="git status"
alias gl='git log --graph --oneline --decorate --max-count 10'
#+end_src

On Debian GNU/Linux hosts, adds a shorthand to copy data to the system
clipboard from the terminal.

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./bash/.bash_profile")
alias pbcopy='xclip -selection clipboard'
#+end_src

**** Bash Completion

The Bash Completion extension shows a list of possible completions when
the user types a partial completion candidate followed by the <TAB> key
twice. This is helpful in narrowing down potential commands and
arguments. For example =ls<TAB><TAB>= may expand and show the following
commands as potential completions:

#+begin_example
root@3acfddd4f63d:/# ls
ls
lsattr
lsblk
lscpu
lsipc
lslocks
lslogins
lsmem
lsnsls
lsattr
lsblk
lscpu
lsipc
lslocks
lslogins
lsmem
lsns
#+end_example

On macOS hosts, Homebrew may provide the bash-completion package and
we'll load completions according to its conventions - see =brew info
bash-completion= for more details.

#+begin_src sh :tangle (when (eq system-type 'darwin) "./bash/.bash_profile")
[[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] && \
    source "/usr/local/etc/profile.d/bash_completion.sh"
#+end_src

However, on GNU/Linux hosts - IE Debian hosts, we'll use [[https://github.com/scop/bash-completion#installation][the official
means of loading bash-completion completions]].

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./bash/.bash_profile")
[[ $PS1 && -f /usr/share/bash-completion/bash_completion ]] && \
    source /usr/share/bash-completion/bash_completion
#+end_src

**** Editor

Some commands will open a text editor to complete their action - =git
commit=, for example. Bash will execute the command stored in the =EDITOR=
environment variable to launch a text editor in these cases. This makes
sure that =emacs= is the preferred text editor.

#+begin_src sh
export EDITOR="emacs"
#+end_src
**** History

Bash has the capabilities keep track of the commands entered into
interactive shells. History is searchable and executable. The [[https://www.digitalocean.com/community/tutorials/how-to-use-bash-history-commands-and-expansions-on-a-linux-vps][How To Use
Bash History Commands and Expansions on a Linux VPS]] guide and
[[https://metaredux.com/posts/2020/07/07/supercharge-your-bash-history.html][Supercharge Your Bash History]] articles are primary sources for the
following configuration. The configuration below achieves the following
goals:

- Each command appends itself to the history on entry. By default, bash
  writes its history at the end of each session, overwriting the
  existing file with an updated version. This means that if there are
  multiple bash sessions only the last one to exit will have its history
  saved.
- Entering a command will automatically append itself and reload the
  history. To do this correctly, we need to do a bit of a hack. We need
  to append to the history file immediately with =history -a= and reload
  new entries from the history file via =history -n=.
- Store only unique commands in bash history. Don't store multiple
  instances of =ls= for example. The =HISTCONTROL=
  =erasedups= configuration value controls this.
- Prefixing a command with a white space character excludes it from the
  history. The =HISTCONTROL= =ignoreboth= configuration value controls this.
- The Bash defaults on the number of items and size of the history are
  limited - they harken back to days when storage was more
  expensive. This sets a reasonably large cap on the number of items to
  keep in history via the =HISTSIZE= and =HISTFILESIZE= environment
  variables.
- Provides a blacklist of commands which should never appear in the
  history via =HISTIGNORE=. Typically having history entries for the
  following commands in the bash history either accounts for clutter and
  removes or obscures the more meaningful history entries. Therefore, we
  prevent creating history entries for the following commands.

#+begin_src sh
shopt -s histappend
export PROMPT_COMMAND="history -a; history -n; $PROMPT_COMMAND"
export HISTCONTROL=ignoreboth:erasedups
export HISTSIZE=100000
export HISTFILESIZE=10000000
export HISTIGNORE='bg:cd:clear:exit:fg:ll:ls:pwd:history'
#+end_src

**** Prompt

This section configures the shape and coloring of the Bash prompt. Below
is an example of what this prompt looks like:

#+begin_example
[maximilian: .files] organize-configuration-for-gnu-stow-management(+1) *+ →
$ ls
#+end_example

Some notable features:

- The prompt will colorize its components when the terminal supports
  colors.
- When the terminal supports colors, the =$= character will indicate the
  =exit= code status of the last run command - green for =exit 0= (success),
  and red for a non zero exit code.
- When the current working directory is a git directory
  - show the current git branch.
  - show a count of the number of commits deviation from the base and/or
    remote branch directly after the branch name.
  - show status indicators to the right of the commit deviation metrics.
    =*= indicates un-staged changes in the working directory exist. =+= indicates
    staged, but uncommitted changes exist in the index. =^=
    indicates the stash queue is not empty.

#+begin_src sh
# Get a graphical representation of the clean/dirty state of a git repository
# colors
case "$TERM" in
    xterm*|rxvt*|screen*|eterm-color)
        ESC="\033"
        RED="\[$ESC[01;31m\]"
        LIGHT_RED="\[$ESC[1;31m\]"
        GREEN="\[$ESC[01;32m\]"
        LIGHT_GREEN="\[$ESC[1;32m\]"
        GREY="\[$ESC[0;37m\]"
        CYAN="\[$ESC[01;36m\]"
        YELLOW="\[$ESC[0;33m\]"
        LIGHT_VIOLET="\[$ESC[1;35m\]"
        RESET="\[$ESC[0m\]"
        ;;
    ,*)
        ESC=""
        RED=""
        LIGHT_RED=""
        GREEN=""
        LIGHT_GREEN=""
        GREY=""
        CYAN=""
        YELLOW=""
        LIGHT_VIOLET=""
        RESET=""
        ;;
esac

# prints path to git directory
__git_dirname() {
    local dirname
    if [ -d .git ]; then
        dirname=".git"
    else
        dirname="$(git rev-parse --git-dir 2>/dev/null)"
    fi
    echo "$dirname"
}

# gets the branching state of the repository
# optional arg: path to git directory
__git_branching_state() {
    local gitdir="$1" || "$(__git_dirname)"
    local state

    if [ -f "$gitdir/rebase-merge/interactive" ]; then
        state="rebase-i"
    elif [ -d "$gitdir/rebase-merge" ]; then
        state="rebase-m"
    else
        if [ -d "$gitdir/rebase-apply" ]; then
            if [ -f "$gitdir/rebase-apply/rebasing" ]; then
                state="rebase"
            elif [ -f "$gitdir/rebase-apply/applying" ]; then
                state="am"
            else
                state="am/r"
            fi
        elif [ -f "$gitdir/MERGE_HEAD" ]; then
            state="merge" # merging
        elif [ -f "$gitdir/BISECT_LOG" ]; then
            state="bisect" # bisecting
        fi
    fi
    echo "$state"
}

# prints the working directory state of the repository using symbols
# these could be expensive.. would make sense to have configs to turn off
# * - modified / + - staged / ^ - stashed / % - untracked
__git_working_dir_symbols() {
    local symbols

    # in working dir
    if [ true = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
        git diff --no-ext-diff --quiet --exit-code || symbols="*"
        if git rev-parse --quiet --verify HEAD >/dev/null; then
            git diff-index --cached --quiet HEAD -- || symbols="${symbols}+"
        fi
    fi

    # stashed
    git rev-parse --verify refs/stash >/dev/null 2>&1 && symbols="${symbols}^"

    # untracked files
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        symbols="${symbols}%"
    fi
    echo "$symbols"
}

# prints current / parent branch name
# optional arg: 'parent' -- returns a limited guess of the parent
# optional arg: path to git directory
__git_branch_name() {
    # current branch name
    local branch
    local gitdir="$2" || "$(__git_dirname)"
    branch="$(git symbolic-ref HEAD 2>/dev/null)" || {
        branch="$(git describe --contains --all HEAD 2>/dev/null)" ||
            branch="$(cut -c1-7 "$gitdir/HEAD" 2>/dev/null)..." ||
            branch="unknown"

        branch="${branch##remotes/}"
        branch="($branch)"
    }
    branch="${branch##refs/heads/}"

    # parent branch name
    if [ parent = "$1" ]; then
        if [ master = "$branch" ]; then
            local refs="$(git for-each-ref --format="%(refname:short)")"
            case "$refs" in
                ,*git-svn*) # git-svn repo
                    branch='git-svn' ;;
                ,*origin*) # remote clone
                    branch='origin' ;;
                ,*)
                    branch='HEAD' ;; # same repo
            esac
        else
            # TODO.. would be nice to improve this to determine the actual
            # merge base (git merge-base) and compare against that instead of
            # always assuming master. In this way a 'topic/feature' branch
            # would show the diff counts for its parent 'next/develop' branch
            # rather than those plus those on the 'next/develop' branch.
            # I don't think we want to loop over the refs comparing ... that's
            # fuzzy.
            branch='master' # on a branch
        fi
    fi
    echo "$branch"
}

# prints if inside git directory or bare git repository
__git_in_gitdir() {
    if [ true = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
        if [ true = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
            echo 'bare'
        else
            echo 'gitdir'
        fi
    fi
}

# prints number of commits that are available on ref B but not ref A
# arg1: reference A
# arg2: reference B
__git_commit_diff_count() {
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}

# build combined (+/-) counts for related commits
__git_count_str() {
    local str
    local parent="$(__git_branch_name parent)"
    local ahead_count="$(__git_commit_diff_count $parent HEAD)"
    local behind_count="$(__git_commit_diff_count HEAD $parent)"

    if [ 0 -lt "$ahead_count" ]; then
        str="${GREEN}+${ahead_count}${RESET}"
    fi

    if [ 0 -lt "$behind_count" ]; then
        [ -n "$str" ] && str="$str/"
        str="${str}${LIGHT_RED}-${behind_count}${RESET}"
    fi

    [ -n "$str" ] && str="($str)"
    echo "$str"
}

# install git integration into PS1
__git_prompt() {
    local last_exit="$?" # keep here.. so we get the last command

    # setup PS1
    local host="${LIGHT_GREEN}\h:${RESET}"
    local dir="${YELLOW}\W${RESET}"
    PS1="[$host $dir]"

    # when in git repository
    local gitdir="$(__git_dirname)"
    if [ -n "$gitdir" ]; then
        local branch
        local extras

        local in_gitdir="$(__git_in_gitdir)"
        case "$in_gitdir" in
            gitdir|bare)
                branch="~$(echo $in_gitdir | tr "[:lower:]" "[:upper:]")~"
                extras=""
                ;;
            ,*)
                local branch="$(__git_branch_name current ${gitdir})"
                local br_state="$(__git_branching_state $gitdir)"

                # rebasing..use merge head for branch name
                case "$br_state" in
                    rebase-*)
                        # get the ref head during rebase
                        branch="$(cat "$gitdir/rebase-merge/head-name")"
                        branch="${branch##refs/heads/}"
                        branch="${branch##remotes/}"
                        ;;
                esac

                # extras (count strings, working dir symbols)
                local countstr="$(__git_count_str)"
                local wd_syms="${LIGHT_VIOLET}$(__git_working_dir_symbols)${RESET}"
                extras="${countstr} ${wd_syms}"
                ;;
        esac
        branch="${GREY}${branch}${RESET}"

        # update PS1
        PS1="${PS1} ${branch}${extras}"
    fi

    # setup marker that acts off of last exit code
    local marker
    if [ 0 -eq "$last_exit" ]; then
        marker="$GREEN"
    else
        marker="$RED"
    fi
    marker="${marker}\$${RESET}"
    PS1="\n${PS1} →\n${marker} "
}
PROMPT_COMMAND=__git_prompt
#+end_src
** ASDF Version manager

*** Global configuration
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./asdf/.asdfrc
:END:

This file is ready during =asdf='s initialization it provides instance
wide configuration for the =asdf= program itself.

Each language's version manager communities seem to have come to
different conclusions on how to represent "required versions". The
=legacy_version_file= setting here tells =asdf= to allow the language
specific plugin to attempt to use the language's version manager
community's default file for specifying a version - for example the =asdf=
Ruby plugin will look in =.ruby_version= first for Ruby version
declarations as well as =.tool-versions=.

#+begin_src conf
legacy_version_file = yes
#+end_src

*** Plugin specific configuration

ASDF is a framework for managing multiple runtime version through a
single CLI tool. ASDF Plugins provide functionality for managing
specific runtimes. This section contains configurations for specific
plugins.

**** Ruby

***** Default gems
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./asdf/.default-gems
:END:

The Ruby plugin provides a way to ensure that a baseline set of gems
exists after installing a new Ruby. Listing the names of the gems in a
file in the user's =$HOME/.default-gems= makes this possible. The
following list describes this file's contents.

#+begin_src text
bundler
pry
rcodetools
#+end_src

** Gnome terminal
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./terminal/.gruvbox-profile.dconf
:END:

This is my gnome-terminal configuration. This configuration generates
=~/.gruvbox-profile.dconf=. At some point I'll automate the installation,
but for now to import the profile:

   1. Open gnome-terminal
   2. Create a new profile
   3. Take node of the UUID of the Profile
   4. Import the profile settings into the new profile
      =cat ~/.gruvbox-profile.dconf | dconf load /org/gnome/terminal/legacy/profiles:/:<profile-uuid-here>/=

      #+begin_src text
[/]
foreground-color='rgb(235,219,178)'
visible-name='Gruvbox'
palette=['rgb(40,40,40)', 'rgb(204,36,29)', 'rgb(152,151,26)', 'rgb(184,187,38)', 'rgb(69,133,136)', 'rgb(177,98,134)', 'rgb(104,157,106)', 'rgb(168,153,132)', 'rgb(146,131,116)', 'rgb(251,73,52)', 'rgb(184,187,38)', 'rgb(250,189,47)', 'rgb(131,165,152)', 'rgb(211,134,155)', 'rgb(142,192,124)', 'rgb(235,219,178)']
scroll-on-output=true
use-system-font=true
use-theme-colors=false
scrollback-unlimited=false
background-color='rgb(40,40,40)'
audible-bell=false
      #+end_src

** Git version control system

This section configures the =git= version control system.

*** Basic configuration
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./git/.gitconfig
:END:

This section provides the core configuration of the =git= version control
system. The following contains configuration which:

- instructs git how to write the author information for commits.
- references a global / host gitignore file.
- prints colorized output for git commands like =status=, and =diff=.
- defines aliases, or shorthand, for frequently used, or often forgotten
  git incantations.
- signs every commit with my GnuPG key to verify the authenticity of
  such commits to other parties.
- configures the =git clean= command to be less intrusive - IE drop the
  "Are you sure?" charade.
- only pushe the current branch when running =git push=;rather than
  pushing all refs in the local repository.
- prevents =git= from eagerly fetching the tags from the =origin= remote.
  This is useful for improving the responsiveness of large repositories
  with lots of tags, and the user may manually download them later if
  they so choose.
- performs a =--prune= operation on each fetch from the =origin= remote.
  Again, this is useful for large repositories where the =origin= may
  contain refs which I'll never need to reference. When removed
  from the remote, these branches are automatically removed from the
  local object database as well.

#+begin_src conf
[user]
name = Aaron Kuehler
email = aaron.kuehler@gmail.com
signingkey = 9E3E4C59E2694215

[core]
excludesfile = ~/.gitignore_global

[color]
ui = true

[alias]
co  = checkout
cb  = checkout -b
db  = branch -d
rclone = clone --recursive

[commit]
gpgsign = true

[clean]
requireForce = false

[push]
default = simple

[remote "origin"]
tagOpt = --no-tags
prune = true
#+end_src

*** Global ignore file
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./git/.gitignore_global
:END:

This configures the global list of files and patterns that git should
ignore. This typically contains items which are specific to the local
environment or workflow which should never exist in a git repository,
but would be inappropriate to include in the project's =.gitignore=.
Example include, artifacts left behind by local editors, tools,
operating system file managers, etc. which may not be common across
contributors.

The following ignores:

- artifacts left behind by the macOS Finder
- Emacs autosave and backup files

#+begin_src text
.DS_Store

,*~
.#*
,*#
#+end_src

** Ruby Programming Languae
*** Rspec
:PROPERTIES:
:header-args: :mkdirp yes :tangle ./ruby/.rspec
:END:

This section specifies system-wide configuration for RSpec - The Ruby Behavior
Driven Development tool. This ensures that:

- example and specification output should use the terminal control
  characters to colorize output. This provides rich visual feedback of
  the success, failure, or omitted status of examples in the RSpec
  suite.
- RSpec should use the "progress" output format. This displays a series
  of =.=, =F=, and =S= characters to indicate the output status of individual
  examples. These characters indicate a success, failure, or "skip"
  respectively.
- examples run in order according to the =--seed= of the runner. By
  default, rspec uses a random seed for each run, but the order of a
  specific run is reproducable by passing its =--seed= to the =rspec=
  command. This is helpful for surfacing dependencies between example,
  leaked / persistent state, etc between sequential runs of
  specifications.


#+begin_src text
--color
--format progress
--order random
#+end_src

** Secure Shell (SSH)

Automatically load the private key into the ssh-agent and store
passwords in the keychain on OS X hosts.

#+begin_src text :mkdirp yes :tangle (when (eq system-type 'darwin) "./ssh/.ssh/config")
Host *
AddKeysToAgent yes
UseKeychain yes
#+end_src

** Utility Scripts
:PROPERTIES:
:header-args: :mkdirp yes :tangle-mode (identity #o755) :shebang "#!/usr/bin/env bash"
:END:

Version controlled scripts used to automate repetitive tasks.

*** Flush DNS cache

Invalidates the local DNS cache:

**** Usage

#+begin_src sh
$ flush_dns
#+end_src

**** Source

#+begin_src sh :tangle ./scripts/bin/flush_dns
# Purpose:
#   Flush the local DNS cache
# Usage:
#   $ flush_dns_cache

if [[ `uname` == "Darwin" ]]; then
    sudo killall -HUP mDNSResponder
fi
#+end_src

*** Refresh local git tags

Ensures that a local git repository's tags are in sync with the
remote origin

**** Usage

#+begin_src sh
$ refresh_tags
#+end_src

**** Source

#+begin_src sh :tangle ./scripts/bin/refresh_tags
# Purpose:
#   Delete all local tags and refresh from origin
# Usage:
#   $ refresh_tags

git tag -l | xargs git tag -d && git fetch
#+end_src

*** Emacs Lisp Testing

Runs an elisp test

**** Usage

#+begin_src sh
$ ert-run <path-to-test>.el
#+end_src

**** Source

#+begin_src sh ./scripts/bin/ert-run
# Purpose:
#   Runs an elisp test
# Usage:
#  $ ert-run <path-to-test>.el

emacs -batch -l ert -l $1 -f ert-run-tests-batch-and-exit
#+end_src
*** inode consumption

Find locations of dense inode consumption on disk

**** Usage

#+begin_src sh
$ inode-consumption
#+end_src

**** Source

#+begin_src sh :tangle ./scripts/bin/inode-consumption
# Purpose:
#   List locations on disk ranked by their inode consumption
# Usage:
#  $ inode-consumption

find / -xdev -printf '%h\n' | sort | uniq -c | sort -k 1 -n
#+end_src

*** Initial host setup script
:PROPERTIES:
:header-args: :mkdirp yes :tangle-mode (identity #o755) :shebang "#!/usr/bin/env bash" :tangle "./scripts/bin/initial-host-setup"
:END:

This section generates a script used to bootstrap new system with the
tools and configuration I use across hosts. Though running
=.files/install= generates this file, it is NOT run automatically. This
allows me to better control how and when the setup script runs during
initial setup.

The setup script resides in the =$HOME/bin= directory, which means it
should be executable on the user's =$PATH=. To start the initial host
setup process run =initial-host-setup=.

***** Common Packages

Define and install basic packages required to build and install software

#+begin_src sh :tangle "./scripts/bin/initial-host-setup"
PACKAGES="aspell automake autoconf bash emacs git libtool unzip curl bash-completion"
#+end_src

***** macOS Packages

****** Add "Package Manager"

macOS has a surprising lack of "package management system". Homebrew is
the closest thing, but has functional deficiencies. Nonetheless, in most
cases it's better than nothing so we ensure that it exists on macOS
hosts here.

#+begin_src sh :tangle (when (eq system-type 'darwin) "./scripts/bin/initial-host-setup")
if ! [ -x "$(command -v brew)" ]; then
    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
fi
brew update
brew tap homebrew/cask-versions
#+end_src
****** Additional macOS Packages

On macOS, ensure that these programs are present. Generally they're
required to build or support the tools I use to produce software.

#+begin_src sh :tangle (when (eq system-type 'darwin) "./scripts/bin/initial-host-setup")
PACKAGES="$PACKAGES ncurses openssl readline the_silver_searcher"
#+end_src

****** macOS Binary Packages

On macOS clients, also ensure that the following binary
applications are available for use.

#+begin_src sh :tangle "./scripts/bin/initial-host-setup"
BINARY_PACKAGES="emacs firefox-developer-edition gpg-suite iterm2 keepassxc nextcloud signal spectacle"
#+end_src

****** Install Packages

And now we're ready to ensure that each of the packages are
installed. On macOS hosts, we use Homebrew to install packages.

#+begin_src sh :tangle (when (eq system-type 'darwin) "./scripts/bin/initial-host-setup")
for package in $PACKAGES; do
    if [ "$( brew list -1 | grep $package )" == "" ]; then
        echo "installing $package"
        brew install $package
    else
        echo "$package installed"
    fi
done

for package in $BINARY_PACKAGES; do
    if [ "$( brew cask list -1 | grep $package )" == "" ]; then
        echo "installing $package"
        brew cask install $package
    else
        echo "$package installed"
    fi
done
#+end_src

****** macOS update =GNU bash=

Apple seems to hate the idea of [[https://www.fsf.org/][Free Software]] and has refused to update
the =bash= shell in macOS for some time - [[https://support.apple.com/en-ca/HT208050?fbclid=IwAR0Z1-TK9h3oInv_byv9fDa9EbxxxZoqSaI4Osfq5_fxDi7jXvKjS3YAKvk][in fact they've gone so far as
switching the user's default shell to zsh, and added an annoying
depreciation warning when using bash in their latest OS update]]...
LOLWAT? Here we'll use Homebrew to install a recent version of =GNU bash=
and make sure it's our user's default shell.

#+begin_src sh :tangle (when (eq system-type 'darwin) "./scripts/bin/initial-host-setup")
if [ -z $(grep /usr/local/bin/bash /etc/shells) ]
then
    sudo bash -c "echo /usr/local/bin/bash >> /etc/shells"
fi
#+end_src

Change the shell to bash for the rest of the setup script.  This
also has the affect of loading the newly generated bash
configuration which makes installing things like ASDF a bit easier.

#+begin_src sh :tangle (when (eq system-type 'darwin) "./scripts/bin/initial-host-setup")
if [[ "$(echo $SHELL)" != "/usr/local/bin/bash" ]]
then
    echo "Bash is not the current shell, changing shell..."
    chsh -s /usr/local/bin/bash 2>/dev/null
    /usr/local/bin/bash
    source $HOME/.bashrc
fi
#+end_src

***** GNU/Linux Packages

On GNU/Linux hosts, ensure that the following packages are present.

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./scripts/bin/initial-host-setup")
PACKAGES="$PACKAGES aspell git silversearcher-ag"
#+end_src

****** Install Packages
On GNU/Linux hosts - for which I always use Debian GNU/Linux -
we'll use the Aptitude Package Manager.

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./scripts/bin/initial-host-setup")
for package in $PACKAGES; do
    if [ "$(sudo apt-cache policy $package | grep 'Installed: (none)')" ]
    then
        sudo apt install -y $package
    else
        echo "$package is already installed";
    fi
done
#+end_src

****** Load the bash config

Load the newly generated bash configuration which makes installing
things like ASDF a bit easier.

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./scripts/bin/initial-host-setup")
source $HOME/.bashrc
#+end_src

***** Install asdf

I use [[https://asdf-vm.com/#/][asdf - the extensible version manager]] to manage the tooling
and runtimes in which I typically write software.

#+begin_src sh :tangle "./scripts/bin/initial-host-setup"
ASDF_DIR=$HOME/.asdf
if [ -e $ASDF_DIR ]; then
    echo "Updating $ASDF_DIR"
    asdf update
else
    echo "Installing ASDF"
    git clone https://github.com/asdf-vm/asdf.git $ASDF_DIR
    cd $ASDF_DIR
    git checkout "$(git describe --abbrev=0 --tags)"
fi
[ -f $HOME/.asdf/asdf.sh ] && source $HOME/.asdf/asdf.sh
[ -f $HOME/.asdf/completions/asdf.bash ] && source $HOME/.asdf/completions/asdf.bash
#+end_src

Now that asdf-vm is in place, install the language specific plugins I typically use.

#+begin_src sh :tangle "./scripts/bin/initial-host-setup"
ASDF_PLUGINS='ruby nodejs'
for plugin in $ASDF_PLUGINS; do
    if [ -e $ASDF_DIR/plugins/$plugin ]; then
        echo "asdf $plugin plugin already installed"
        asdf plugin-update $plugin
    else
        echo "installing asdf $plugin plugin"
        asdf plugin-add $plugin
    fi
done
#+end_src

Post install, the [[https://github.com/asdf-vm/asdf-nodejs][asdf-nodejs]] plugin requires manually importing
the team's nodejs team's keyring. Manual installation is for
suckers.

#+begin_src sh :tangle "./scripts/bin/initial-host-setup"
bash ~/.asdf/plugins/nodejs/bin/import-release-team-keyring
#+end_src

***** Install Docker

Ensures that docker is installed. On Mac OS X hosts, we use
[[https://brew.sh/][Homebrew]] to install Docker:

#+begin_src sh :tangle (when (eq system-type 'darwin) "./scripts/bin/initial-host-setup")
if [ $(which docker) ]; then
    echo "docker is already installed"
else
    brew cask install docker
fi
#+end_src

While on GNU/Linux hosts, we assume we're using my favorite distro -
Debian - and use the [[https://wiki.debian.org/Aptitude][Aptitude Package Manager]] to install Docker.

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./scripts/bin/initial-host-setup")
if [ $(which docker) ]
then
    echo "docker is already installed"
else
    echo "installing docker"
    sudo apt-get remove docker docker-engine docker.io containerd runc
    sudo apt-get update
    sudo apt-get install \
         apt-transport-https \
         ca-certificates \
         curl \
         gnupg2 \
         software-properties-common

    curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
    sudo add-apt-repository \
         "deb [arch=amd64] https://download.docker.com/linux/debian \
                 $(lsb_release -cs) \
                 stable"
    sudo apt-get update
    sudo apt install -y docker-ce docker-ce-cli containerd.io
    sudo groupadd docker
    sudo usermod -aG docker $USER
    newgrp docker
fi
#+end_src

***** Install docker-compose

Ensures that docker-compose is present and ready to use. On Mac OS X
this comes bundled in the Homebrew cask version of Docker, so there's
nothing for us to do. However on GNU/Linux hosts we need to do some
additional steps to get everything up and running.

#+begin_src sh :tangle (when (eq system-type 'gnu/linux) "./scripts/bin/initial-host-setup")
if [ $(which docker-compose) ]
then
    echo "Installing docker-compose..."
    sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    sudo chmod +x /usr/local/bin/docker-compose
    sudo curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose
else
    echo "docker-compose already installed. Skipping..."
fi
#+end_src
