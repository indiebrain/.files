#+TITLE: Dotfiles Configuration

Shell and CLI Tooling configuration

* bash

** .bash_profile

  Use the same configuration for =.bash_profile= as the =.bashrc=

  #+BEGIN_SRC sh :tangle ~/.bash_profile
    if [ -f ~/.bashrc ];
        then source ~/.bashrc
    fi
  #+END_SRC


** CLI Colors

   For commands that support colors, enable the use of colors to
   better visually understand the output of commands.

   #+BEGIN_SRC sh :tangle ~/.bashrc
     export CLICOLOR=1
   #+END_SRC


** $PATH

*** /usr/local/bin

   Binaries stored in the =/usr/local/bin= directory take precedence
   over their counterparts stored elsewhere on the =PATH=

   #+BEGIN_SRC sh :tangle ~/.bashrc
     export PATH=/usr/local/bin:/usr/local/sbin:$PATH
   #+END_SRC


*** .bin

   I keep personal scripts in =~/.bin=. Ensure that scripts found in
   =~/.bin= are available on the =PATH= so they can be executed
   without providing full paths:

   For example, instead of typing =~/.bin/script-name= simply type
   =script-name=.

   #+BEGIN_SRC sh :tangle ~/.bashrc
     export PATH=$PATH:$HOME/.bin
   #+END_SRC



** Aliases

*** *nix aliases

  Make =ls= output more information about files and directories in a
  human readable format.

  #+BEGIN_SRC sh :tangle ~/.bashrc
    alias ls='ls -lha'
  #+END_SRC



*** Git aliases

   =gs= is shorthand for the status of a git repository.

   #+BEGIN_SRC sh :tangle ~/.bashrc
     alias gs="git status"
   #+END_SRC

   =gl= shows the railroad tracks of the current head ref

   #+BEGIN_SRC sh :tangle ~/.bashrc
     alias gl='git log --graph --oneline --decorate --max-count 10'
   #+END_SRC



** Prompt

  Configure the shell prompt. This happens to check if we're in a git
  managed directory and adds some status info to the command line.

  #+BEGIN_SRC sh :tangle ~/.bashrc
    # Get a graphical representation of the clean/dirty state of a git repository
    function parse_git_dirty {
      [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit, working tree clean" ]] && echo -e '\033[31m ✪ \033[0m'|| echo -e '\033[32m ✪ \033[0m'
    }

    # Get the name of the current git brank
    function parse_git_branch {
      git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/[\1$(parse_git_dirty)]/"
    }

    # Set the prompt pattern
    export PS1='
    \[\033[0;32m\]\@\[\033[0m\] \[\033[1;33m\]\w\[\033[0m\] $(parse_git_branch)
    => '
  #+END_SRC


** Editors

   Use emacs as the default editor for the shell

   #+BEGIN_SRC sh :tangle ~/.bashrc
     export EDITOR=emacs
   #+END_SRC



* exenv


** elixir installation path

  Use the [[https://github.com/mururu/exenv][exenv]] project to manage local [[http://elixir-lang.org/][Elixir]] installations.

  Store installations in =/usr/local/var/exenv= instead of the user
  home directory so they're available to all users of the system.

  #+BEGIN_SRC sh :tangle ~/.bashrc
    export "EXENV_ROOT=/usr/local/var/exenv"
  #+END_SRC


** exenv initialization

  If the =exenv= command is available initialize the exenv
  system. This provides access to shims and autocompletion.

  #+BEGIN_SRC sh :tangle ~/.bashrc
    if which exenv > /dev/null; then eval "$(exenv init -)"; fi
  #+END_SRC



* rbenv

** ruby installation path

  Use the [[https://github.com/rbenv/rbenv][rbenv]] project to manage local [[https://www.ruby-lang.org][Ruby]] installations.

  Store installations in =/usr/local/var/rbenv= instead of the user
  home directory so they are available to all users of the system.

  #+BEGIN_SRC sh :tangle ~/.bashrc
    RBENV_ROOT=/usr/local/var/rbenv
  #+END_SRC


** rbenv initialization

  If the =rbenv= command is available initialize the rbenv
  system. This provides access to shims and autocompletion.

  #+BEGIN_SRC sh :tangle ~/.bashrc
    if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi
  #+END_SRC


* git

  Git Configuration

** .gitconfig

*** Author

  Configure information used by git to determine how to write the
  author information for commits

  #+BEGIN_SRC conf :tangle ~/.gitconfig
    [user]
      name = Aaron Kuehler
      email = aaron.kuehler@gmail.com
  #+END_SRC


*** Core configuration

  In addition to any files included in a project's =.gitignore= file,
  also include those listed in the =~/.gitconfig.=

  Use Emacs as the commit editor

  #+BEGIN_SRC conf :tangle ~/.gitconfig
    [core]
      excludesfile = ~/.gitignore
      editor = emacs -nw --eval '(global-git-commit-mode t)'
  #+END_SRC


*** Colors

  Enable coloring of git output

  #+BEGIN_SRC conf :tangle ~/.gitconfig
    [color]
      ui = true
  #+END_SRC


*** Aliases

  Set aliases for frequently used git incantations.

  #+BEGIN_SRC conf :tangle ~/.gitconfig
    [alias]
      co  = checkout
      cb  = checkout -b
      db  = branch -d
      rclone = clone --recursive
  #+END_SRC


*** Clean

  Disable the safeguard flag when running =git clean=

  #+BEGIN_SRC conf :tangle ~/.gitconfig
    [clean]
      requireForce = false
  #+END_SRC


*** Push

  Only push the current branch, rather than all
  branches, when =git push= is invoked.

  #+BEGIN_SRC conf :tangle ~/.gitconfig
    [push]
      default = simple
  #+END_SRC


*** Filter

  #+BEGIN_SRC conf :tangle ~/.gitconfig
    [filter "lfs"]
      clean = git-lfs clean %f
      smudge = git-lfs smudge %f
      required = true
  #+END_SRC


** .gitignore

*** Mac OS Finder cache

  Never ever store Mac OS Finder metadata in a git repository.

  #+BEGIN_SRC txt :tangle ~/.gitignore
    .DS_Store
  #+END_SRC

*** Emacs temp files

  Never store Emacs autosave and backup files in a git repository.

  #+BEGIN_SRC text
    ,*~
    .#*
    ,*#
  #+END_SRC


** tab completion

  Enable tab completion for the git.

  #+BEGIN_SRC sh :tangle ~/.bashrc
    GIT_TAB_COMPLETION_FILE=/usr/local/etc/bash_completion.d/git-completion.bash
    if [ -f $GIT_TAB_COMPLETION_FILE ];
       then source $GIT_TAB_COMPLETION_FILE
    fi
  #+END_SRC


* gem

  Ruby gems configuration

** Documentation

  When a gem is installed forego the generation of its documentation.

  #+BEGIN_SRC text :tangle ~/.gemrc
    gem: --no-document
  #+END_SRC


* Rspec

  rspec CLI configuration

** Color

  Enable colorized output

  #+BEGIN_SRC text :tangle ~/.rspec
    --color
  #+END_SRC


** Output format

  Output from spec runs should look like a progress bar

  #+BEGIN_SRC text :tangle ~/.rspec
    --format progress
  #+END_SRC


** Ordering

  Always run specs in a random order to ensure that examples are
  independent of one another.

  #+BEGIN_SRC text :tangle ~/.rspec
    --order random
  #+END_SRC
